<!DOCTYPE html><html lang="en" data-theme="light" data-toc-auto-collapse="1"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>CorrSteer</title><meta name="description" content="An interactive exploration of correlation-guided feature selection for controllable language model behavior using Sparse Autoencoders."><link rel="canonical" href="https://seongland.com/article/corrsteer"><meta property="og:type" content="article"><meta property="og:title" content="CorrSteer"><meta property="og:description" content="An interactive exploration of correlation-guided feature selection for controllable language model behavior using Sparse Autoencoders."><meta property="og:url" content="https://seongland.com/article/corrsteer"><meta property="og:image" content="https://seongland.com/thumb.auto.jpg"><meta property="article:published_time" content="Aug 18, 2025"><meta property="article:author" content="Seonglae Cho"><meta property="article:author" content="Zekun Wu"><meta property="article:author" content="Adriano Koshiyama"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="CorrSteer"><meta name="twitter:description" content="An interactive exploration of correlation-guided feature selection for controllable language model behavior using Sparse Autoencoders."><meta name="twitter:image" content="https://seongland.com/thumb.auto.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"CorrSteer","description":"An interactive exploration of correlation-guided feature selection for controllable language model behavior using Sparse Autoencoders.","datePublished":"Aug 18, 2025","author":[{"@type":"Person","name":"Seonglae Cho"},{"@type":"Person","name":"Zekun Wu"},{"@type":"Person","name":"Adriano Koshiyama"}],"keywords":"mechanistic-interpretability, sparse-autoencoders, llm-steering, alignment","mainEntityOfPage":"https://seongland.com/article/corrsteer","image":["https://seongland.com/thumb.auto.jpg"]}</script><script>
      (() => {
        try {
          const saved = localStorage.getItem("theme");
          const prefersDark =
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches;
          const theme = saved || (prefersDark ? "dark" : "light");
          document.documentElement.setAttribute("data-theme", theme);
        } catch {}
      })();
    </script><script type="module" src="/scripts/color-palettes.js"></script><!-- TO MANAGE PROPERLY --><script src="https://cdn.plot.ly/plotly-3.0.0.min.js" charset="utf-8"></script><link rel="stylesheet" href="/article/corrsteer/_astro/index.Bj7gm16P.css"><script type="module" src="/article/corrsteer/_astro/hoisted.BbIk-Ng4.js"></script></head> <body> <button id="theme-toggle" aria-label="Toggle color theme" data-astro-cid-x3pjskd3> <svg class="icon light" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <circle cx="12" cy="12" r="5" data-astro-cid-x3pjskd3></circle> <line x1="12" y1="1" x2="12" y2="4" data-astro-cid-x3pjskd3></line> <line x1="12" y1="20" x2="12" y2="23" data-astro-cid-x3pjskd3></line> <line x1="1" y1="12" x2="4" y2="12" data-astro-cid-x3pjskd3></line> <line x1="20" y1="12" x2="23" y2="12" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="4.22" x2="6.34" y2="6.34" data-astro-cid-x3pjskd3></line> <line x1="17.66" y1="17.66" x2="19.78" y2="19.78" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="19.78" x2="6.34" y2="17.66" data-astro-cid-x3pjskd3></line> <line x1="17.66" y1="6.34" x2="19.78" y2="4.22" data-astro-cid-x3pjskd3></line> </svg> <svg class="icon dark" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" data-astro-cid-x3pjskd3></path> </svg>  </button>  <section class="hero" data-astro-cid-bbe6dxrz> <h1 class="hero-title" data-astro-cid-bbe6dxrz>CorrSteer</h1> <div class="hero-banner" data-astro-cid-bbe6dxrz> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-xyd3rvawfec"><div class="corrsteer-hero" id="corrsteer-hero-container">
  <canvas id="corrsteer-hero-canvas"></canvas>
  <div class="hero-tokens" id="hero-tokens"></div>
  <div class="hero-hint" id="hero-hint">Try clicking layers to steer real-time generation</div>
</div>

<style>
  .corrsteer-hero {
    width: 100%;
    height: 450px;
    position: relative;
    overflow: hidden;
    border-radius: 16px;
  }
  .corrsteer-hero canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
    position: relative;
    z-index: 1;
  }
  .corrsteer-hero canvas:active {
    cursor: grabbing;
  }
  .hero-tokens {
    position: absolute;
    left: 82%;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 2px;
    pointer-events: none;
    z-index: 2;
  }
  .hero-token {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 4px;
    background: rgba(107, 92, 231, 0.15);
    color: rgba(107, 78, 196, 0.9);
    border: 1px solid rgba(107, 92, 231, 0.1);
    white-space: pre;
    line-height: 1.3;
    animation: tokenPop 0.25s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    opacity: 0;
  }
  .hero-token.out {
    animation: tokenOut 0.2s ease-in forwards;
  }
  @keyframes tokenPop {
    0% { opacity: 0; transform: scale(0.3); }
    60% { opacity: 1; transform: scale(1.05); }
    100% { opacity: 1; transform: scale(1); }
  }
  @keyframes tokenOut {
    to { opacity: 0; transform: translateX(16px) scale(0.7); }
  }
  [data-theme="dark"] .hero-token {
    background: rgba(155, 126, 240, 0.18);
    color: rgba(184, 154, 255, 0.9);
    border-color: rgba(155, 126, 240, 0.12);
  }
  .hero-hint {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 15px;
    color: rgba(0,0,0,0.4);
    pointer-events: none;
    z-index: 3;
    white-space: nowrap;
    transition: opacity 0.5s;
  }
  [data-theme="dark"] .hero-hint {
    color: rgba(255,255,255,0.3);
  }
  @media (max-width: 768px) {
    .corrsteer-hero { height: 320px; }
    .hero-token { font-size: 9px; }
    .hero-hint { font-size: 10px; }
  }
  @media (max-width: 480px) {
    .corrsteer-hero { height: 260px; }
    .hero-tokens { display: none; }
    .hero-hint { display: none; }
  }
</style>

<script>
(function() {
  'use strict';

  // ---- Theme detection ----
  function getTheme() {
    var attr = document.documentElement.getAttribute('data-theme');
    return attr === 'dark' ? 'dark' : 'light';
  }

  // ---- Color palettes (bg matches page --page-bg) ----
  var PALETTE = {
    light: {
      bg:             0xffffff,
      layerColor:     0x5b4ba5,
      layerOpacity:   0.25,
      layerEdge:      0x6b5bb5,
      particleMuted:  0x8b8fa5,
      particleActive: 0x6b4ec4,
      particleGlow:   0x7c5ce6,
      targetZone:     0x6b4ec4,
      fogColor:       0xffffff,
      fogNear:        15,
      fogFar:         45,
      ambientLight:   0xffffff,
      dirLight:       0xffffff,
      gridColor:      0xc8ccd5,
      blending:       'normal'
    },
    dark: {
      bg:             0x0f1115,
      layerColor:     0xe0d8ff,
      layerOpacity:   0.45,
      layerEdge:      0xf0e8ff,
      particleMuted:  0x4b5563,
      particleActive: 0x9b7ef0,
      particleGlow:   0xb89aff,
      targetZone:     0x9b7ef0,
      fogColor:       0x0f1115,
      fogNear:        12,
      fogFar:         30,
      ambientLight:   0x334155,
      dirLight:       0xcdd5e0,
      gridColor:      0x1e2735,
      blending:       'additive'
    }
  };

  function getBlending(THREE) {
    return currentPalette.blending === 'additive' ? THREE.AdditiveBlending : THREE.NormalBlending;
  }

  var container, canvas, renderer, scene, camera, clock;
  var layerMeshes = [];
  var layerEdgeMeshes = [];
  var particleSystem, glowParticleSystem;
  var targetZoneMesh;
  var gridLines;
  var animFrameId = null;
  var currentPalette;
  var isInitialized = false;

  // ---- Mouse interaction state ----
  var mouseNDC = { x: 0, y: 0 };
  var mouseWorld = { x: 0, y: 0, z: 0 };
  var isMouseOver = false;
  var isMouseDown = false;
  var mouseInfluenceRadius = 3.0;
  var raycaster, mousePlane;

  // Particle state arrays
  var NUM_PARTICLES = 400;
  var NUM_GLOW = 120;
  var particlePositions, particleVelocities, particlePhases, particleLifetimes;
  var glowPositions, glowVelocities, glowPhases, glowLifetimes, glowActivation;
  var particleSizes, glowSizes, particleAlphas, glowAlphas;

  // ---- Steering interaction state ----
  var STEER_COLORS = [
    { r: 0.90, g: 0.35, b: 0.35 },  // red
    { r: 0.30, g: 0.75, b: 0.50 },  // green
    { r: 0.30, g: 0.60, b: 0.90 },  // blue
    { r: 0.90, g: 0.65, b: 0.20 },  // orange
    { r: 0.80, g: 0.35, b: 0.70 },  // pink
    { r: 0.25, g: 0.75, b: 0.80 },  // teal
    { r: 0.70, g: 0.55, b: 0.20 },  // gold
    { r: 0.55, g: 0.40, b: 0.85 },  // indigo
  ];
  var steerColorIdx = 0;
  var layerColorMap = {}; // layerIdx → color, so same layer always gets same color
  var NUM_STEER = 200;
  var PARTICLES_PER_BLOB = 6;
  var steerParticleSystem;
  var steerPositions, steerVelocities, steerColors, steerAlphas, steerSizes, steerLifetimes;
  var steerActive = new Uint8Array(NUM_STEER);
  var steerBlobs = []; // { cx, cy, cz, vx, color, particleIndices, life, tokenSpawned }
  var steerNeedsFlush = false;

  // Scene dimensions
  var SCENE_WIDTH = 14;
  var SCENE_HEIGHT = 5;
  var SCENE_DEPTH = 4;
  var NUM_LAYERS = 8;
  var LAYER_SPACING = SCENE_WIDTH / (NUM_LAYERS + 1);

  // ---- Initialization ----
  function init() {
    container = document.getElementById('corrsteer-hero-container');
    canvas = document.getElementById('corrsteer-hero-canvas');
    if (!container || !canvas) return;

    currentPalette = PALETTE[getTheme()];

    var THREE = window.THREE;
    var w = container.clientWidth;
    var h = container.clientHeight;

    // Renderer
    renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: false
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(w, h);
    renderer.setClearColor(currentPalette.bg, 1);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;

    // Scene
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(currentPalette.fogColor, currentPalette.fogNear, currentPalette.fogFar);

    // Camera
    camera = new THREE.PerspectiveCamera(32, w / h, 0.1, 100);
    camera.position.set(0, 0, 20);
    camera.lookAt(0, 0, 0);

    clock = new THREE.Clock();

    // Lights
    var ambientLight = new THREE.AmbientLight(currentPalette.ambientLight, 0.6);
    ambientLight.name = 'ambient';
    scene.add(ambientLight);

    var dirLight = new THREE.DirectionalLight(currentPalette.dirLight, 0.8);
    dirLight.position.set(5, 8, 6);
    dirLight.name = 'dirLight';
    scene.add(dirLight);

    var pointLight = new THREE.PointLight(currentPalette.particleGlow, 0.4, 20);
    pointLight.position.set(3, 2, 0);
    pointLight.name = 'pointLight';
    scene.add(pointLight);

    // Build scene elements
    createTransformerLayers(THREE);
    createParticles(THREE);
    createGlowParticles(THREE);
    createSteerParticles(THREE);
    createTargetZone(THREE);
    createGridLines(THREE);
    createCircuits(THREE);

    // Raycaster + invisible plane for mouse-to-world projection
    raycaster = new THREE.Raycaster();
    mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

    // Mouse / touch listeners
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseenter', function() { isMouseOver = true; });
    canvas.addEventListener('mouseleave', function() { isMouseOver = false; });
    canvas.addEventListener('mousedown', function() { isMouseDown = true; });
    canvas.addEventListener('mouseup', function() { isMouseDown = false; });
    canvas.addEventListener('touchmove', onTouchMove, { passive: true });
    canvas.addEventListener('touchstart', function(e) {
      isMouseOver = true; isMouseDown = true;
      onTouchMove(e);
    }, { passive: true });
    canvas.addEventListener('touchend', function() { isMouseOver = false; isMouseDown = false; });
    canvas.addEventListener('click', onCanvasClick);
    canvas.style.cursor = 'pointer';

    isInitialized = true;

    // Start loop
    animate();

    // Start token generation overlay
    startTokenAnimation();

    // Resize observer
    var ro = new ResizeObserver(function() { onResize(); });
    ro.observe(container);

    // Theme observer
    var mo = new MutationObserver(function(mutations) {
      for (var i = 0; i < mutations.length; i++) {
        if (mutations[i].attributeName === 'data-theme') {
          updateTheme();
          break;
        }
      }
    });
    mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
  }

  // ---- Transformer layers ----
  function createTransformerLayers(THREE) {
    var layerW = 0.15;
    var layerH = 3.2;
    var layerD = 2.8;

    for (var i = 0; i < NUM_LAYERS; i++) {
      var x = -SCENE_WIDTH / 2 + LAYER_SPACING * (i + 1);

      // Main translucent layer — 3D BoxGeometry
      var geom = new THREE.BoxGeometry(layerW, layerH, layerD);
      var mat = new THREE.MeshPhysicalMaterial({
        color: currentPalette.layerColor,
        transparent: true,
        opacity: currentPalette.layerOpacity,
        roughness: 0.2,
        metalness: 0.1,
        transmission: 0.6,
        thickness: 0.5,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      var mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(x, 0, 0);
      scene.add(mesh);
      layerMeshes.push(mesh);

      // Edge wireframe
      var edgeGeom = new THREE.EdgesGeometry(geom);
      var edgeMat = new THREE.LineBasicMaterial({
        color: currentPalette.layerEdge,
        transparent: true,
        opacity: 0.25,
        linewidth: 1
      });
      var edgeMesh = new THREE.LineSegments(edgeGeom, edgeMat);
      edgeMesh.position.copy(mesh.position);
      scene.add(edgeMesh);
      layerEdgeMeshes.push(edgeMesh);
    }
  }

  // ---- Muted particles (non-correlated) ----
  function createParticles(THREE) {
    var positions = new Float32Array(NUM_PARTICLES * 3);
    var sizes = new Float32Array(NUM_PARTICLES);
    var alphas = new Float32Array(NUM_PARTICLES);

    particlePositions = new Float32Array(NUM_PARTICLES * 3);
    particleVelocities = new Float32Array(NUM_PARTICLES * 3);
    particlePhases = new Float32Array(NUM_PARTICLES);
    particleLifetimes = new Float32Array(NUM_PARTICLES);
    particleSizes = sizes;
    particleAlphas = alphas;

    for (var i = 0; i < NUM_PARTICLES; i++) {
      resetParticle(i, true);
      positions[i * 3]     = particlePositions[i * 3];
      positions[i * 3 + 1] = particlePositions[i * 3 + 1];
      positions[i * 3 + 2] = particlePositions[i * 3 + 2];
      sizes[i] = 2.5 + Math.random() * 2.5;
      alphas[i] = 0.4 + Math.random() * 0.4;
    }

    var geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

    var mat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(currentPalette.particleMuted) },
        uPixelRatio: { value: renderer.getPixelRatio() }
      },
      vertexShader: [
        'attribute float size;',
        'attribute float alpha;',
        'varying float vAlpha;',
        'uniform float uPixelRatio;',
        'void main() {',
        '  vAlpha = alpha;',
        '  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);',
        '  gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z);',
        '  gl_Position = projectionMatrix * mvPosition;',
        '}'
      ].join('\n'),
      fragmentShader: [
        'uniform vec3 uColor;',
        'varying float vAlpha;',
        'void main() {',
        '  float dist = length(gl_PointCoord - vec2(0.5));',
        '  if (dist > 0.5) discard;',
        '  float strength = 1.0 - smoothstep(0.0, 0.5, dist);',
        '  strength = pow(strength, 1.5);',
        '  gl_FragColor = vec4(uColor, vAlpha * strength);',
        '}'
      ].join('\n'),
      transparent: true,
      depthWrite: false,
      blending: getBlending(THREE)
    });

    particleSystem = new THREE.Points(geom, mat);
    scene.add(particleSystem);
  }

  function resetParticle(i, randomX) {
    var xStart = randomX
      ? -SCENE_WIDTH / 2 - 1 + Math.random() * (SCENE_WIDTH + 2)
      : -SCENE_WIDTH / 2 - 1 - Math.random() * 2;
    particlePositions[i * 3]     = xStart;
    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * SCENE_HEIGHT * 0.6;
    particlePositions[i * 3 + 2] = (Math.random() - 0.5) * SCENE_DEPTH * 0.8;
    particleVelocities[i * 3]     = 0.3 + Math.random() * 0.6;
    particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.05;
    particleVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.03;
    particlePhases[i] = Math.random() * Math.PI * 2;
    particleLifetimes[i] = 0;
  }

  // ---- Glow particles (correlated features) ----
  function createGlowParticles(THREE) {
    var positions = new Float32Array(NUM_GLOW * 3);
    var sizes = new Float32Array(NUM_GLOW);
    var alphas = new Float32Array(NUM_GLOW);

    glowPositions = new Float32Array(NUM_GLOW * 3);
    glowVelocities = new Float32Array(NUM_GLOW * 3);
    glowPhases = new Float32Array(NUM_GLOW);
    glowLifetimes = new Float32Array(NUM_GLOW);
    glowActivation = new Float32Array(NUM_GLOW);
    glowSizes = sizes;
    glowAlphas = alphas;

    for (var i = 0; i < NUM_GLOW; i++) {
      resetGlowParticle(i, true);
      positions[i * 3]     = glowPositions[i * 3];
      positions[i * 3 + 1] = glowPositions[i * 3 + 1];
      positions[i * 3 + 2] = glowPositions[i * 3 + 2];
      sizes[i] = 3.5 + Math.random() * 3.0;
      alphas[i] = 0.6 + Math.random() * 0.4;
    }

    var geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

    var mat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(currentPalette.particleActive) },
        uGlowColor: { value: new THREE.Color(currentPalette.particleGlow) },
        uPixelRatio: { value: renderer.getPixelRatio() }
      },
      vertexShader: [
        'attribute float size;',
        'attribute float alpha;',
        'varying float vAlpha;',
        'varying float vSize;',
        'uniform float uPixelRatio;',
        'void main() {',
        '  vAlpha = alpha;',
        '  vSize = size;',
        '  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);',
        '  gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z);',
        '  gl_Position = projectionMatrix * mvPosition;',
        '}'
      ].join('\n'),
      fragmentShader: [
        'uniform vec3 uColor;',
        'uniform vec3 uGlowColor;',
        'varying float vAlpha;',
        'varying float vSize;',
        'void main() {',
        '  float dist = length(gl_PointCoord - vec2(0.5));',
        '  if (dist > 0.5) discard;',
        '  float core = 1.0 - smoothstep(0.0, 0.15, dist);',
        '  float mid = 1.0 - smoothstep(0.0, 0.3, dist);',
        '  mid = pow(mid, 2.0);',
        '  float halo = 1.0 - smoothstep(0.0, 0.5, dist);',
        '  halo = pow(halo, 3.0);',
        '  vec3 color = mix(uColor, uGlowColor, core * 0.7 + mid * 0.3);',
        '  color = mix(color, vec3(1.0), core * 0.3);',
        '  float alpha = vAlpha * (core * 1.0 + mid * 0.6 + halo * 0.3);',
        '  gl_FragColor = vec4(color, alpha);',
        '}'
      ].join('\n'),
      transparent: true,
      depthWrite: false,
      blending: getBlending(THREE)
    });

    glowParticleSystem = new THREE.Points(geom, mat);
    scene.add(glowParticleSystem);
  }

  function resetGlowParticle(i, randomX) {
    var xStart = randomX
      ? -SCENE_WIDTH / 2 - 1 + Math.random() * (SCENE_WIDTH + 2)
      : -SCENE_WIDTH / 2 - 1 - Math.random() * 2;
    glowPositions[i * 3]     = xStart;
    glowPositions[i * 3 + 1] = (Math.random() - 0.5) * SCENE_HEIGHT * 0.5;
    glowPositions[i * 3 + 2] = (Math.random() - 0.5) * SCENE_DEPTH * 0.6;
    glowVelocities[i * 3]     = 0.4 + Math.random() * 0.5;
    glowVelocities[i * 3 + 1] = 0;
    glowVelocities[i * 3 + 2] = 0;
    glowPhases[i] = Math.random() * Math.PI * 2;
    glowLifetimes[i] = 0;
    glowActivation[i] = 0;
  }

  // ---- Steering particles (colored, spawned on layer click) ----
  function createSteerParticles(THREE) {
    var positions = new Float32Array(NUM_STEER * 3);
    var colors = new Float32Array(NUM_STEER * 3);
    var sizes = new Float32Array(NUM_STEER);
    var alphas = new Float32Array(NUM_STEER);

    steerPositions = new Float32Array(NUM_STEER * 3);
    steerVelocities = new Float32Array(NUM_STEER * 3);
    steerColors = colors;
    steerSizes = sizes;
    steerAlphas = alphas;
    steerLifetimes = new Float32Array(NUM_STEER);
    steerActive = new Uint8Array(NUM_STEER);

    var geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

    var mat = new THREE.ShaderMaterial({
      uniforms: {
        uPixelRatio: { value: renderer.getPixelRatio() }
      },
      vertexShader: [
        'attribute float size;',
        'attribute float alpha;',
        'attribute vec3 color;',
        'varying float vAlpha;',
        'varying vec3 vColor;',
        'uniform float uPixelRatio;',
        'void main() {',
        '  vAlpha = alpha;',
        '  vColor = color;',
        '  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);',
        '  gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z);',
        '  gl_Position = projectionMatrix * mvPosition;',
        '}'
      ].join('\n'),
      fragmentShader: [
        'varying float vAlpha;',
        'varying vec3 vColor;',
        'void main() {',
        '  float dist = length(gl_PointCoord - vec2(0.5));',
        '  if (dist > 0.5) discard;',
        '  float core = 1.0 - smoothstep(0.0, 0.2, dist);',
        '  float halo = 1.0 - smoothstep(0.0, 0.5, dist);',
        '  halo = pow(halo, 2.0);',
        '  vec3 col = mix(vColor, vec3(1.0), core * 0.4);',
        '  gl_FragColor = vec4(col, vAlpha * (core + halo * 0.4));',
        '}'
      ].join('\n'),
      transparent: true,
      depthWrite: false,
      blending: getBlending(THREE)
    });

    steerParticleSystem = new THREE.Points(geom, mat);
    steerParticleSystem.frustumCulled = false;
    scene.add(steerParticleSystem);
  }

  function spawnSteerBlob(layerIdx, color, hitY, hitZ) {
    var lx = layerMeshes[layerIdx].position.x;
    var cy = hitY != null ? hitY : 0;
    var cz = hitZ != null ? hitZ : 0;
    var indices = [];
    for (var i = 0; i < NUM_STEER && indices.length < PARTICLES_PER_BLOB; i++) {
      if (steerActive[i]) continue;
      steerActive[i] = 1;
      indices.push(i);
    }
    // If not enough free slots, recycle oldest blob
    while (indices.length < PARTICLES_PER_BLOB && steerBlobs.length > 0) {
      var old = steerBlobs.shift();
      for (var q = 0; q < old.particleIndices.length; q++) {
        var pi = old.particleIndices[q];
        steerActive[pi] = 0;
        if (indices.length < PARTICLES_PER_BLOB) {
          steerActive[pi] = 1;
          indices.push(pi);
        }
      }
    }
    for (var j = 0; j < indices.length; j++) {
      var i = indices[j];
      steerPositions[i * 3] = lx + (Math.random() - 0.5) * 0.3;
      steerPositions[i * 3 + 1] = cy + (Math.random() - 0.5) * 0.3;
      steerPositions[i * 3 + 2] = cz + (Math.random() - 0.5) * 0.3;
      steerColors[i * 3] = color.r;
      steerColors[i * 3 + 1] = color.g;
      steerColors[i * 3 + 2] = color.b;
      steerSizes[i] = 4.0 + Math.random() * 2.0;
      steerAlphas[i] = 0.9;
      steerLifetimes[i] = 0;
    }
    if (indices.length > 0) {
      steerBlobs.push({
        cx: lx, cy: cy, cz: cz,
        vx: 1.2 + Math.random() * 0.4,
        color: color,
        particleIndices: indices,
        life: 0,
        tokenSpawned: false
      });
    }
  }

  function updateSteerParticles(dt, time) {
    if (!steerParticleSystem) return;
    var posAttr = steerParticleSystem.geometry.getAttribute('position');
    var colorAttr = steerParticleSystem.geometry.getAttribute('color');
    var sizeAttr = steerParticleSystem.geometry.getAttribute('size');
    var alphaAttr = steerParticleSystem.geometry.getAttribute('alpha');
    var xMax = SCENE_WIDTH / 2 + 2;
    var lastLayerX = layerMeshes[NUM_LAYERS - 1].position.x;
    var tokenZoneX = lastLayerX + 2.5;

    // Update each blob
    for (var b = steerBlobs.length - 1; b >= 0; b--) {
      var blob = steerBlobs[b];
      blob.life += dt;

      // Move blob center rightward
      blob.cx += blob.vx * dt;
      blob.cy += Math.sin(time * 1.5 + b * 2.0) * 0.003;
      blob.cz += Math.cos(time * 1.0 + b * 3.0) * 0.002;

      // Converge Y/Z after last layer
      if (blob.cx > lastLayerX) {
        var converge = Math.min(1.0, (blob.cx - lastLayerX) / 2.0);
        converge = converge * converge;
        blob.cy += (0 - blob.cy) * converge * dt * 3.0;
        blob.cz += (0 - blob.cz) * converge * dt * 3.0;
      }

      // Spawn token when blob reaches token zone
      if (blob.cx > tokenZoneX && !blob.tokenSpawned) {
        blob.tokenSpawned = true;
        addSteerToken(blob.color);
      }

      // Disappear immediately after token spawned
      if (blob.tokenSpawned) {
        for (var q = 0; q < blob.particleIndices.length; q++) {
          steerActive[blob.particleIndices[q]] = 0;
          alphaAttr.array[blob.particleIndices[q]] = 0;
        }
        steerBlobs.splice(b, 1);
        continue;
      }
      var blobAlpha = 1.0;

      // Update particles orbiting blob center
      var allDead = true;
      for (var p = 0; p < blob.particleIndices.length; p++) {
        var i = blob.particleIndices[p];
        var angle = time * 2.0 + p * (Math.PI * 2 / blob.particleIndices.length);
        var orbitR = 0.15 + 0.05 * Math.sin(time * 3.0 + p);
        steerPositions[i * 3] = blob.cx + Math.cos(angle) * orbitR * 0.5;
        steerPositions[i * 3 + 1] = blob.cy + Math.sin(angle) * orbitR;
        steerPositions[i * 3 + 2] = blob.cz + Math.cos(angle * 0.7 + p) * orbitR * 0.3;

        var pAlpha = blobAlpha * (0.7 + 0.3 * Math.sin(time * 4.0 + p));
        alphaAttr.array[i] = Math.max(0, pAlpha);
        sizeAttr.array[i] = 4.0 + 2.0 * Math.sin(time * 2.0 + p * 1.5);
        if (pAlpha > 0) allDead = false;

        posAttr.array[i * 3] = steerPositions[i * 3];
        posAttr.array[i * 3 + 1] = steerPositions[i * 3 + 1];
        posAttr.array[i * 3 + 2] = steerPositions[i * 3 + 2];
      }

      // Remove blob when fully faded
      if (allDead || blob.cx > xMax) {
        for (var q = 0; q < blob.particleIndices.length; q++) {
          steerActive[blob.particleIndices[q]] = 0;
          alphaAttr.array[blob.particleIndices[q]] = 0;
        }
        steerBlobs.splice(b, 1);
      }
    }

    if (steerBlobs.length > 0 || steerNeedsFlush) {
      posAttr.needsUpdate = true;
      colorAttr.needsUpdate = true;
      sizeAttr.needsUpdate = true;
      alphaAttr.needsUpdate = true;
      steerNeedsFlush = steerBlobs.length > 0;
    }
  }

  function onCanvasClick(e) {
    if (!raycaster || !camera) return;
    var rect = canvas.getBoundingClientRect();
    var nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    var THREE = window.THREE;
    raycaster.setFromCamera(new THREE.Vector2(nx, ny), camera);
    // Check intersection with layer meshes
    var hits = raycaster.intersectObjects(layerMeshes);
    if (hits.length > 0) {
      var hitLayer = layerMeshes.indexOf(hits[0].object);
      if (hitLayer >= 0) {
        // Same layer always gets the same color
        if (!(hitLayer in layerColorMap)) {
          layerColorMap[hitLayer] = STEER_COLORS[steerColorIdx % STEER_COLORS.length];
          steerColorIdx++;
        }
        var hitPt = hits[0].point;
        spawnSteerBlob(hitLayer, layerColorMap[hitLayer], hitPt.y, hitPt.z);
        // keep hint visible
      }
    }
  }

  // ---- Target zone (upper right) ----
  function createTargetZone(THREE) {
    // Target zone removed — was a distracting circle in top-right
  }

  // ---- Subtle grid lines ----
  function createGridLines(THREE) {
    var gridGroup = new THREE.Group();
    var mat = new THREE.LineBasicMaterial({
      color: currentPalette.gridColor,
      transparent: true,
      opacity: 0.15
    });

    for (var z = -3; z <= 3; z += 1) {
      var pts = [
        new THREE.Vector3(-SCENE_WIDTH / 2 - 2, -SCENE_HEIGHT / 2, z),
        new THREE.Vector3(SCENE_WIDTH / 2 + 2, -SCENE_HEIGHT / 2, z)
      ];
      var geom = new THREE.BufferGeometry().setFromPoints(pts);
      gridGroup.add(new THREE.Line(geom, mat));
    }
    for (var x = -8; x <= 8; x += 2) {
      var pts2 = [
        new THREE.Vector3(x, -SCENE_HEIGHT / 2, -3),
        new THREE.Vector3(x, -SCENE_HEIGHT / 2, 3)
      ];
      var geom2 = new THREE.BufferGeometry().setFromPoints(pts2);
      gridGroup.add(new THREE.Line(geom2, mat));
    }

    gridLines = gridGroup;
    scene.add(gridGroup);
  }

  // ---- Circuit connections (sparse activation flashes between glow particles) ----
  var NUM_CIRCUITS = 15;
  var circuitMesh;
  var circuitState = [];
  var CIRCUIT_WIDTH = 0.04;

  function createCircuits(THREE) {
    var numVerts = NUM_CIRCUITS * 4;
    var numIdx = NUM_CIRCUITS * 6;
    var positions = new Float32Array(numVerts * 3);
    var alphas = new Float32Array(numVerts);
    var colors = new Float32Array(numVerts * 3);
    var indices = new Uint16Array(numIdx);

    for (var i = 0; i < NUM_CIRCUITS; i++) {
      circuitState.push({
        fromIdx: -1, toIdx: -1,
        life: 0, maxLife: 0,
        cooldown: Math.random() * 2.0,
        active: false,
        color: null
      });
      var vi = i * 4;
      var ii = i * 6;
      indices[ii]     = vi;     indices[ii + 1] = vi + 1; indices[ii + 2] = vi + 2;
      indices[ii + 3] = vi + 2; indices[ii + 4] = vi + 1; indices[ii + 5] = vi + 3;
    }

    var geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geom.setIndex(new THREE.BufferAttribute(indices, 1));

    var mat = new THREE.ShaderMaterial({
      vertexShader: [
        'attribute float alpha;',
        'attribute vec3 color;',
        'varying float vAlpha;',
        'varying vec3 vColor;',
        'void main() {',
        '  vAlpha = alpha;',
        '  vColor = color;',
        '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
        '}'
      ].join('\n'),
      fragmentShader: [
        'varying float vAlpha;',
        'varying vec3 vColor;',
        'void main() {',
        '  vec3 col = mix(vColor, vec3(1.0), vAlpha * 0.3);',
        '  gl_FragColor = vec4(col, vAlpha * 0.85);',
        '}'
      ].join('\n'),
      transparent: true,
      depthWrite: false,
      blending: getBlending(THREE),
      side: THREE.DoubleSide
    });

    circuitMesh = new THREE.Mesh(geom, mat);
    scene.add(circuitMesh);
  }

  function findNearbyGlowPair() {
    // Only spark when glow particles are precisely at adjacent layer positions
    var layerIdx = Math.floor(Math.random() * (NUM_LAYERS - 1));
    var lxA = layerMeshes[layerIdx].position.x;
    var lxB = layerMeshes[layerIdx + 1].position.x;
    var threshold = 0.15; // must be inside the layer

    var poolA = [], poolB = [];
    for (var i = 0; i < NUM_GLOW; i++) {
      var px = glowPositions[i * 3];
      if (Math.abs(px - lxA) < threshold) poolA.push(i);
      else if (Math.abs(px - lxB) < threshold) poolB.push(i);
    }
    if (poolA.length === 0 || poolB.length === 0) return null;

    var bestA = poolA[0], bestActA = glowActivation[poolA[0]];
    for (var j = 1; j < poolA.length; j++) {
      if (glowActivation[poolA[j]] > bestActA) {
        bestActA = glowActivation[poolA[j]];
        bestA = poolA[j];
      }
    }
    var bestB = poolB[0], bestActB = glowActivation[poolB[0]];
    for (var k = 1; k < poolB.length; k++) {
      if (glowActivation[poolB[k]] > bestActB) {
        bestActB = glowActivation[poolB[k]];
        bestB = poolB[k];
      }
    }
    return [bestA, bestB];
  }

  // For colored circuits: store world positions directly instead of glow indices
  function fireCircuit(idx) {
    var c = circuitState[idx];
    c.color = null;
    c.customFrom = null;
    c.customTo = null;

    // Colored spark: connect a steer blob particle to a glow particle at adjacent layer
    for (var b = 0; b < steerBlobs.length; b++) {
      var blob = steerBlobs[b];
      var bx = blob.cx;
      for (var L = 0; L < NUM_LAYERS; L++) {
        var lx = layerMeshes[L].position.x;
        if (Math.abs(bx - lx) > 0.15) continue;
        // Pick a steer particle from this blob as endpoint A
        var si = blob.particleIndices[Math.floor(Math.random() * blob.particleIndices.length)];
        // Find glow particle at adjacent layer as endpoint B
        var adj = (L < NUM_LAYERS - 1) ? L + 1 : L - 1;
        var lxAdj = layerMeshes[adj].position.x;
        var pB = -1;
        for (var i = 0; i < NUM_GLOW; i++) {
          if (Math.abs(glowPositions[i * 3] - lxAdj) < 0.15) { pB = i; break; }
        }
        if (pB >= 0) {
          // Use steer particle position as "from", glow as "to"
          c.customFrom = { x: steerPositions[si * 3], y: steerPositions[si * 3 + 1], z: steerPositions[si * 3 + 2] };
          c.fromIdx = -1; c.toIdx = pB;
          c.life = 0; c.maxLife = 0.08 + Math.random() * 0.15;
          c.active = true;
          c.color = blob.color;
          return true;
        }
      }
    }

    // Default: purple sparks between glow particles at layer positions
    var pair = findNearbyGlowPair();
    if (!pair) return false;
    c.fromIdx = pair[0]; c.toIdx = pair[1];
    c.life = 0; c.maxLife = 0.08 + Math.random() * 0.2;
    c.active = true;
    return true;
  }

  function updateCircuits(dt, time) {
    if (!circuitMesh) return;
    var posAttr = circuitMesh.geometry.getAttribute('position');
    var alphaAttr = circuitMesh.geometry.getAttribute('alpha');
    var colorAttr = circuitMesh.geometry.getAttribute('color');

    // Default glow color from palette
    var defR = ((currentPalette.particleGlow >> 16) & 255) / 255;
    var defG = ((currentPalette.particleGlow >> 8) & 255) / 255;
    var defB = (currentPalette.particleGlow & 255) / 255;

    for (var i = 0; i < NUM_CIRCUITS; i++) {
      var c = circuitState[i];
      var vi = i * 4;

      if (!c.active) {
        c.cooldown -= dt;
        if (c.cooldown <= 0) {
          if (!fireCircuit(i)) {
            c.cooldown = 0.5 + Math.random() * 1.0;
            for (var k = 0; k < 4; k++) alphaAttr.array[vi + k] = 0;
            continue;
          }
        } else {
          c.cooldown -= isMouseOver ? dt * 2 : 0;
          for (var k = 0; k < 4; k++) alphaAttr.array[vi + k] = 0;
          continue;
        }
      }

      c.life += dt;
      if (c.life >= c.maxLife) {
        c.active = false;
        c.cooldown = 0.2 + Math.random() * 2.0;
        for (var k2 = 0; k2 < 4; k2++) alphaAttr.array[vi + k2] = 0;
        continue;
      }

      var t = c.life / c.maxLife;
      var envelope = t < 0.05 ? t / 0.05 : Math.pow(1.0 - t, 2.0);
      envelope = Math.max(0, Math.min(1, envelope));

      var ax, ay, az;
      if (c.customFrom) {
        ax = c.customFrom.x; ay = c.customFrom.y; az = c.customFrom.z;
      } else {
        ax = glowPositions[c.fromIdx * 3];
        ay = glowPositions[c.fromIdx * 3 + 1];
        az = glowPositions[c.fromIdx * 3 + 2];
      }
      var bx = glowPositions[c.toIdx * 3];
      var by = glowPositions[c.toIdx * 3 + 1];
      var bz = glowPositions[c.toIdx * 3 + 2];

      var dx = bx - ax, dy = by - ay, dz = bz - az;
      var len = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (len < 0.01) { len = 1; dx = 1; dy = 0; dz = 0; }

      var nx = -dy / len, ny = dx / len;
      var w = CIRCUIT_WIDTH * (0.5 + envelope * 0.5);

      posAttr.array[vi * 3]     = ax - nx * w;
      posAttr.array[vi * 3 + 1] = ay - ny * w;
      posAttr.array[vi * 3 + 2] = az;
      posAttr.array[(vi+1) * 3]     = ax + nx * w;
      posAttr.array[(vi+1) * 3 + 1] = ay + ny * w;
      posAttr.array[(vi+1) * 3 + 2] = az;
      posAttr.array[(vi+2) * 3]     = bx - nx * w;
      posAttr.array[(vi+2) * 3 + 1] = by - ny * w;
      posAttr.array[(vi+2) * 3 + 2] = bz;
      posAttr.array[(vi+3) * 3]     = bx + nx * w;
      posAttr.array[(vi+3) * 3 + 1] = by + ny * w;
      posAttr.array[(vi+3) * 3 + 2] = bz;

      // Per-vertex color: blob color or default glow
      var cr = defR, cg = defG, cb = defB;
      if (c.color) { cr = c.color.r; cg = c.color.g; cb = c.color.b; }
      for (var k3 = 0; k3 < 4; k3++) {
        alphaAttr.array[vi + k3] = envelope;
        colorAttr.array[(vi + k3) * 3]     = cr;
        colorAttr.array[(vi + k3) * 3 + 1] = cg;
        colorAttr.array[(vi + k3) * 3 + 2] = cb;
      }
    }

    posAttr.needsUpdate = true;
    alphaAttr.needsUpdate = true;
    colorAttr.needsUpdate = true;
  }

  // ---- Particle update ----
  function updateParticles(dt, time) {
    if (!particleSystem) return;
    var posAttr = particleSystem.geometry.getAttribute('position');
    var sizeAttr = particleSystem.geometry.getAttribute('size');
    var alphaAttr = particleSystem.geometry.getAttribute('alpha');
    var xMax = SCENE_WIDTH / 2 + 2;

    for (var i = 0; i < NUM_PARTICLES; i++) {
      particleLifetimes[i] += dt;

      particlePositions[i * 3]     += particleVelocities[i * 3] * dt;
      particlePositions[i * 3 + 1] += particleVelocities[i * 3 + 1] * dt;
      particlePositions[i * 3 + 2] += particleVelocities[i * 3 + 2] * dt;

      particlePositions[i * 3 + 1] += Math.sin(time * 0.8 + particlePhases[i]) * 0.002;

      var x = particlePositions[i * 3];
      for (var L = 0; L < NUM_LAYERS; L++) {
        var lx = layerMeshes[L].position.x;
        var distToLayer = Math.abs(x - lx);
        if (distToLayer < 0.3) {
          var influence = 1.0 - distToLayer / 0.3;
          particlePositions[i * 3 + 1] += Math.sin(time * 3 + particlePhases[i] + L) * 0.003 * influence;
          sizeAttr.array[i] = 2.0 + influence * 1.5;
          alphaAttr.array[i] = 0.3 + influence * 0.2;
        }
      }

      // Mouse: muted particles repel from cursor
      if (isMouseOver) {
        var dx = particlePositions[i * 3] - mouseWorld.x;
        var dy = particlePositions[i * 3 + 1] - mouseWorld.y;
        var distMouse = Math.sqrt(dx * dx + dy * dy);
        if (distMouse < mouseInfluenceRadius && distMouse > 0.01) {
          var repelForce = (1.0 - distMouse / mouseInfluenceRadius);
          repelForce = repelForce * repelForce * 0.15 * dt;
          particlePositions[i * 3]     += (dx / distMouse) * repelForce;
          particlePositions[i * 3 + 1] += (dy / distMouse) * repelForce;
          alphaAttr.array[i] = Math.max(0.15, alphaAttr.array[i] - repelForce * 2);
        }
      }

      if (particlePositions[i * 3] > xMax) {
        resetParticle(i, false);
      }

      posAttr.array[i * 3]     = particlePositions[i * 3];
      posAttr.array[i * 3 + 1] = particlePositions[i * 3 + 1];
      posAttr.array[i * 3 + 2] = particlePositions[i * 3 + 2];
    }

    posAttr.needsUpdate = true;
    sizeAttr.needsUpdate = true;
    alphaAttr.needsUpdate = true;
  }

  function updateGlowParticles(dt, time) {
    if (!glowParticleSystem) return;
    var posAttr = glowParticleSystem.geometry.getAttribute('position');
    var sizeAttr = glowParticleSystem.geometry.getAttribute('size');
    var alphaAttr = glowParticleSystem.geometry.getAttribute('alpha');
    var xMax = SCENE_WIDTH / 2 + 2;
    var halfW = SCENE_WIDTH / 2;

    for (var i = 0; i < NUM_GLOW; i++) {
      glowLifetimes[i] += dt;

      var x = glowPositions[i * 3];
      var progress = (x + halfW) / SCENE_WIDTH;

      glowPositions[i * 3] += glowVelocities[i * 3] * dt;

      // Decay activation every frame so it doesn't accumulate forever
      glowActivation[i] *= (1.0 - dt * 2.0);

      for (var L = 0; L < NUM_LAYERS; L++) {
        var lx = layerMeshes[L].position.x;
        var distToLayer = Math.abs(x - lx);
        if (distToLayer < 0.25) {
          var activationBoost = (1.0 - distToLayer / 0.25) * dt * 3.0;
          glowActivation[i] = Math.min(1.0, glowActivation[i] + activationBoost);
        }
      }

      // Set size/alpha from activation (computed fresh each frame, no accumulation)
      sizeAttr.array[i] = 3.5 + glowActivation[i] * 8.0;
      alphaAttr.array[i] = 0.6 + glowActivation[i] * 0.4;

      // HORIZONTAL flow: gentle vertical wobble, no diagonal rise
      glowPositions[i * 3 + 1] += Math.sin(time * 1.2 + glowPhases[i]) * 0.002;
      glowPositions[i * 3 + 2] += Math.cos(time * 0.9 + glowPhases[i]) * 0.001;

      // Mouse: glow particles ATTRACT toward cursor
      if (isMouseOver) {
        var dx = mouseWorld.x - glowPositions[i * 3];
        var dy2 = mouseWorld.y - glowPositions[i * 3 + 1];
        var distMouse = Math.sqrt(dx * dx + dy2 * dy2);
        if (distMouse < mouseInfluenceRadius * 1.5 && distMouse > 0.01) {
          var attractForce = (1.0 - distMouse / (mouseInfluenceRadius * 1.5));
          attractForce = attractForce * attractForce;
          var strength = isMouseDown ? 0.4 : 0.12;
          glowPositions[i * 3]     += (dx / distMouse) * attractForce * strength * dt;
          glowPositions[i * 3 + 1] += (dy2 / distMouse) * attractForce * strength * dt;
          sizeAttr.array[i] += attractForce * 4.0;
          alphaAttr.array[i] = Math.min(1.0, alphaAttr.array[i] + attractForce * 0.2);
          if (isMouseDown) {
            glowActivation[i] = Math.min(1.0, glowActivation[i] + attractForce * dt * 2.0);
          }
        }
      }

      // Converge Y/Z toward center after last layer (particles cluster)
      var lastLayerX = layerMeshes[NUM_LAYERS - 1].position.x;
      if (x > lastLayerX) {
        var toFocalY = 0 - glowPositions[i * 3 + 1];
        var toFocalZ = 0 - glowPositions[i * 3 + 2];
        var converge = Math.min(1.0, (x - lastLayerX) / 2.0);
        converge = converge * converge;
        glowPositions[i * 3 + 1] += toFocalY * converge * dt * 2.5;
        glowPositions[i * 3 + 2] += toFocalZ * converge * dt * 2.5;
        // Fade near right edge (absorbed into token)
        var distToEdge = xMax - glowPositions[i * 3];
        if (distToEdge < 0.8) {
          var fade = distToEdge / 0.8;
          sizeAttr.array[i] *= fade;
          alphaAttr.array[i] *= fade;
        }
      }

      var pulse = 0.85 + 0.15 * Math.sin(time * 2.5 + glowPhases[i]);
      alphaAttr.array[i] *= pulse;

      if (glowPositions[i * 3] > xMax) {
        resetGlowParticle(i, false);
      }

      posAttr.array[i * 3]     = glowPositions[i * 3];
      posAttr.array[i * 3 + 1] = glowPositions[i * 3 + 1];
      posAttr.array[i * 3 + 2] = glowPositions[i * 3 + 2];
    }

    posAttr.needsUpdate = true;
    sizeAttr.needsUpdate = true;
    alphaAttr.needsUpdate = true;
  }

  // ---- Layer animation ----
  function updateLayers(time) {
    for (var i = 0; i < NUM_LAYERS; i++) {
      var mesh = layerMeshes[i];
      var edge = layerEdgeMeshes[i];

      var breathe = 1.0 + Math.sin(time * 0.6) * 0.02;

      // Mouse proximity highlight
      var layerHighlight = 0;
      if (isMouseOver) {
        var dxLayer = Math.abs(mouseWorld.x - mesh.position.x);
        if (dxLayer < 2.0) {
          layerHighlight = 1.0 - dxLayer / 2.0;
        }
      }

      var hoverScale = 1.0 + layerHighlight * 0.05;
      mesh.scale.set(hoverScale, breathe * hoverScale, breathe * hoverScale);
      edge.scale.copy(mesh.scale);

      mesh.material.opacity = currentPalette.layerOpacity + layerHighlight * 0.08;

      // HORIZONTAL highlight — no i*0.9 phase offset
      var edgePulse = 0.2 + 0.1 * Math.sin(time * 1.2) + layerHighlight * 0.35;
      edge.material.opacity = edgePulse;
    }
  }

  // ---- Mouse handlers ----
  function onMouseMove(e) {
    var rect = canvas.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    updateMouseWorld();
  }

  function onTouchMove(e) {
    if (!e.touches.length) return;
    var rect = canvas.getBoundingClientRect();
    mouseNDC.x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
    mouseNDC.y = -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
    updateMouseWorld();
  }

  function updateMouseWorld() {
    if (!raycaster || !camera) return;
    var THREE = window.THREE;
    var ndcVec = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
    raycaster.setFromCamera(ndcVec, camera);
    var target = new THREE.Vector3();
    raycaster.ray.intersectPlane(mousePlane, target);
    if (target) {
      mouseWorld.x = target.x;
      mouseWorld.y = target.y;
      mouseWorld.z = target.z;
    }
  }

  // ---- Camera: slow orbit + mouse parallax ----
  var camCurrent = { x: 0, y: 0, z: 20 };
  var CAM_RADIUS = 20;

  function updateCamera(time) {
    var targetX, targetY, targetZ;

    if (isMouseOver) {
      targetX = mouseNDC.x * 1.0;
      targetY = mouseNDC.y * 0.3;
      targetZ = CAM_RADIUS;
    } else {
      // Gentle slow rotation — small angle so layers stay mostly frontal
      var angle = time * 0.08;
      targetX = Math.sin(angle) * 2.5;
      targetY = Math.sin(time * 0.05) * 0.3;
      targetZ = CAM_RADIUS;
    }

    var lerpSpeed = isMouseOver ? 0.05 : 0.02;
    camCurrent.x += (targetX - camCurrent.x) * lerpSpeed;
    camCurrent.y += (targetY - camCurrent.y) * lerpSpeed;
    camCurrent.z += (targetZ - camCurrent.z) * lerpSpeed;

    camera.position.set(camCurrent.x, camCurrent.y, camCurrent.z);
    camera.lookAt(0, 0, 0);
  }

  // ---- Main animation loop ----
  function animate() {
    animFrameId = requestAnimationFrame(animate);
    if (!isInitialized) return;

    var dt = Math.min(clock.getDelta(), 0.05);
    var time = clock.getElapsedTime();

    updateCamera(time);
    updateLayers(time);
    updateParticles(dt, time);
    updateGlowParticles(dt, time);
    updateCircuits(dt, time);
    updateSteerParticles(dt, time);

    renderer.render(scene, camera);
  }

  // ---- Resize handler ----
  function onResize() {
    if (!renderer || !camera || !container) return;
    var w = container.clientWidth;
    var h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }

  // ---- Theme update ----
  function updateTheme() {
    currentPalette = PALETTE[getTheme()];
    if (!renderer) return;

    var THREE = window.THREE;
    var blend = getBlending(THREE);

    renderer.setClearColor(currentPalette.bg, 1);
    scene.fog.color.set(currentPalette.fogColor);
    scene.fog.near = currentPalette.fogNear;
    scene.fog.far = currentPalette.fogFar;

    scene.getObjectByName('ambient').color.set(currentPalette.ambientLight);
    scene.getObjectByName('dirLight').color.set(currentPalette.dirLight);
    scene.getObjectByName('pointLight').color.set(currentPalette.particleGlow);

    for (var i = 0; i < layerMeshes.length; i++) {
      layerMeshes[i].material.color.set(currentPalette.layerColor);
      layerMeshes[i].material.opacity = currentPalette.layerOpacity;
      layerEdgeMeshes[i].material.color.set(currentPalette.layerEdge);
    }

    if (particleSystem) {
      particleSystem.material.uniforms.uColor.value.set(currentPalette.particleMuted);
      particleSystem.material.blending = blend;
      particleSystem.material.needsUpdate = true;
    }
    if (glowParticleSystem) {
      glowParticleSystem.material.uniforms.uColor.value.set(currentPalette.particleActive);
      glowParticleSystem.material.uniforms.uGlowColor.value.set(currentPalette.particleGlow);
      glowParticleSystem.material.blending = blend;
      glowParticleSystem.material.needsUpdate = true;
    }


    if (circuitMesh) {
      circuitMesh.material.blending = blend;
      circuitMesh.material.needsUpdate = true;
    }
    if (steerParticleSystem) {
      steerParticleSystem.material.blending = blend;
      steerParticleSystem.material.needsUpdate = true;
    }
    if (gridLines) {
      gridLines.children.forEach(function(line) {
        line.material.color.set(currentPalette.gridColor);
      });
    }
  }

  // ---- Token generation visualization (single-line stream) ----
  var tokenPool = [];
  var tokenContainer = null;
  var tokenPoolIdx = 0;
  var MAX_TOKENS = 5;

  function buildTokenPool() {
    // Grab article text from the page DOM
    var main = document.querySelector('main');
    if (!main) return;
    var paragraphs = main.querySelectorAll('p, li');
    var texts = [];
    for (var i = 0; i < paragraphs.length; i++) {
      var t = paragraphs[i].textContent.trim();
      if (t.length > 20) texts.push(t);
    }
    // Tokenize into word-level tokens
    for (var j = 0; j < texts.length; j++) {
      var words = texts[j].split(/(\s+)/);
      for (var k = 0; k < words.length; k++) {
        var w = words[k];
        if (w.trim().length > 0) tokenPool.push(w.trim());
      }
    }
    // No shuffle — keep article order
  }

  function startTokenAnimation() {
    tokenContainer = document.getElementById('hero-tokens');
    if (!tokenContainer) return;
    buildTokenPool();
    if (tokenPool.length === 0) return;
    tokenPoolIdx = 0;
    scheduleNextToken();
  }

  function scheduleNextToken() {
    var delay = 200 + Math.random() * 200;
    setTimeout(addNextToken, delay);
  }

  function addNextToken() {
    if (!tokenContainer || tokenPool.length === 0) return;

    // Remove oldest (rightmost)
    while (tokenContainer.children.length >= MAX_TOKENS) {
      var oldest = tokenContainer.children[tokenContainer.children.length - 1];
      oldest.classList.add('out');
      (function(el) {
        setTimeout(function() { if (el.parentNode) el.parentNode.removeChild(el); }, 200);
      })(oldest);
      break;
    }

    var span = document.createElement('span');
    span.className = 'hero-token';
    span.textContent = tokenPool[tokenPoolIdx];
    if (tokenContainer.firstChild) {
      tokenContainer.insertBefore(span, tokenContainer.firstChild);
    } else {
      tokenContainer.appendChild(span);
    }

    tokenPoolIdx = (tokenPoolIdx + 1) % tokenPool.length;
    scheduleNextToken();
  }

  function addSteerToken(color) {
    if (!tokenContainer) return;
    // Remove oldest if at max
    while (tokenContainer.children.length >= MAX_TOKENS) {
      var oldest = tokenContainer.children[tokenContainer.children.length - 1];
      oldest.classList.add('out');
      (function(el) {
        setTimeout(function() { if (el.parentNode) el.parentNode.removeChild(el); }, 200);
      })(oldest);
      break;
    }
    var span = document.createElement('span');
    span.className = 'hero-token';
    var word = tokenPool.length > 0 ? tokenPool[tokenPoolIdx] : 'steer';
    span.textContent = word;
    if (tokenPool.length > 0) tokenPoolIdx = (tokenPoolIdx + 1) % tokenPool.length;
    var cr = Math.round(color.r * 255);
    var cg = Math.round(color.g * 255);
    var cb = Math.round(color.b * 255);
    span.style.color = 'rgba(' + cr + ',' + cg + ',' + cb + ',0.9)';
    span.style.background = 'rgba(' + cr + ',' + cg + ',' + cb + ',0.15)';
    span.style.borderColor = 'rgba(' + cr + ',' + cg + ',' + cb + ',0.2)';
    if (tokenContainer.firstChild) {
      tokenContainer.insertBefore(span, tokenContainer.firstChild);
    } else {
      tokenContainer.appendChild(span);
    }
  }

  // ---- Bootstrap: load Three.js r143 ----
  function bootstrap() {
    if (window.THREE) {
      init();
      return;
    }
    var s = document.getElementById('three-cdn-core');
    if (s) {
      // Script tag exists but THREE not yet loaded — wait for it
      s.addEventListener('load', function() { if (window.THREE) init(); }, { once: true });
      return;
    }
    s = document.createElement('script');
    s.id = 'three-cdn-core';
    s.src = 'https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.min.js';
    s.onload = function() { init(); };
    s.onerror = function() {
      // Hide canvas on error instead of showing blank
      var c = document.getElementById('corrsteer-hero-container');
      if (c) c.style.display = 'none';
    };
    document.head.appendChild(s);
  }

  // Start
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
  } else {
    bootstrap();
  }
})();
</script>
</div></div></figure> <p class="hero-desc" data-astro-cid-bbe6dxrz>Generation-Time LLM Steering via Correlated Sparse Autoencoder Features</p> </div> </section> <header class="meta" aria-label="Article meta information" data-astro-cid-bbe6dxrz> <div class="meta-container" data-astro-cid-bbe6dxrz> <div class="meta-container-cell" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Authors</h3> <ul class="authors" data-astro-cid-bbe6dxrz> <li data-astro-cid-bbe6dxrz> Seonglae Cho<sup data-astro-cid-bbe6dxrz>1, 2</sup><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> Zekun Wu<sup data-astro-cid-bbe6dxrz>1, 2</sup><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> Adriano Koshiyama<sup data-astro-cid-bbe6dxrz>1, 2</sup> </li> </ul> </div> <div class="meta-container-cell meta-container-cell--affiliations" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Affiliations</h3> <ol class="affiliations" data-astro-cid-bbe6dxrz> <li value="1" data-astro-cid-bbe6dxrz> <a href="https://www.holisticai.com" target="_blank" rel="noopener noreferrer" data-astro-cid-bbe6dxrz> Holistic AI </a> </li><li value="2" data-astro-cid-bbe6dxrz> <a href="https://www.ucl.ac.uk" target="_blank" rel="noopener noreferrer" data-astro-cid-bbe6dxrz> University College London </a> </li> </ol> </div>  <div class="meta-container-cell meta-container-cell--published" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Published</h3> <p data-astro-cid-bbe6dxrz>Aug 18, 2025</p> </div> <!-- {doi && (
      <div class="meta-container-cell">
        <h3>DOI</h3>
        <p><a href={`https://doi.org/${doi}`} target="_blank" rel="noopener noreferrer">{doi}</a></p>
      </div>
    )} --> <div class="meta-container-cell meta-container-cell--pdf" data-astro-cid-bbe6dxrz> <div class="pdf-header-wrapper" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>PDF</h3> <span class="pro-badge-wrapper" style="display: none;" data-astro-cid-bbe6dxrz> <span class="pro-badge-prefix" data-astro-cid-bbe6dxrz>- you are</span> <span class="pro-badge" data-astro-cid-bbe6dxrz>PRO</span> </span> <span class="pro-only-label" style="display: none;" data-astro-cid-bbe6dxrz> <span class="pro-only-dash" data-astro-cid-bbe6dxrz>-</span> <span class="pro-only-text" data-astro-cid-bbe6dxrz>pro only</span> <svg class="pro-only-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-bbe6dxrz> <rect x="3" y="11" width="18" height="11" rx="2" ry="2" data-astro-cid-bbe6dxrz></rect> <path d="M7 11V7a5 5 0 0 1 10 0v4" data-astro-cid-bbe6dxrz></path> </svg> </span> </div> <div id="pdf-download-container" data-pdf-pro-only="false" data-astro-cid-bbe6dxrz> <p class="pdf-loading" style="display: none;" data-astro-cid-bbe6dxrz></p> <p class="pdf-pro-only" style="display: block;" data-astro-cid-bbe6dxrz> <a class="button" href="https://arxiv.org/pdf/2508.12535" target="_blank" rel="noopener noreferrer" aria-label="Download PDF from arXiv" data-astro-cid-bbe6dxrz>
Download PDF
</a> </p> <div class="pdf-locked" style="display: none;" data-astro-cid-bbe6dxrz> <a class="button button-locked" href="https://huggingface.co/subscribe/pro" target="_blank" rel="noopener noreferrer" data-astro-cid-bbe6dxrz> <svg class="lock-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" role="img" width="1em" height="1em" viewBox="0 0 12 12" fill="none" data-astro-cid-bbe6dxrz> <path d="M6.48 1.26c0 1.55.67 2.58 1.5 3.24.86.68 1.9 1 2.58 1.07v.86A5.3 5.3 0 0 0 7.99 7.5a3.95 3.95 0 0 0-1.51 3.24h-.96c0-1.55-.67-2.58-1.5-3.24a5.3 5.3 0 0 0-2.58-1.07v-.86A5.3 5.3 0 0 0 4.01 4.5a3.95 3.95 0 0 0 1.51-3.24h.96Z" fill="currentColor" data-astro-cid-bbe6dxrz></path> </svg> <span class="locked-title" data-astro-cid-bbe6dxrz>Subscribe to Pro</span> </a> </div> </div> </div> </div> </header>   <section class="content-grid"> <nav class="table-of-contents" aria-label="Table of Contents" data-auto-collapse="1"> <div class="title">Table of Contents</div> <div id="article-toc-placeholder"></div> </nav> <details class="table-of-contents-mobile"> <summary>Table of Contents</summary> <div id="article-toc-mobile-placeholder"></div> </details> <script>
  // Build TOC from article headings (h2/h3/h4) and render into the sticky aside
  const buildTOC = () => {
    const holder = document.getElementById("article-toc-placeholder");
    const holderMobile = document.getElementById(
      "article-toc-mobile-placeholder",
    );
    // Always rebuild TOC to avoid stale entries
    if (holder) holder.innerHTML = "";
    if (holderMobile) holderMobile.innerHTML = "";
    const articleRoot = document.querySelector("section.content-grid main");
    if (!articleRoot) return;
    const headings = articleRoot.querySelectorAll("h2, h3, h4");
    if (!headings.length) return;

    // Inclure tous les titres H2/H3/H4 sans filtrer "Table of contents"
    const headingsArr = Array.from(headings);
    if (!headingsArr.length) return;

    // Ensure unique ids for headings (deduplicate duplicates)
    const usedIds = new Set();
    const slugify = (s) =>
      String(s || "")
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^a-z0-9_\-]/g, "");
    headingsArr.forEach((h) => {
      let id = (h.id || "").trim();
      if (!id) {
        const base = slugify(h.textContent || "");
        id = base || "section";
      }
      let candidate = id;
      let n = 2;
      while (usedIds.has(candidate)) {
        candidate = `${id}-${n++}`;
      }
      if (h.id !== candidate) h.id = candidate;
      usedIds.add(candidate);
    });

    const nav = document.createElement("nav");
    let ulStack = [document.createElement("ul")];
    nav.appendChild(ulStack[0]);

    const levelOf = (tag) => (tag === "H2" ? 2 : tag === "H3" ? 3 : 4);
    let prev = 2;
    let headingCount = 0;
    headingsArr.forEach((h) => {
      const lvl = levelOf(h.tagName);
      // adjust depth
      while (lvl > prev) {
        const ul = document.createElement("ul");
        ulStack[ulStack.length - 1].lastElementChild?.appendChild(ul);
        ulStack.push(ul);
        prev++;
      }
      while (lvl < prev) {
        ulStack.pop();
        prev--;
      }
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = "#" + h.id;
      a.textContent = h.textContent;
      a.target = "_self";
      li.appendChild(a);
      // Ajouter un index unique à chaque heading pour le tracking
      li.setAttribute("data-heading-idx", String(headingCount));
      headingCount++;
      ulStack[ulStack.length - 1].appendChild(li);
    });

    if (holder) holder.appendChild(nav);
    const navClone = nav.cloneNode(true);
    if (holderMobile) holderMobile.appendChild(navClone);

    // active link on scroll
    const links = [
      ...(holder ? holder.querySelectorAll("a") : []),
      ...(holderMobile ? holderMobile.querySelectorAll("a") : []),
    ];
    // Read breakpoint from CSS var and set autoCollapse only on desktop (disabled on mobile)
    const getCollapsePx = () => {
      const root = document.documentElement;
      const raw = getComputedStyle(root)
        .getPropertyValue("--bp-content-collapse")
        .trim();
      return raw || "1100px";
    };
    const mq = window.matchMedia(`(max-width: ${getCollapsePx()})`);
    const attrEnabled =
      document
        .querySelector(".table-of-contents")
        ?.getAttribute("data-auto-collapse") === "1";
    let autoCollapse = attrEnabled && !mq.matches;

    // Inject styles for collapsible & animation (tous les niveaux)
    const ensureStyles = () => {
      if (document.getElementById("toc-collapse-style")) return;
      const style = document.createElement("style");
      style.id = "toc-collapse-style";
      style.textContent = `
        .table-of-contents nav.table-of-contents-collapsible li > ul,
        details.table-of-contents-mobile nav.table-of-contents-collapsible li > ul { overflow: hidden; transition: height 200ms ease; }
        .table-of-contents nav.table-of-contents-collapsible li.collapsed > ul,
        details.table-of-contents-mobile nav.table-of-contents-collapsible li.collapsed > ul { display: block; }
      `;
      document.head.appendChild(style);
    };
    ensureStyles();

    const getAllItemsWithChildren = () => {
      const sideNav = holder ? holder.querySelector("nav") : null;
      const mobileNav = holderMobile ? holderMobile.querySelector("nav") : null;
      const q = (navEl) =>
        navEl
          ? Array.from(navEl.querySelectorAll("li[data-heading-idx]")).filter(
              (li) => li.querySelector(":scope > ul"),
            )
          : [];
      return {
        sideNav,
        mobileNav,
        sideItems: q(sideNav),
        mobileItems: q(mobileNav),
      };
    };

    const setNavCollapsible = () => {
      const sideNav = holder ? holder.querySelector("nav") : null;
      const mobileNav = holderMobile ? holderMobile.querySelector("nav") : null;
      if (sideNav) sideNav.classList.add("table-of-contents-collapsible");
      if (mobileNav) mobileNav.classList.add("table-of-contents-collapsible");
    };

    const measure = (el) => {
      if (!el) return 0;
      // Temporarily set height to auto to measure scrollHeight reliably
      const prev = el.style.height;
      el.style.height = "auto";

      // Force un reflow pour que le navigateur calcule les wraps de texte
      void el.offsetHeight;

      // Maintenant scrollHeight inclut la vraie hauteur avec tous les line wraps
      const h = el.scrollHeight;
      el.style.height = prev || "";
      return h;
    };

    // Tracker les animations en cours pour pouvoir les annuler
    const activeAnimations = new Map();

    const cancelAnimation = (el) => {
      if (!el) return;
      const animData = activeAnimations.get(el);
      if (animData) {
        // Nettoyer le listener de l'animation précédente
        el.removeEventListener("transitionend", animData.onEnd);
        activeAnimations.delete(el);
      }
    };

    const animateTo = (el, target) => {
      if (!el) return;

      // Annuler toute animation en cours sur cet élément
      cancelAnimation(el);

      // Obtenir la hauteur ACTUELLE (même si une animation est en cours)
      const current = parseFloat(getComputedStyle(el).height) || 0;

      // Si on est déjà proche de la cible, pas besoin d'animer
      if (Math.abs(current - target) < 1) {
        el.style.height = target ? "auto" : "0px";
        return;
      }

      // Démarrer depuis la hauteur actuelle
      el.style.height = current + "px";
      // Force reflow
      void el.offsetHeight;

      // Aller vers la cible
      el.style.height = target + "px";

      // Créer le listener de fin
      const onEnd = (e) => {
        if (e.propertyName !== "height") return;
        el.removeEventListener("transitionend", onEnd);
        activeAnimations.delete(el);
        if (target > 0) el.style.height = "auto";
      };

      // Sauvegarder le listener pour pouvoir l'annuler plus tard
      activeAnimations.set(el, { onEnd });
      el.addEventListener("transitionend", onEnd);
    };

    let prevActiveIdx = -1;
    let prevActiveElements = new Set();
    let prevActiveHeadingId = null;

    const setCollapsedState = (activeIdx) => {
      if (!autoCollapse) return;
      if (activeIdx == null || activeIdx < 0) activeIdx = 0;
      const { sideItems, mobileItems } = getAllItemsWithChildren();

      // Trouver l'élément <li> correspondant au heading actif et tous ses ancêtres
      const getActiveAndAncestors = (items, targetIdx) => {
        const toExpand = new Set();

        // Trouver le <li> qui correspond au targetIdx
        const findActiveLi = (li) => {
          const idx = Number(li.getAttribute("data-heading-idx") || "-1");
          if (idx === targetIdx) {
            return li;
          }

          const childUl = li.querySelector(":scope > ul");
          if (!childUl) return null;

          const childLis = childUl.querySelectorAll(
            ":scope > li[data-heading-idx]",
          );
          for (const child of childLis) {
            const found = findActiveLi(child);
            if (found) return found;
          }
          return null;
        };

        let activeLi = null;
        for (const li of items) {
          activeLi = findActiveLi(li);
          if (activeLi) break;
        }

        if (!activeLi) return toExpand;

        // Collecter l'élément actif lui-même
        const activeIdx = Number(
          activeLi.getAttribute("data-heading-idx") || "-1",
        );
        toExpand.add(activeIdx);

        // Remonter et collecter TOUS les ancêtres, sans condition
        // La structure de la TOC détermine automatiquement qui doit être ouvert
        let current = activeLi;
        while (current) {
          const parent = current.parentElement?.closest("li[data-heading-idx]");
          if (parent) {
            const parentIdx = Number(
              parent.getAttribute("data-heading-idx") || "-1",
            );
            toExpand.add(parentIdx);
            current = parent;
          } else {
            break;
          }
        }

        return toExpand;
      };

      const update = (items) => {
        const newActiveAncestors = getActiveAndAncestors(items, activeIdx);

        // Étape 0 : Annuler TOUTES les animations en cours avant de commencer
        // Cela évite les conflits si l'utilisateur scroll rapidement
        items.forEach((li) => {
          const sub = li.querySelector(":scope > ul");
          if (sub) cancelAnimation(sub);
        });

        // Étape 1 : Identifier TOUS les éléments qui vont changer d'état
        const allChanges = [];
        items.forEach((li) => {
          const sub = li.querySelector(":scope > ul");
          if (!sub) return;

          const idx = Number(li.getAttribute("data-heading-idx") || "-1");

          // Un élément doit être expanded SI il contient (directement ou indirectement) le heading actif
          // Donc soit il est dans newActiveAncestors, soit un de ses descendants l'est
          let shouldBeExpanded = false;

          // Vérifier si cet élément ou un de ses descendants est dans le chemin actif
          const allDescendants = li.querySelectorAll("li[data-heading-idx]");
          const allRelatedIndices = [
            idx,
            ...Array.from(allDescendants).map((d) =>
              Number(d.getAttribute("data-heading-idx") || "-1"),
            ),
          ];

          // Si au moins un de ces indices est dans newActiveAncestors, garder ouvert
          shouldBeExpanded = allRelatedIndices.some((i) =>
            newActiveAncestors.has(i),
          );

          const isCurrentlyCollapsed = li.classList.contains("collapsed");

          const isChanging =
            (shouldBeExpanded && isCurrentlyCollapsed) ||
            (!shouldBeExpanded && !isCurrentlyCollapsed);

          if (isChanging) {
            allChanges.push({ li, sub, shouldBeExpanded, idx });
          }
        });

        // Étape 2 : Parmi tous les changements, trouver ceux qui sont des "top-level"
        // (= n'ont PAS d'ancêtre qui change aussi)
        const topLevelChanges = [];
        const descendantChanges = [];

        allChanges.forEach((change) => {
          let hasAncestorChanging = false;

          // Remonter l'arbre pour voir si un ancêtre change aussi
          let currentLi = change.li;
          while (currentLi) {
            const parentLi = currentLi.parentElement?.closest(
              "li[data-heading-idx]",
            );
            if (!parentLi) break;

            const parentIdx = Number(
              parentLi.getAttribute("data-heading-idx") || "-1",
            );

            // Vérifier si ce parent est dans la liste des changements
            const parentIsChanging = allChanges.some(
              (c) => c.idx === parentIdx,
            );
            if (parentIsChanging) {
              hasAncestorChanging = true;
              break;
            }

            currentLi = parentLi;
          }

          if (hasAncestorChanging) {
            descendantChanges.push(change);
          } else {
            topLevelChanges.push(change);
          }
        });

        // Étape 3 : Appliquer TOUS les descendants instantanément (sans animation)
        // Ceci doit être fait AVANT toute animation pour que les hauteurs soient correctes
        if (descendantChanges.length > 0) {
          descendantChanges.forEach(({ li, sub, shouldBeExpanded }) => {
            const oldTransition = sub.style.transition;
            sub.style.transition = "none";

            if (shouldBeExpanded) {
              li.classList.remove("collapsed");
              sub.style.height = "auto";
            } else {
              li.classList.add("collapsed");
              sub.style.height = "0px";
            }

            // Forcer un reflow immédiat pour cet élément
            void sub.offsetHeight;
            sub.style.transition = oldTransition || "";
          });

          // Forcer un reflow global pour que TOUS les changements soient appliqués
          void document.body.offsetHeight;

          // IMPORTANT : Attendre un frame pour que le navigateur ait fini tous les calculs
          // avant de mesurer les hauteurs des parents
        }

        // Étape 4 : Animer SEULEMENT les top-level avec requestAnimationFrame
        // Les descendants sont déjà dans leur état final, donc la hauteur du parent sera correcte
        if (topLevelChanges.length > 0) {
          // Double requestAnimationFrame pour être sûr que le DOM est stabilisé
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              topLevelChanges.forEach(({ li, sub, shouldBeExpanded }) => {
                if (shouldBeExpanded) {
                  li.classList.remove("collapsed");

                  // CRITIQUE : Avant de mesurer, mettre ABSOLUMENT TOUS les sous-éléments
                  // dans leur état final (expanded OU collapsed) de manière synchrone
                  const allInnerItems = sub.querySelectorAll(
                    "li[data-heading-idx]",
                  );

                  // D'abord, désactiver toutes les transitions
                  allInnerItems.forEach((innerLi) => {
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      innerSub.style.transition = "none";
                    }
                  });

                  // Ensuite, mettre chaque élément dans son état final
                  allInnerItems.forEach((innerLi) => {
                    const innerIdx = Number(
                      innerLi.getAttribute("data-heading-idx") || "-1",
                    );
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      if (newActiveAncestors.has(innerIdx)) {
                        // Cet élément devrait être expanded
                        innerLi.classList.remove("collapsed");
                        innerSub.style.height = "auto";
                      } else {
                        // Cet élément devrait être collapsed
                        innerLi.classList.add("collapsed");
                        innerSub.style.height = "0px";
                      }
                    }
                  });

                  // Forcer un reflow global pour que TOUT soit calculé
                  void sub.offsetHeight;

                  // Réactiver les transitions
                  allInnerItems.forEach((innerLi) => {
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      innerSub.style.transition = "";
                    }
                  });

                  // Maintenant on peut mesurer avec confiance : tous les éléments
                  // sont dans leur état final définitif
                  const target = measure(sub);
                  animateTo(sub, target);
                } else {
                  li.classList.add("collapsed");
                  animateTo(sub, 0);
                }
              });
            });
          });
        }

        prevActiveElements = newActiveAncestors;
      };

      update(sideItems);
      update(mobileItems);
      setNavCollapsible();
      prevActiveIdx = activeIdx;
    };

    // When switching between desktop/mobile, refresh autoCollapse and expand all on mobile
    const expandAll = () => {
      const { sideItems, mobileItems } = getAllItemsWithChildren();
      const expand = (items) =>
        items.forEach((li) => {
          li.classList.remove("collapsed");
          const sub = li.querySelector(":scope > ul");
          if (sub) sub.style.height = "auto";
        });
      expand(sideItems);
      expand(mobileItems);
    };

    const onMqChange = () => {
      autoCollapse = attrEnabled && !mq.matches;
      if (!autoCollapse) {
        expandAll();
      } else {
        setCollapsedState(prevActiveIdx);
      }
    };
    if (mq.addEventListener) mq.addEventListener("change", onMqChange);
    else if (mq.addListener) mq.addListener(onMqChange);

    // Debounce pour traiter la dernière mise à jour après que le scroll se stabilise
    let scrollDebounceTimer = null;
    let lastRequestedIdx = -1;
    let isProcessing = false;

    // Block URL updates until user has scrolled at least once
    let userHasScrolled = false;
    window.addEventListener('scroll', () => { userHasScrolled = true; }, { once: true });

    // Fonction pour mettre à jour l'URL avec l'ancre actuelle
    const updateURL = (headingId) => {
      // Disabled: auto hash URL updates cause unwanted navigation
      return;

      // Mettre à jour l'URL sans recharger la page
      if (window.location.href !== newUrl) {
        history.pushState(null, null, newUrl);

        // Essayer différentes méthodes pour communiquer avec la fenêtre parente
        if (window.parent !== window) {
          try {
            // Méthode 1: Essayer de modifier directement l'URL du parent (si autorisé)
            try {
              window.parent.location.hash = headingId;
              console.debug("Successfully updated parent URL directly");
              return;
            } catch (e) {
              console.debug("Direct parent URL update blocked:", e.message);
            }

            // Méthode 2: Essayer avec window.top (fenêtre racine)
            try {
              if (window.top !== window && window.top !== window.parent) {
                window.top.location.hash = headingId;
                console.debug("Successfully updated top window URL directly");
                return;
              }
            } catch (e) {
              console.debug("Direct top window URL update blocked:", e.message);
            }

            // Méthode 3: Utiliser postMessage avec différents formats vers parent
            const messages = [
              {
                type: "urlChange",
                url: newUrl,
                hash: headingId,
              },
              {
                type: "anchorChange",
                anchorId: headingId,
                url: newUrl,
              },
              {
                type: "HF_SPACE_URL_UPDATE",
                hash: headingId,
                url: newUrl,
              },
              // Format officiel Hugging Face
              {
                queryString: "",
                hash: headingId,
              },
            ];

            messages.forEach((msg) => {
              try {
                window.parent.postMessage(msg, "*");
              } catch (e) {
                console.debug("PostMessage to parent failed:", e.message);
              }
            });

            // Méthode 4: Essayer avec window.top
            try {
              if (window.top !== window) {
                messages.forEach((msg) => {
                  try {
                    window.top.postMessage(msg, "*");
                  } catch (e) {
                    console.debug("PostMessage to top failed:", e.message);
                  }
                });
              }
            } catch (e) {
              console.debug("PostMessage to top window failed:", e.message);
            }

            // Méthode 5: Essayer avec l'origine spécifique Hugging Face
            try {
              window.parent.postMessage(
                {
                  queryString: "",
                  hash: headingId,
                },
                "https://huggingface.co",
              );
              console.debug("Sent HF official format message");
            } catch (e) {
              console.debug("HF official format failed:", e.message);
            }
          } catch (e) {
            console.debug(
              "All parent communication methods failed:",
              e.message,
            );
          }
        }
      }
    };

    const onScroll = () => {
      // active link highlight
      let activeIdx = -1;
      let activeHeadingId = null;

      for (let i = headingsArr.length - 1; i >= 0; i--) {
        const top = headingsArr[i].getBoundingClientRect().top;
        if (top - 60 <= 0) {
          links.forEach((l) => l.classList.remove("active"));
          const id = "#" + headingsArr[i].id;
          const actives = Array.from(links).filter(
            (l) => l.getAttribute("href") === id,
          );
          actives.forEach((a) => a.classList.add("active"));
          // Utiliser l'index du heading actif (n'importe quel niveau)
          activeIdx = i;
          activeHeadingId = headingsArr[i].id;
          break;
        }
      }

      // Mettre à jour l'URL si la section active a changé
      if (activeHeadingId && activeHeadingId !== prevActiveHeadingId) {
        updateURL(activeHeadingId);
        prevActiveHeadingId = activeHeadingId;
      }

      if (activeIdx === prevActiveIdx) return;

      // Sauvegarder la dernière demande
      lastRequestedIdx = activeIdx;

      // Si on est en train de traiter, ne rien faire (on traitera la dernière demande après)
      if (isProcessing) return;

      // Debounce : attendre un peu que le scroll se stabilise
      clearTimeout(scrollDebounceTimer);
      scrollDebounceTimer = setTimeout(() => {
        // Traiter la dernière demande
        if (lastRequestedIdx !== prevActiveIdx) {
          isProcessing = true;
          setCollapsedState(lastRequestedIdx);
          // Le processing flag sera réinitialisé après les animations
          setTimeout(() => {
            isProcessing = false;
            // Si une nouvelle demande est arrivée pendant qu'on traitait, la traiter maintenant
            if (lastRequestedIdx !== prevActiveIdx) {
              onScroll();
            }
          }, 250); // Attendre que les animations soient lancées
        }
      }, 100); // Debounce de 100ms
    };

    // If auto-collapse, collapse immediately (expand first section) before any scroll
    if (autoCollapse) setCollapsedState(0);

    window.addEventListener("scroll", onScroll);

    // Gérer la navigation par ancres au chargement de la page
    const handleInitialNavigation = () => {
      const hash = window.location.hash;
      if (hash) {
        const targetElement = document.querySelector(hash);
        if (targetElement) {
          // Attendre que le DOM soit prêt puis faire défiler vers l'élément
          setTimeout(() => {
            targetElement.scrollIntoView({ block: "start" });
            // Mettre à jour l'URL après le scroll
            setTimeout(() => {
              updateURL(hash.substring(1)); // Enlever le # du hash
            }, 100);
          }, 100);
        }
      } else {
        // No hash: stay at current scroll position, don't jump to first heading
      }
    };

    // Initialize state
    onScroll();

    // Gérer la navigation initiale
    handleInitialNavigation();

    // Gérer les événements de navigation du navigateur (boutons précédent/suivant)
    window.addEventListener("popstate", (event) => {
      const hash = window.location.hash;
      if (hash) {
        const targetElement = document.querySelector(hash);
        if (targetElement) {
          targetElement.scrollIntoView({ block: "start" });
        }
      } else {
        // Si pas d'ancre, aller au début de la page
        window.scrollTo({ top: 0 });
      }
    });

    // Close mobile accordion when a link inside it is clicked
    if (holderMobile) {
      const details = holderMobile.closest("details");
      holderMobile.addEventListener("click", (ev) => {
        const target = ev.target;
        const anchor =
          target && "closest" in target ? target.closest("a") : null;
        if (anchor instanceof HTMLAnchorElement && details && details.open) {
          details.open = false;
        }
      });
    }
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", buildTOC, { once: true });
  } else {
    buildTOC();
  }
</script>  <main> <h2 id="tldr"><a href="#tldr">TL;DR</a></h2>
<p><strong>CorrSteer</strong> is a fully automated method for steering LLMs using Sparse Autoencoder features. It selects features by correlating task outcomes with SAE activations during generation, then validates through intervention. No contrastive datasets, no backward passes, no activation storage needed.</p>
<p><strong>Key results:</strong> +3.3% MMLU, +27.2% HarmBench, with half the side effects of fine-tuning.</p>
<h2 id="why-steering-matters"><a href="#why-steering-matters">Why Steering Matters</a></h2>
<p>Large language models have behaviors we want to control: reduce bias, improve factual accuracy, prevent harmful outputs. The standard approach is <strong>fine-tuning</strong>, but it is a blunt instrument. It changes thousands of parameters simultaneously, often introducing unintended side effects that are difficult to diagnose or reverse.</p>
<p><strong>Sparse Autoencoders</strong> (SAEs) offer an alternative. They decompose neural activations into interpretable features: individual directions in activation space that correspond to human-understandable concepts like “refusal to harmful requests” or “mathematical reasoning.”</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The Linear Representation Hypothesis states that neural networks encode concepts as directions in activation space. SAEs exploit this by finding a sparse basis where each direction corresponds to an interpretable concept.</p> </aside> </div>  
<p>But existing SAE steering methods have limitations: they require contrastive datasets, large activation stores, or backward passes. And critically, they select features from <strong>context tokens</strong> rather than <strong>generation tokens</strong>, missing the features that actually drive output behavior.</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Steering in Action</figcaption><div class="html-embed__card"><div id="frag-ktizrron82" data-datafiles="response_examples.json"><div class="response-demo"></div>
<style>
  .html-embed__card:has(.response-demo) {
    background-color: var(--page-bg, #fff) !important;
  }
  .response-demo {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --rd-primary: #6B5CE7;
    --rd-muted: #8b8fa3;
    --rd-baseline-accent: #7a7e8f;
    --rd-steered-accent: #6B5CE7;
    --rd-card-bg: var(--surface-bg, #fff);
    --rd-card-border: var(--border-color, #e2e4ea);
    --rd-text: var(--text-color, #1a1a2e);
    --rd-text-secondary: var(--muted-color, #6b6f80);
    --rd-prompt-bg: var(--code-bg, #f5f6f8);
    --rd-badge-bg: var(--surface-bg, #f0f1f5);
    --rd-amplify: #e04f4f;
    --rd-mitigate: #4E8FB7;
  }

  /* Tabs */
  .response-demo .tabs {
    display: flex;
    gap: 0;
    margin-bottom: 16px;
    border-bottom: 2px solid var(--rd-card-border);
  }

  .response-demo .tab-btn {
    padding: 8px 20px;
    border: none;
    background: none;
    font-size: 13px;
    font-weight: 600;
    color: var(--rd-text-secondary);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    transition: all 0.2s ease;
  }

  .response-demo .tab-btn:hover {
    color: var(--rd-text);
  }

  .response-demo .tab-btn.active {
    color: var(--rd-primary);
    border-bottom-color: var(--rd-primary);
  }

  .response-demo .tab-panel {
    display: none;
  }

  .response-demo .tab-panel.active {
    display: block;
  }

  /* Shared controls */
  .response-demo .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }

  .response-demo .control-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .response-demo .control-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--rd-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .response-demo select {
    min-width: 160px;
    padding: 6px 28px 6px 10px;
    border: 1px solid var(--rd-card-border);
    border-radius: 8px;
    background: transparent;
    color: var(--rd-text);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3' fill='none' stroke='%236b6f80' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    transition: border-color 0.2s ease;
  }

  .response-demo select:hover {
    border-color: var(--rd-primary);
  }

  .response-demo select:focus {
    outline: none;
    border-color: var(--rd-primary);
    box-shadow: 0 0 0 2px rgba(78, 165, 183, 0.15);
  }

  .response-demo .btn-next {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    border: 1px solid var(--rd-card-border);
    border-radius: 8px;
    background: transparent;
    color: var(--rd-text);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .response-demo .btn-next:hover {
    border-color: var(--rd-primary);
    color: var(--rd-primary);
    background: rgba(107, 92, 231, 0.06);
  }

  .response-demo .btn-next svg {
    width: 14px;
    height: 14px;
    transition: transform 0.2s ease;
  }

  .response-demo .btn-next:hover svg {
    transform: translateX(2px);
  }

  .response-demo .prompt-card {
    background: transparent;
    border: 1px solid var(--rd-card-border);
    border-radius: 10px;
    padding: 14px 16px;
    margin-bottom: 12px;
    transition: opacity 0.3s ease;
  }

  .response-demo .prompt-label {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: var(--rd-text-secondary);
    margin-bottom: 8px;
  }

  .response-demo .prompt-text {
    font-size: 13px;
    line-height: 1.55;
    color: var(--rd-text);
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 160px;
    overflow-y: auto;
  }

  .response-demo .split-panels {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 12px;
    transition: opacity 0.3s ease;
  }

  @media (max-width: 640px) {
    .response-demo .split-panels {
      grid-template-columns: 1fr;
    }
  }

  .response-demo .panel {
    background: transparent;
    border: 1px solid var(--rd-card-border);
    border-radius: 10px;
    overflow: hidden;
    transition: border-color 0.2s ease;
  }

  .response-demo .panel-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    border-bottom: 1px solid var(--rd-card-border);
  }

  .response-demo .panel-header .accent-bar {
    width: 3px;
    height: 16px;
    border-radius: 2px;
  }

  .response-demo .panel--baseline .accent-bar {
    background: var(--rd-baseline-accent);
  }

  .response-demo .panel--steered .accent-bar {
    background: var(--rd-steered-accent);
  }

  .response-demo .panel-header .panel-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--rd-text);
    letter-spacing: 0.02em;
  }

  .response-demo .panel--baseline .panel-title {
    color: var(--rd-baseline-accent);
  }

  .response-demo .panel--steered .panel-title {
    color: var(--rd-steered-accent);
  }

  .response-demo .panel-body {
    padding: 14px 16px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--rd-text);
    white-space: pre-wrap;
    word-break: break-word;
    min-height: 80px;
    max-height: 220px;
    overflow-y: auto;
  }

  .response-demo .feature-badge {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 14px;
    background: transparent;
    border: 1px solid var(--rd-card-border);
    border-radius: 8px;
    font-size: 12px;
    color: var(--rd-text-secondary);
    flex-wrap: wrap;
    transition: opacity 0.3s ease;
  }

  .response-demo .feature-badge .badge-label {
    font-weight: 600;
    color: var(--rd-text);
  }

  .response-demo .feature-badge .badge-corr {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 4px;
    font-weight: 600;
    color: var(--rd-primary);
  }

  .response-demo .feature-badge .corr-bar {
    width: 40px;
    height: 5px;
    background: var(--rd-card-border);
    border-radius: 3px;
    overflow: hidden;
  }

  .response-demo .feature-badge .corr-fill {
    height: 100%;
    background: var(--rd-primary);
    border-radius: 3px;
    transition: width 0.4s ease;
  }

  .response-demo .counter-text {
    font-size: 11px;
    color: var(--rd-text-secondary);
    margin-left: 8px;
  }

  .response-demo .loading-msg {
    text-align: center;
    padding: 40px 20px;
    font-size: 13px;
    color: var(--rd-text-secondary);
  }

  /* Live Demo styles */
  .response-demo .live-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 12px;
  }

  @media (max-width: 640px) {
    .response-demo .live-grid {
      grid-template-columns: 1fr;
    }
  }

  .response-demo .live-panel {
    background: transparent;
    border: 1px solid var(--rd-card-border);
    border-radius: 10px;
    overflow: hidden;
    transition: border-color 0.2s;
  }

  .response-demo .live-panel.generating {
    border-color: var(--rd-primary);
  }

  .response-demo .live-panel-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    border-bottom: 1px solid var(--rd-card-border);
  }

  .response-demo .live-panel-header .panel-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }

  .response-demo .live-panel-header .panel-title {
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.3px;
  }

  .response-demo .live-panel-body {
    padding: 12px 14px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--rd-text);
    min-height: 80px;
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .response-demo .live-panel-body .cursor {
    display: inline-block;
    width: 2px;
    height: 1em;
    background: var(--rd-primary);
    animation: blink 0.8s step-end infinite;
    vertical-align: text-bottom;
    margin-left: 1px;
  }

  @keyframes blink {
    50% { opacity: 0; }
  }

  .response-demo .btn-generate {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 7px 18px;
    border: none;
    border-radius: 8px;
    background: var(--rd-primary);
    color: #fff;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .response-demo .btn-generate:hover:not(:disabled) {
    filter: brightness(1.1);
  }

  .response-demo .btn-generate:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .response-demo .btn-generate svg {
    width: 16px;
    height: 16px;
  }

  .response-demo .api-unavailable {
    text-align: center;
    padding: 32px 20px;
    color: var(--rd-text-secondary);
    font-size: 13px;
    line-height: 1.6;
    background: transparent;
    border: 1px dashed var(--rd-card-border);
    border-radius: 10px;
  }

  .response-demo .api-unavailable .icon {
    font-size: 24px;
    margin-bottom: 8px;
  }

  .response-demo .spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>
<script>
  (() => {
    const DATA_PATHS = [
      '/data/response_examples.json',
      './assets/data/response_examples.json',
      '../assets/data/response_examples.json',
      '../../assets/data/response_examples.json',
      '../../../assets/data/response_examples.json'
    ];

    const TASK_LABELS = {
      harmbench: 'HarmBench',
      mmlu: 'MMLU',
      bbq_ambig: 'BBQ-Ambig',
      bbq_disambig: 'BBQ-Disambig'
    };

    const LIVE_CATEGORIES = {
      'lgbtq+': { label: 'LGBT+', prompt: 'The gay people are' },
      'nationality': { label: 'Nationality', prompt: 'The French people are' },
      'race': { label: 'Race', prompt: 'The Black people are' }
    };

    const LIVE_TYPES = [
      { key: 'original', label: 'Original Model', icon: '<svg viewBox="0 0 16 16" fill="none" width="14" height="14"><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/><circle cx="8" cy="8" r="2" fill="currentColor"/></svg>', color: '#7a7e8f', desc: 'GPT-2 without steering' },
      { key: 'origin+steer', label: 'Bias Amplified', icon: '<svg viewBox="0 0 16 16" fill="none" width="14" height="14"><path d="M8 2l6 12H2z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/><line x1="8" y1="6" x2="8" y2="10" stroke="currentColor" stroke-width="1.5"/><circle cx="8" cy="12" r="0.8" fill="currentColor"/></svg>', color: '#e04f4f', desc: 'GPT-2 + CorrSteer amplify' },
      { key: 'trained', label: 'Fine-tuned Model', icon: '<svg viewBox="0 0 16 16" fill="none" width="14" height="14"><rect x="2" y="2" width="12" height="12" rx="2" stroke="currentColor" stroke-width="1.5"/><path d="M5 8h6M8 5v6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>', color: '#9b7ed8', desc: 'GPT-2 EMGSD fine-tuned' },
      { key: 'trained-steer', label: 'Bias Mitigated', icon: '<svg viewBox="0 0 16 16" fill="none" width="14" height="14"><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/><path d="M5 8l2 2 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>', color: '#4E8FB7', desc: 'GPT-2 + CorrSteer mitigate' }
    ];

    var fetchFirstAvailable = function(paths) {
      var idx = 0;
      return new Promise(function(resolve, reject) {
        function tryNext() {
          if (idx >= paths.length) { reject(new Error('Data not found')); return; }
          fetch(paths[idx], { cache: 'no-cache' }).then(function(r) {
            if (r.ok) return r.json();
            throw new Error('not ok');
          }).then(resolve).catch(function() { idx++; tryNext(); });
        }
        tryNext();
      });
    };

    var shuffleArray = function(arr) {
      var a = arr.slice();
      for (var i = a.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
      }
      return a;
    };

    var truncatePrompt = function(text, maxLen) {
      maxLen = maxLen || 400;
      if (text.length <= maxLen) return text;
      return text.slice(0, maxLen) + '...';
    };

    function bootstrap() {
      var scriptEl = document.currentScript;
      var container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('response-demo'))) {
        var candidates = Array.from(document.querySelectorAll('.response-demo'))
          .filter(function(el) { return !(el.dataset && el.dataset.mounted === 'true'); });
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      container.innerHTML = '<div class="loading-msg">Loading examples...</div>';

      var allData = [];
      var taskMap = {};
      var currentTask = 'harmbench';
      var currentIdx = 0;
      var apiAvailable = null;
      var apiBase = '';

      // Check API availability (try relative first, then localhost:5001 for dev)
      function checkApi() {
        return fetch('/api/health', { method: 'GET' }).then(function(r) {
          if (r.ok) { apiAvailable = true; apiBase = ''; }
          else throw new Error('not ok');
        }).catch(function() {
          return fetch('http://localhost:5001/api/health', { method: 'GET' }).then(function(r) {
            if (r.ok) { apiAvailable = true; apiBase = 'http://localhost:5001'; }
            else { apiAvailable = false; }
          }).catch(function() {
            apiAvailable = false;
          });
        });
      }

      // ========================
      // Examples tab (existing)
      // ========================
      function buildExamplesTab(panel) {
        var controls = document.createElement('div');
        controls.className = 'controls';

        var controlGroup = document.createElement('div');
        controlGroup.className = 'control-group';

        var label = document.createElement('span');
        label.className = 'control-label';
        label.textContent = 'Task';

        var select = document.createElement('select');
        select.id = 'rd-task-select';
        var orderedTasks = Object.keys(TASK_LABELS).filter(function(t) { return taskMap[t] && taskMap[t].length > 0; });
        Object.keys(taskMap).forEach(function(t) {
          if (orderedTasks.indexOf(t) === -1) orderedTasks.push(t);
        });
        orderedTasks.forEach(function(t) {
          var opt = document.createElement('option');
          opt.value = t;
          opt.textContent = TASK_LABELS[t] || t;
          if (t === currentTask) opt.selected = true;
          select.appendChild(opt);
        });

        controlGroup.appendChild(label);
        controlGroup.appendChild(select);
        controls.appendChild(controlGroup);

        var counterSpan = document.createElement('span');
        counterSpan.className = 'counter-text';
        counterSpan.id = 'rd-counter';
        controls.appendChild(counterSpan);

        var nextBtn = document.createElement('button');
        nextBtn.className = 'btn-next';
        nextBtn.innerHTML = 'Next Example <svg viewBox="0 0 16 16" fill="none"><path d="M6 3l5 5-5 5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        controls.appendChild(nextBtn);

        panel.appendChild(controls);

        var promptCard = document.createElement('div');
        promptCard.className = 'prompt-card';
        promptCard.id = 'rd-prompt';
        promptCard.innerHTML = '<div class="prompt-label">Prompt</div><div class="prompt-text" id="rd-prompt-text"></div>';
        panel.appendChild(promptCard);

        var splitPanels = document.createElement('div');
        splitPanels.className = 'split-panels';
        splitPanels.id = 'rd-panels';
        splitPanels.innerHTML = '<div class="panel panel--baseline"><div class="panel-header"><div class="accent-bar"></div><div class="panel-title">Baseline</div></div><div class="panel-body" id="rd-baseline-text"></div></div><div class="panel panel--steered"><div class="panel-header"><div class="accent-bar"></div><div class="panel-title">CorrSteer</div></div><div class="panel-body" id="rd-steered-text"></div></div>';
        panel.appendChild(splitPanels);

        var badge = document.createElement('div');
        badge.className = 'feature-badge';
        badge.id = 'rd-badge';
        badge.innerHTML = '<span class="badge-label" id="rd-badge-label"></span><span class="badge-corr" id="rd-badge-corr"><span id="rd-corr-val"></span><span class="corr-bar"><span class="corr-fill" id="rd-corr-fill"></span></span></span>';
        panel.appendChild(badge);

        select.addEventListener('change', function(e) {
          currentTask = e.target.value;
          currentIdx = 0;
          showExample(true);
        });

        nextBtn.addEventListener('click', function() {
          var examples = taskMap[currentTask] || [];
          if (examples.length === 0) return;
          currentIdx = (currentIdx + 1) % examples.length;
          showExample(true);
        });

        showExample(false);
      }

      function showExample(animate) {
        var examples = taskMap[currentTask] || [];
        if (examples.length === 0) return;
        var ex = examples[currentIdx];

        var promptText = document.getElementById('rd-prompt-text');
        var baselineText = document.getElementById('rd-baseline-text');
        var steeredText = document.getElementById('rd-steered-text');
        var badgeLabel = document.getElementById('rd-badge-label');
        var corrVal = document.getElementById('rd-corr-val');
        var corrFill = document.getElementById('rd-corr-fill');
        var counter = document.getElementById('rd-counter');
        if (!promptText) return;

        var targets = [
          document.getElementById('rd-prompt'),
          document.getElementById('rd-panels'),
          document.getElementById('rd-badge')
        ];

        function apply() {
          promptText.textContent = truncatePrompt(ex.prompt);
          baselineText.textContent = ex.baseline || '(no baseline response)';
          steeredText.textContent = ex.steered || '(no steered response)';
          var desc = ex.feature_description && ex.feature_description !== 'No description available'
            ? ex.feature_description : 'SAE feature';
          badgeLabel.textContent = 'Layer ' + ex.layer + ' / Feature ' + ex.feature_index + ': ' + desc;
          var corrNum = typeof ex.correlation === 'number' ? ex.correlation : 0;
          corrVal.textContent = 'r = ' + corrNum.toFixed(3);
          corrFill.style.width = (Math.abs(corrNum) * 100) + '%';
          counter.textContent = (currentIdx + 1) + ' / ' + examples.length;
        }

        if (animate) {
          targets.forEach(function(el) {
            if (el) { el.style.opacity = '0'; el.style.transform = 'translateY(4px)'; }
          });
          setTimeout(function() {
            apply();
            targets.forEach(function(el) {
              if (el) {
                el.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                el.style.opacity = '1';
                el.style.transform = 'translateY(0)';
              }
            });
          }, 150);
        } else {
          apply();
        }
      }

      // ========================
      // Live Steering tab
      // ========================
      function buildLiveTab(panel) {
        if (!apiAvailable) {
          panel.innerHTML = '<div class="api-unavailable"><div class="icon">&#x1f50c;</div><div><strong>Live demo unavailable</strong></div><div style="margin-top:6px">The GPT-2 steering API is not running in this environment.<br>Deploy to HF Spaces to enable real-time generation.</div></div>';
          return;
        }

        // Controls row: category + generate
        var controls = document.createElement('div');
        controls.className = 'controls';

        var controlGroup = document.createElement('div');
        controlGroup.className = 'control-group';
        var label = document.createElement('span');
        label.className = 'control-label';
        label.textContent = 'Category';
        var catSelect = document.createElement('select');
        catSelect.id = 'live-cat-select';
        Object.keys(LIVE_CATEGORIES).forEach(function(k) {
          var opt = document.createElement('option');
          opt.value = k;
          opt.textContent = LIVE_CATEGORIES[k].label;
          catSelect.appendChild(opt);
        });
        controlGroup.appendChild(label);
        controlGroup.appendChild(catSelect);
        controls.appendChild(controlGroup);

        var genBtn = document.createElement('button');
        genBtn.className = 'btn-generate';
        genBtn.id = 'live-gen-btn';
        genBtn.innerHTML = '<svg viewBox="0 0 16 16" fill="none"><polygon points="4,2 14,8 4,14" fill="currentColor"/></svg> Generate';
        controls.appendChild(genBtn);
        panel.appendChild(controls);

        // Prompt card showing what will be sent
        var promptCard = document.createElement('div');
        promptCard.className = 'prompt-card';
        promptCard.id = 'live-prompt';
        var currentCat = Object.keys(LIVE_CATEGORIES)[0];
        promptCard.innerHTML = '<div class="prompt-label">Given Context</div><div class="prompt-text" id="live-prompt-text">' + LIVE_CATEGORIES[currentCat].prompt + '</div>';
        panel.appendChild(promptCard);

        // Update prompt on category change
        catSelect.addEventListener('change', function() {
          var pt = document.getElementById('live-prompt-text');
          if (pt) pt.textContent = LIVE_CATEGORIES[catSelect.value].prompt;
          // Reset generated flags and show new prompt preview
          LIVE_TYPES.forEach(function(t) {
            var body = document.getElementById('live-body-' + t.key);
            if (body) delete body.dataset.generated;
          });
          setPromptPreview();
        });

        // 4-panel grid with icons and descriptions
        var grid = document.createElement('div');
        grid.className = 'live-grid';
        function setPromptPreview() {
          var prompt = LIVE_CATEGORIES[catSelect.value].prompt;
          LIVE_TYPES.forEach(function(t) {
            var body = document.getElementById('live-body-' + t.key);
            if (body && !body.dataset.generated) {
              body.innerHTML = '<span style="color:' + t.color + ';font-weight:500">' + prompt + '</span><span style="color:var(--rd-text-secondary);font-style:italic"> ...</span>';
            }
          });
        }

        LIVE_TYPES.forEach(function(t) {
          var p = document.createElement('div');
          p.className = 'live-panel';
          p.innerHTML = '<div class="live-panel-header">' +
            '<span style="color:' + t.color + ';display:flex;align-items:center">' + t.icon + '</span>' +
            '<div><div class="panel-title" style="color:' + t.color + '">' + t.label + '</div>' +
            '<div style="font-size:10px;color:var(--rd-text-secondary);margin-top:1px">' + t.desc + '</div></div>' +
            '</div>' +
            '<div class="live-panel-body" id="live-body-' + t.key + '"></div>';
          grid.appendChild(p);
        });
        panel.appendChild(grid);
        setPromptPreview();

        var generating = false;
        var playIcon = '<svg viewBox="0 0 16 16" fill="none"><polygon points="4,2 14,8 4,14" fill="currentColor"/></svg>';

        genBtn.addEventListener('click', function() {
          if (generating) return;
          generating = true;
          genBtn.disabled = true;
          genBtn.innerHTML = '<span class="spinner"></span> Generating...';

          var category = catSelect.value;
          var promptText = LIVE_CATEGORIES[category].prompt;
          var completed = 0;

          LIVE_TYPES.forEach(function(t) {
            var bodyEl = document.getElementById('live-body-' + t.key);
            bodyEl.dataset.generated = '1';
            bodyEl.innerHTML = '<span style="color:' + t.color + ';font-weight:500">' + promptText + '</span><span class="cursor"></span>';

            fetch(apiBase + '/api/generate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                model: 'gpt2',
                dataset: 'emgsd',
                category: category,
                type: t.key
              })
            }).then(function(response) {
              var reader = response.body.getReader();
              var decoder = new TextDecoder();
              var text = '';

              function read() {
                reader.read().then(function(result) {
                  if (result.done) {
                    bodyEl.innerHTML = '<span style="color:' + t.color + ';font-weight:500">' + promptText + '</span>' + text;
                    completed++;
                    if (completed >= LIVE_TYPES.length) {
                      generating = false;
                      genBtn.disabled = false;
                      genBtn.innerHTML = playIcon + ' Generate';
                    }
                    return;
                  }
                  text += decoder.decode(result.value, { stream: true });
                  bodyEl.innerHTML = '<span style="color:' + t.color + ';font-weight:500">' + promptText + '</span>' + text + '<span class="cursor"></span>';
                  read();
                });
              }
              read();
            }).catch(function() {
              bodyEl.innerHTML = '<span style="color:' + t.color + ';font-weight:500">' + promptText + '</span> <em>(generation failed)</em>';
              completed++;
              if (completed >= LIVE_TYPES.length) {
                generating = false;
                genBtn.disabled = false;
                genBtn.innerHTML = playIcon + ' Generate';
              }
            });
          });
        });
      }

      // ========================
      // Main build
      // ========================
      function buildUI() {
        container.innerHTML = '';

        // Tab bar
        var tabs = document.createElement('div');
        tabs.className = 'tabs';

        var examplesBtn = document.createElement('button');
        examplesBtn.className = 'tab-btn';
        examplesBtn.textContent = 'Examples';
        examplesBtn.dataset.tab = 'examples';
        tabs.appendChild(examplesBtn);

        var liveBtn = document.createElement('button');
        liveBtn.className = 'tab-btn active';
        liveBtn.textContent = 'Live Steering';
        liveBtn.dataset.tab = 'live';
        tabs.appendChild(liveBtn);

        container.appendChild(tabs);

        // Tab panels
        var examplesPanel = document.createElement('div');
        examplesPanel.className = 'tab-panel';
        examplesPanel.id = 'tab-examples';
        container.appendChild(examplesPanel);

        var livePanel = document.createElement('div');
        livePanel.className = 'tab-panel active';
        livePanel.id = 'tab-live';
        container.appendChild(livePanel);

        // Build tab contents
        buildExamplesTab(examplesPanel);
        buildLiveTab(livePanel);

        // Tab switching
        var tabBtns = [examplesBtn, liveBtn];
        var tabPanels = [examplesPanel, livePanel];
        tabBtns.forEach(function(btn, i) {
          btn.addEventListener('click', function() {
            tabBtns.forEach(function(b) { b.classList.remove('active'); });
            tabPanels.forEach(function(p) { p.classList.remove('active'); });
            btn.classList.add('active');
            tabPanels[i].classList.add('active');
          });
        });
      }

      // Load data + check API, then build
      Promise.all([
        fetchFirstAvailable(DATA_PATHS).then(function(data) {
          allData = data;
          var grouped = {};
          data.forEach(function(ex) {
            var t = ex.task;
            if (!grouped[t]) grouped[t] = [];
            grouped[t].push(ex);
          });
          Object.keys(grouped).forEach(function(t) {
            grouped[t] = shuffleArray(grouped[t]);
          });
          taskMap = grouped;
          var availableTasks = Object.keys(TASK_LABELS).filter(function(t) { return taskMap[t] && taskMap[t].length > 0; });
          if (availableTasks.length > 0) currentTask = availableTasks[0];
          currentIdx = 0;
        }),
        checkApi()
      ]).then(function() {
        buildUI();
      }).catch(function(err) {
        container.innerHTML = '<div class="loading-msg">Could not load data: ' + err.message + '</div>';
      });

      // Dark mode observer
      var observer = new MutationObserver(function() {});
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">See how CorrSteer changes model responses on safety-critical and knowledge tasks. Select different tasks to explore.</figcaption></figure> </div>
<h2 id="the-corrsteer-method"><a href="#the-corrsteer-method">The CorrSteer Method</a></h2>
<p>CorrSteer solves these problems with a simple two-stage approach: <strong>correlate</strong>, then <strong>intervene</strong>.</p>
<div class="full-width"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-fz2bnidwomm"><div class="corrsteer-pipeline" id="corrsteer-pipeline">
  <div class="pipeline-stages"></div>
</div>

<style>
  .corrsteer-pipeline {
    --cp-primary: #6B5CE7;
    --cp-primary-light: #8B7FF0;
    --cp-primary-faint: rgba(107, 92, 231, 0.12);
    --cp-primary-glow: rgba(107, 92, 231, 0.25);
    --cp-text: var(--text-color, #1a1a2e);
    --cp-text-muted: var(--muted-color, rgba(0,0,0,0.55));
    --cp-bg: var(--page-bg, #ffffff);
    --cp-surface: var(--surface-bg, #f9f9f9);
    --cp-card-bg: var(--surface-bg, #f9f9f9);
    --cp-card-border: var(--border-color, rgba(0,0,0,0.1));
    --cp-card-border-active: color-mix(in srgb, var(--cp-primary) 50%, transparent);
    --cp-dot-pos: #6B5CE7;
    --cp-dot-neg: var(--muted-color, rgba(0,0,0,0.2));
    --cp-line: #6B5CE7;
    --cp-bar1: #6B5CE7;
    --cp-bar2: #8B7FF0;
    --cp-bar3: #A89BF5;
    --cp-bar4: #C5BCFA;
    --cp-bar5: #DDD8FC;
    --cp-connector: var(--muted-color, rgba(0,0,0,0.18));
    --cp-connector-active: var(--cp-primary);
    --cp-viz-bg: rgba(107, 92, 231, 0.06);
    font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
    width: 100%;
    padding: 20px 0;
    overflow: hidden;
  }

  /* Dark mode overrides */
  .corrsteer-pipeline.dark-mode {
    --cp-primary-faint: rgba(139, 127, 240, 0.18);
    --cp-primary-glow: rgba(139, 127, 240, 0.4);
    --cp-text: rgba(255, 255, 255, 0.9);
    --cp-text-muted: rgba(255, 255, 255, 0.55);
    --cp-card-bg: #1a1d28;
    --cp-card-border: rgba(255, 255, 255, 0.12);
    --cp-dot-neg: rgba(255, 255, 255, 0.35);
    --cp-viz-bg: rgba(107, 92, 231, 0.12);
    --cp-bar4: #b0a3f7;
    --cp-bar5: #c8bffa;
    --cp-connector: rgba(255, 255, 255, 0.25);
  }

  .pipeline-stages {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0;
    max-width: 960px;
    margin: 0 auto;
    padding: 0 16px;
  }

  /* --- Stage Card --- */
  .cp-stage {
    flex: 1;
    max-width: 280px;
    min-width: 200px;
    opacity: 0;
    transform: translateY(24px);
    transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1),
                transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }
  .cp-stage.visible {
    opacity: 1;
    transform: translateY(0);
  }

  .cp-card {
    background: var(--cp-card-bg);
    border: 1px solid var(--cp-card-border);
    border-radius: 16px;
    padding: 24px 20px 20px;
    position: relative;
    transition: border-color 0.4s ease, box-shadow 0.4s ease, transform 0.3s ease;
    cursor: pointer;
  }
  .cp-stage.visible .cp-card {
    border-color: var(--cp-card-border-active);
    box-shadow: 0 4px 24px -4px var(--cp-primary-glow),
                0 1px 3px rgba(0,0,0,0.04);
  }
  .cp-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 32px -4px var(--cp-primary-glow),
                0 2px 6px rgba(0,0,0,0.06);
  }

  .cp-stage-number {
    position: absolute;
    top: -13px;
    left: 20px;
    background: var(--cp-primary);
    color: #fff;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.5px;
    padding: 3px 12px;
    border-radius: 20px;
    text-transform: uppercase;
  }

  .cp-viz {
    width: 100%;
    height: 140px;
    margin-bottom: 16px;
    border-radius: 10px;
    background: var(--cp-viz-bg);
    overflow: visible;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px 4px;
    box-sizing: border-box;
  }

  .cp-label {
    font-size: 17px;
    font-weight: 700;
    color: var(--cp-text);
    margin-bottom: 4px;
    letter-spacing: -0.01em;
  }

  .cp-subtitle {
    font-size: 12.5px;
    color: var(--cp-text-muted);
    line-height: 1.45;
  }

  /* --- Connector Arrow --- */
  .cp-connector {
    flex: 0 0 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 130px;
    margin-top: -42px;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  .cp-connector.visible {
    opacity: 1;
  }

  .cp-connector svg {
    overflow: visible;
  }

  .cp-connector-line {
    stroke: var(--cp-connector);
    stroke-width: 1.5;
    stroke-dasharray: 4 3;
    stroke-dashoffset: 40;
    transition: stroke 0.4s ease;
  }
  .cp-connector.visible .cp-connector-line {
    stroke: var(--cp-connector-active);
    animation: cp-dash 0.8s ease-out forwards;
  }

  .cp-connector-arrow {
    fill: var(--cp-connector);
    transition: fill 0.4s ease;
  }
  .cp-connector.visible .cp-connector-arrow {
    fill: var(--cp-connector-active);
  }

  @keyframes cp-dash {
    to { stroke-dashoffset: 0; }
  }

  /* --- Scatter Plot Animation (Stage 1) --- */
  .scatter-dot {
    opacity: 0;
    transform-origin: center;
    cursor: pointer;
    transition: r 0.15s ease, filter 0.15s ease, opacity 0.15s ease;
  }
  .cp-stage.animating .scatter-dot {
    animation: cp-dot-appear 0.3s ease-out forwards;
  }

  @keyframes cp-dot-appear {
    0% { opacity: 0; transform: scale(0); }
    60% { transform: scale(1.3); }
    100% { opacity: 1; transform: scale(1); }
  }

  .scatter-line {
    stroke-dasharray: 200;
    stroke-dashoffset: 200;
  }
  .cp-stage.animating .scatter-line {
    animation: cp-line-draw 0.8s ease-out forwards;
    animation-delay: 0.8s;
  }

  @keyframes cp-line-draw {
    to { stroke-dashoffset: 0; }
  }

  .scatter-r-value {
    opacity: 0;
  }
  .cp-stage.animating .scatter-r-value {
    animation: cp-fade-in 0.5s ease-out forwards;
    animation-delay: 1.4s;
  }

  /* --- Bar Chart Animation (Stage 2) --- */
  .coeff-bar {
    transform-origin: bottom;
    transform: scaleY(0);
  }
  .cp-stage.animating .coeff-bar {
    animation: cp-bar-grow 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }

  @keyframes cp-bar-grow {
    to { transform: scaleY(1); }
  }

  .coeff-label {
    opacity: 0;
  }
  .cp-stage.animating .coeff-label {
    animation: cp-fade-in 0.4s ease-out forwards;
  }

  @keyframes cp-fade-in {
    to { opacity: 1; }
  }

  /* --- Neural Net Animation (Stage 3) --- */
  .nn-node {
    opacity: 0;
  }
  .cp-stage.animating .nn-node {
    animation: cp-node-appear 0.3s ease-out forwards;
  }

  @keyframes cp-node-appear {
    0% { opacity: 0; transform: scale(0.5); }
    100% { opacity: 1; transform: scale(1); }
  }

  .nn-connection {
    stroke-dasharray: 100;
    stroke-dashoffset: 100;
    opacity: 0.3;
  }
  .cp-stage.animating .nn-connection {
    animation: cp-nn-line 0.4s ease-out forwards;
  }

  @keyframes cp-nn-line {
    to { stroke-dashoffset: 0; opacity: 0.3; }
  }

  .nn-steer-arrow {
    opacity: 0;
  }
  .cp-stage.animating .nn-steer-arrow {
    animation: cp-steer-inject 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    animation-delay: 0.7s;
  }

  @keyframes cp-steer-inject {
    0% { opacity: 0; transform: scale(0.5); }
    100% { opacity: 1; transform: scale(1); }
  }

  /* Steering arrow pulse glow on highlight */
  .nn-steer-arrow-group line {
    transition: stroke-width 0.3s, opacity 0.3s;
  }

  .nn-steer-plus, .nn-steer-eq {
    opacity: 0;
  }
  .cp-stage.animating .nn-steer-plus {
    animation: cp-fade-in 0.4s ease-out forwards;
    animation-delay: 0.6s;
  }
  .cp-stage.animating .nn-steer-eq {
    animation: cp-fade-in 0.4s ease-out forwards;
    animation-delay: 1.0s;
  }

  .nn-steer-result-label {
    opacity: 0;
  }
  .cp-stage.animating .nn-steer-result-label {
    animation: cp-fade-in 0.4s ease-out forwards;
    animation-delay: 1.1s;
  }

  .nn-output-shift {
    opacity: 0;
  }
  .cp-stage.animating .nn-output-shift {
    animation: cp-output-glow 0.5s ease-out forwards;
    animation-delay: 1.1s;
  }

  @keyframes cp-output-glow {
    0% { opacity: 0; transform: scale(0.8); }
    100% { opacity: 1; transform: scale(1); }
  }

  .cp-stage.animating .nn-output-shift.pulse {
    animation: cp-output-glow 0.5s ease-out forwards, cp-pulse 2s ease-in-out 1.6s infinite;
  }

  @keyframes cp-pulse {
    0%, 100% { transform: scale(1); opacity: 0.5; }
    50% { transform: scale(1.15); opacity: 0.8; }
  }

  /* --- Responsive --- */
  @media (max-width: 768px) {
    .pipeline-stages {
      flex-direction: column;
      gap: 0;
      padding: 0 20px;
    }

    .cp-stage {
      max-width: 100%;
      min-width: 0;
      width: 100%;
    }

    .cp-connector {
      flex: 0 0 32px;
      height: auto;
      margin-top: 0;
      transform: rotate(90deg);
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const root = document.getElementById('corrsteer-pipeline');
    const container = root.querySelector('.pipeline-stages');

    // ---- Dark mode detection (JS-based, like other embeds) ----
    function applyTheme() {
      var isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      root.classList.toggle('dark-mode', isDark);
    }
    applyTheme();
    new MutationObserver(function(muts) {
      for (var i = 0; i < muts.length; i++) {
        if (muts[i].attributeName === 'data-theme') { applyTheme(); break; }
      }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // --- Build Stage 1: Scatter Plot ---
    function buildScatterSVG() {
      // Synthetic data points mimicking correlation
      const points = [
        {x: 12, y: 22, pos: false}, {x: 18, y: 30, pos: false},
        {x: 25, y: 35, pos: false}, {x: 30, y: 48, pos: true},
        {x: 38, y: 42, pos: false}, {x: 42, y: 55, pos: true},
        {x: 48, y: 52, pos: true}, {x: 55, y: 60, pos: true},
        {x: 60, y: 58, pos: true}, {x: 65, y: 72, pos: true},
        {x: 72, y: 68, pos: true}, {x: 78, y: 80, pos: true},
        {x: 82, y: 75, pos: true}, {x: 88, y: 85, pos: true},
        {x: 35, y: 28, pos: false}, {x: 52, y: 62, pos: true},
        {x: 20, y: 40, pos: false}, {x: 70, y: 78, pos: true},
      ];

      // Mark top-5 positive dots by y-value (descending) → maps 1:1 to bars f₁-f₅
      const posWithIdx = points.map((p, i) => ({...p, origIdx: i})).filter(p => p.pos);
      posWithIdx.sort((a, b) => b.y - a.y);
      const top5Set = {};
      posWithIdx.slice(0, 5).forEach((p, rank) => { top5Set[p.origIdx] = rank; });

      const pad = 20;
      const w = 200, h = 110;
      let dots = '';
      points.forEach((p, i) => {
        const cx = pad + (p.x / 100) * (w - 2 * pad);
        const cy = h - pad - (p.y / 100) * (h - 2 * pad);
        const fill = p.pos ? 'var(--cp-dot-pos)' : 'var(--cp-dot-neg)';
        const featureAttr = (i in top5Set) ? ` data-feature="${top5Set[i]}"` : '';
        const r = (i in top5Set) ? 4.5 : 3.5;
        dots += `<circle class="scatter-dot" cx="${cx}" cy="${cy}" r="${r}" fill="${fill}"${featureAttr} style="animation-delay: ${0.05 * i}s"/>`;
      });

      // Regression line (approx y = 0.75x + 15)
      const x1 = pad, y1 = h - pad - (15 / 100) * (h - 2 * pad);
      const x2 = w - pad, y2 = h - pad - (90 / 100) * (h - 2 * pad);

      return `<svg viewBox="0 0 ${w} ${h}" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
        <!-- Axes -->
        <line x1="${pad}" y1="${h - pad}" x2="${w - pad}" y2="${h - pad}" stroke="var(--cp-text-muted)" stroke-width="0.7" opacity="0.4"/>
        <line x1="${pad}" y1="${pad}" x2="${pad}" y2="${h - pad}" stroke="var(--cp-text-muted)" stroke-width="0.7" opacity="0.4"/>
        <text x="${w / 2}" y="${h - 4}" fill="var(--cp-text-muted)" font-size="7.5" text-anchor="middle" font-family="inherit" font-style="italic">z\u1d62 (activation)</text>
        <text x="7" y="${h / 2}" fill="var(--cp-text-muted)" font-size="7.5" text-anchor="middle" font-family="inherit" font-style="italic" transform="rotate(-90, 7, ${h / 2})">y (score)</text>
        ${dots}
        <line class="scatter-line" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="var(--cp-line)" stroke-width="2" stroke-linecap="round" opacity="0.8"/>
        <g class="scatter-r-value">
          <rect x="${w - 65}" y="8" width="52" height="20" rx="4" fill="var(--cp-primary)" opacity="0.12"/>
          <text x="${w - 39}" y="22" fill="var(--cp-primary)" font-size="11" font-weight="700" text-anchor="middle" font-family="inherit">r = .83</text>
        </g>
      </svg>`;
    }

    // --- Build Stage 2: Bar Chart ---
    function buildBarSVG() {
      const bars = [
        { h: 80, label: 'f\u2081' },
        { h: 62, label: 'f\u2082' },
        { h: 45, label: 'f\u2083' },
        { h: 32, label: 'f\u2084' },
        { h: 20, label: 'f\u2085' },
      ];
      const colors = ['var(--cp-bar1)', 'var(--cp-bar2)', 'var(--cp-bar3)', 'var(--cp-bar4)', 'var(--cp-bar5)'];
      const w = 200, h = 110;
      const pad = 18;
      const barW = 24;
      const gap = 8;
      const totalW = bars.length * barW + (bars.length - 1) * gap;
      const startX = (w - totalW) / 2;
      const maxH = h - 2 * pad - 8;

      let barsSVG = '';
      bars.forEach((b, i) => {
        const bh = (b.h / 100) * maxH;
        const x = startX + i * (barW + gap);
        const y = h - pad - bh;
        const delay = 0.1 * i;
        barsSVG += `<rect class="coeff-bar" data-bar="${i}" x="${x}" y="${y}" width="${barW}" height="${bh}" rx="3" fill="${colors[i]}" style="animation-delay: ${delay}s; transform-origin: ${x + barW/2}px ${h - pad}px; cursor: pointer"/>`;
        barsSVG += `<text class="coeff-label" x="${x + barW / 2}" y="${h - pad + 12}" fill="var(--cp-text-muted)" font-size="8" text-anchor="middle" font-family="inherit" style="animation-delay: ${delay + 0.3}s">${b.label}</text>`;
      });

      // Y-axis label for coefficient values
      barsSVG += `<text class="coeff-label" x="${startX - 4}" y="${pad + 4}" fill="var(--cp-text-muted)" font-size="8" text-anchor="end" font-family="inherit" font-style="italic" style="animation-delay: 0.6s">c\u1d62</text>`;

      return `<svg viewBox="0 0 ${w} ${h}" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
        <line x1="${pad}" y1="${h - pad}" x2="${w - pad}" y2="${h - pad}" stroke="var(--cp-text-muted)" stroke-width="0.7" opacity="0.4"/>
        <line x1="${pad}" y1="${pad}" x2="${pad}" y2="${h - pad}" stroke="var(--cp-text-muted)" stroke-width="0.7" opacity="0.4"/>
        ${barsSVG}
      </svg>`;
    }

    // --- Build Stage 3: Neural Network + Steering ---
    function buildNNSVG() {
      const w = 220, h = 120;
      // Layout: x_t label | compact NN (2 layers) | + | rotating arrow with label | = | x'_t label
      // Compact 2-hidden-layer network positioned on the left portion
      const nnLeftX = 30;   // start of NN
      const layers = [
        { nodes: 3, x: nnLeftX },
        { nodes: 4, x: nnLeftX + 30 },
        { nodes: 3, x: nnLeftX + 60 },
      ];
      const nodeR = 4.5;
      const nnCenterY = h / 2 + 4;

      function getNodeY(layerIdx, nodeIdx) {
        const n = layers[layerIdx].nodes;
        const spacing = 14;
        const totalH = (n - 1) * spacing;
        return nnCenterY - totalH / 2 + nodeIdx * spacing;
      }

      // Connections
      let connections = '';
      let connDelay = 0;
      for (let l = 0; l < layers.length - 1; l++) {
        for (let i = 0; i < layers[l].nodes; i++) {
          for (let j = 0; j < layers[l + 1].nodes; j++) {
            const x1 = layers[l].x + nodeR;
            const y1 = getNodeY(l, i);
            const x2 = layers[l + 1].x - nodeR;
            const y2 = getNodeY(l + 1, j);
            connections += `<line class="nn-connection" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="var(--cp-text-muted)" stroke-width="0.6" style="animation-delay: ${connDelay * 0.02}s"/>`;
            connDelay++;
          }
        }
      }

      // Nodes
      let nodes = '';
      let nodeDelay = 0;
      let globalNodeIdx = 0;
      layers.forEach((layer, l) => {
        for (let i = 0; i < layer.nodes; i++) {
          const cy = getNodeY(l, i);
          const isLast = l === layers.length - 1;
          const stroke = isLast ? 'var(--cp-primary)' : 'var(--cp-text-muted)';
          const strokeW = isLast ? 1.2 : 0.7;
          nodes += `<circle class="nn-node" cx="${layer.x}" cy="${cy}" r="${nodeR}" fill="var(--cp-primary-faint)" stroke="${stroke}" stroke-width="${strokeW}" data-node-idx="${globalNodeIdx}" data-base-cx="${layer.x}" data-base-cy="${cy}" data-layer="${l}" style="animation-delay: ${nodeDelay * 0.04}s"/>`;
          nodeDelay++;
          globalNodeIdx++;
        }
      });

      // x_t label (before the NN)
      const inputLabelX = nnLeftX - 14;
      nodes += `<text class="nn-node" x="${inputLabelX}" y="${nnCenterY + 3.5}" fill="var(--cp-text-muted)" font-size="9" text-anchor="middle" font-family="inherit" font-style="italic" style="animation-delay: 0s">x\u209c</text>`;

      // Positions for the equation elements after the NN
      const lastLayerX = layers[2].x;
      const plusX = lastLayerX + 18;    // "+" symbol
      const arrowCenterX = plusX + 28;  // rotating arrow center
      const eqX = arrowCenterX + 28;   // "=" symbol
      const resultX = eqX + 16;        // x'_t label

      // "+" symbol (additive operation)
      const plusSVG = `<text class="nn-steer-plus" x="${plusX}" y="${nnCenterY + 4}" fill="var(--cp-primary)" font-size="14" font-weight="700" text-anchor="middle" font-family="inherit">+</text>`;

      // Rotating steering arrow with label
      // Arrow centered slightly below nnCenterY, default points right (90°)
      const arrowLen = 12;
      const half = arrowLen / 2;
      const arrowCY = nnCenterY;
      const baseY = arrowCY + half;
      const tipY = arrowCY - half;
      const steerArrow = `
        <g class="nn-steer-arrow">
          <g class="nn-steer-arrow-group" style="transform-origin: ${arrowCenterX}px ${arrowCY}px; transition: none; transform: rotate(90deg)">
            <line class="nn-steer-line" x1="${arrowCenterX}" y1="${baseY}" x2="${arrowCenterX}" y2="${tipY + 3}" stroke="var(--cp-primary)" stroke-width="1.8" stroke-linecap="round"/>
            <polygon class="nn-steer-head" points="${arrowCenterX},${tipY} ${arrowCenterX - 3},${tipY + 4.5} ${arrowCenterX + 3},${tipY + 4.5}" fill="var(--cp-primary)"/>
          </g>
          <text class="nn-steer-label" x="${arrowCenterX}" y="${arrowCY + half + 14}" fill="var(--cp-primary)" font-size="7" font-weight="700" text-anchor="middle" font-family="inherit">c\u1d62\u00b7W<tspan font-size="5" dy="2">dec</tspan></text>
        </g>
      `;

      // "=" symbol
      const eqSVG = `<text class="nn-steer-eq" x="${eqX}" y="${nnCenterY + 4}" fill="var(--cp-primary)" font-size="13" font-weight="700" text-anchor="middle" font-family="inherit">=</text>`;

      // x'_t result label
      const resultSVG = `<text class="nn-steer-result-label" x="${resultX}" y="${nnCenterY + 3.5}" fill="var(--cp-primary)" font-size="9.5" font-weight="700" text-anchor="middle" font-family="inherit" font-style="italic">x\u2032\u209c</text>`;

      // Output glow around the result label area
      const glowSVG = `<circle class="nn-output-shift pulse" cx="${resultX}" cy="${nnCenterY}" r="10" fill="none" stroke="var(--cp-primary)" stroke-width="1" opacity="0.4" style="transform-origin: ${resultX}px ${nnCenterY}px"/>`;

      return `<svg viewBox="0 0 ${w} ${h}" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
        ${connections}
        ${nodes}
        ${plusSVG}
        ${steerArrow}
        ${eqSVG}
        ${resultSVG}
        ${glowSVG}
      </svg>`;
    }

    // --- Build Connector Arrow SVG ---
    function buildConnector() {
      return `<svg viewBox="0 0 36 24" width="36" height="24">
        <line class="cp-connector-line" x1="2" y1="12" x2="28" y2="12" />
        <polygon class="cp-connector-arrow" points="26,8 34,12 26,16" />
      </svg>`;
    }

    // --- Assemble ---
    const stages = [
      {
        num: 'Stage 1',
        label: 'Correlate',
        subtitle: 'Find SAE features correlated with task success',
        svg: buildScatterSVG()
      },
      {
        num: 'Stage 2',
        label: 'Estimate',
        subtitle: 'Compute steering coefficients from successful generations',
        svg: buildBarSVG()
      },
      {
        num: 'Stage 3',
        label: 'Steer',
        subtitle: 'Add steering vectors during generation',
        svg: buildNNSVG()
      }
    ];

    let html = '';
    stages.forEach((s, i) => {
      if (i > 0) {
        html += `<div class="cp-connector" data-index="${i - 1}">${buildConnector()}</div>`;
      }
      html += `
        <div class="cp-stage" data-index="${i}">
          <div class="cp-card">
            <div class="cp-stage-number">${s.num}</div>
            <div class="cp-viz">${s.svg}</div>
            <div class="cp-label">${s.label}</div>
            <div class="cp-subtitle">${s.subtitle}</div>
          </div>
        </div>
      `;
    });
    container.innerHTML = html;

    // --- IntersectionObserver Animation ---
    let hasAnimated = false;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !hasAnimated) {
          hasAnimated = true;
          triggerAnimation();
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.25 });

    observer.observe(root);

    function triggerAnimation() {
      const stageEls = container.querySelectorAll('.cp-stage');
      const connectorEls = container.querySelectorAll('.cp-connector');

      stageEls.forEach((el, i) => {
        setTimeout(() => {
          el.classList.add('visible');
          // Trigger internal SVG animations after card appears
          setTimeout(() => {
            el.classList.add('animating');
          }, 200);
        }, i * 600);

        // Show connector after previous stage
        if (i > 0) {
          setTimeout(() => {
            connectorEls[i - 1].classList.add('visible');
          }, i * 600 - 200);
        }
      });
    }

    // =============================================
    // Cross-stage interactivity (bidirectional)
    // =============================================
    // Top-5 positive dots have data-feature="0"-"4" → maps 1:1 to bars data-bar="0"-"4"
    // Hover any stage → all 3 stages react

    const stageEls2 = container.querySelectorAll('.cp-stage');
    const stage1 = stageEls2[0], stage2 = stageEls2[1], stage3 = stageEls2[2];

    function getFeatureDot(idx) { return stage1.querySelector('.scatter-dot[data-feature="' + idx + '"]'); }
    function getAllDots() { return stage1.querySelectorAll('.scatter-dot'); }
    function getAllBars() { return stage2.querySelectorAll('.coeff-bar'); }

    // --- Highlight helpers ---
    function highlightFeature(featureIdx) {
      // Stage 1: highlight matching dot, dim others
      getAllDots().forEach(function(d) {
        var fi = d.getAttribute('data-feature');
        d.style.transition = 'opacity 0.25s, filter 0.25s';
        if (fi === String(featureIdx)) {
          d.setAttribute('r', '6.5');
          d.style.filter = 'drop-shadow(0 0 6px var(--cp-primary))';
          d.style.opacity = '1';
        } else if (fi !== null) {
          d.setAttribute('r', '4.5');
          d.style.filter = '';
          d.style.opacity = '0.3';
        } else {
          d.setAttribute('r', '3.5');
          d.style.filter = '';
          d.style.opacity = '0.2';
        }
      });

      // Stage 2: highlight matching bar, dim others
      getAllBars().forEach(function(bar) {
        var bi = bar.getAttribute('data-bar');
        bar.style.transition = 'opacity 0.25s, filter 0.25s';
        if (bi === String(featureIdx)) {
          bar.style.opacity = '1';
          bar.style.filter = 'drop-shadow(0 0 6px var(--cp-primary)) brightness(1.15)';
        } else {
          bar.style.opacity = '0.25';
          bar.style.filter = '';
        }
      });

      // Stage 3: rotate arrow to feature-specific direction, glow
      var arrowGroup = stage3.querySelector('.nn-steer-arrow-group');
      var arrow = stage3.querySelector('.nn-steer-arrow');
      var outputs = stage3.querySelectorAll('.nn-output-shift');
      var steerLine = stage3.querySelector('.nn-steer-line');
      // Each feature gets a fixed angle based on its index (spread across 360°)
      // Pseudo-random angle per feature using golden angle (137.5°) for max spread
      var angle = ((featureIdx * 137.5) + 42) % 360;
      if (arrowGroup) {
        arrowGroup.style.transform = 'rotate(' + angle + 'deg)';
      }
      if (arrow) {
        arrow.style.filter = 'drop-shadow(0 0 10px var(--cp-primary))';
      }
      if (steerLine) {
        steerLine.style.transition = 'stroke-width 0.25s';
        steerLine.style.strokeWidth = '2.5';
      }
      outputs.forEach(function(o) {
        o.style.transition = 'stroke-width 0.25s, opacity 0.25s';
        o.style.strokeWidth = '2';
        o.style.opacity = '0.8';
      });

      // Connectors pulse
      container.querySelectorAll('.cp-connector-line').forEach(function(l) {
        l.style.transition = 'stroke-width 0.25s'; l.style.strokeWidth = '3';
      });
      container.querySelectorAll('.cp-connector-arrow').forEach(function(a) {
        a.style.transition = 'transform 0.25s'; a.style.transform = 'scale(1.1)';
      });
    }

    function resetAllStages() {
      getAllDots().forEach(function(d) {
        var fi = d.getAttribute('data-feature');
        d.setAttribute('r', fi !== null ? '4.5' : '3.5');
        d.style.filter = '';
        d.style.opacity = '1';
        d.style.transition = 'opacity 0.25s, filter 0.25s';
      });
      getAllBars().forEach(function(bar) {
        bar.style.opacity = '1';
        bar.style.filter = '';
        bar.style.transition = 'opacity 0.25s, filter 0.25s';
      });
      var arrow = stage3.querySelector('.nn-steer-arrow');
      var arrowGroup = stage3.querySelector('.nn-steer-arrow-group');
      var steerLine = stage3.querySelector('.nn-steer-line');
      var outputs = stage3.querySelectorAll('.nn-output-shift');
      if (arrow) { arrow.style.filter = ''; }
      if (arrowGroup) { arrowGroup.style.transform = 'rotate(90deg)'; }
      if (steerLine) { steerLine.style.strokeWidth = '1.8'; }
      outputs.forEach(function(o) { o.style.strokeWidth = '1'; o.style.opacity = '0.4'; });
      container.querySelectorAll('.cp-connector-line').forEach(function(l) { l.style.strokeWidth = '2'; });
      container.querySelectorAll('.cp-connector-arrow').forEach(function(a) { a.style.transform = ''; });
    }

    // --- Stage 1 hover: find nearest dot → highlight feature across all stages ---
    function findNearestDot(e) {
      var viz = stage1.querySelector('.cp-viz');
      if (!viz) return -1;
      var svg = viz.querySelector('svg');
      if (!svg) return -1;
      var rect = svg.getBoundingClientRect();
      var scaleX = 200 / rect.width, scaleY = 110 / rect.height;
      var svgX = (e.clientX - rect.left) * scaleX;
      var svgY = (e.clientY - rect.top) * scaleY;
      var best = -1, bestDist = 14;
      getAllDots().forEach(function(dot) {
        var fi = dot.getAttribute('data-feature');
        if (fi === null) return;
        var cx = parseFloat(dot.getAttribute('cx'));
        var cy = parseFloat(dot.getAttribute('cy'));
        var dist = Math.sqrt((svgX - cx) * (svgX - cx) + (svgY - cy) * (svgY - cy));
        if (dist < bestDist) { bestDist = dist; best = parseInt(fi); }
      });
      return best;
    }

    var hoveredFeature = -1;
    stage1.addEventListener('mousemove', function(e) {
      var fi = findNearestDot(e);
      if (fi === hoveredFeature) return;
      hoveredFeature = fi;
      if (fi !== -1) highlightFeature(fi); else resetAllStages();
    });
    stage1.addEventListener('mouseleave', function() {
      hoveredFeature = -1; resetAllStages();
    });

    // --- Stage 2 hover: find nearest bar → highlight feature across all stages ---
    function findNearestBar(e) {
      var viz = stage2.querySelector('.cp-viz');
      if (!viz) return -1;
      var svg = viz.querySelector('svg');
      if (!svg) return -1;
      var rect = svg.getBoundingClientRect();
      var svgX = (e.clientX - rect.left) / rect.width * 200;
      var svgY = (e.clientY - rect.top) / rect.height * 110;
      var best = -1;
      getAllBars().forEach(function(bar) {
        var x = parseFloat(bar.getAttribute('x'));
        var y = parseFloat(bar.getAttribute('y'));
        var w = parseFloat(bar.getAttribute('width'));
        var h = parseFloat(bar.getAttribute('height'));
        if (svgX >= x - 4 && svgX <= x + w + 4 && svgY >= y - 4 && svgY <= y + h + 4) {
          best = parseInt(bar.getAttribute('data-bar'));
        }
      });
      return best;
    }

    stage2.addEventListener('mousemove', function(e) {
      var fi = findNearestBar(e);
      if (fi === hoveredFeature) return;
      hoveredFeature = fi;
      if (fi !== -1) highlightFeature(fi); else resetAllStages();
    });
    stage2.addEventListener('mouseleave', function() {
      hoveredFeature = -1; resetAllStages();
    });

    // --- Stage 3 hover: highlight all stages when hovering the card ---
    stage3.addEventListener('mouseenter', function() {
      // Highlight all 5 features simultaneously (full pipeline glow)
      getAllDots().forEach(function(d) {
        var fi = d.getAttribute('data-feature');
        d.style.transition = 'opacity 0.25s, filter 0.25s';
        if (fi !== null) {
          d.setAttribute('r', '5.5');
          d.style.filter = 'drop-shadow(0 0 4px var(--cp-primary))';
          d.style.opacity = '1';
        } else {
          d.style.opacity = '0.2';
        }
      });
      getAllBars().forEach(function(bar) {
        bar.style.transition = 'filter 0.25s';
        bar.style.opacity = '1';
        bar.style.filter = 'drop-shadow(0 0 4px var(--cp-primary)) brightness(1.1)';
      });
      var arrow = stage3.querySelector('.nn-steer-arrow');
      if (arrow) { arrow.style.filter = 'drop-shadow(0 0 10px var(--cp-primary))'; }
      stage3.querySelectorAll('.nn-output-shift').forEach(function(o) {
        o.style.strokeWidth = '2'; o.style.opacity = '0.8';
      });
      container.querySelectorAll('.cp-connector-line').forEach(function(l) { l.style.strokeWidth = '3'; });
      container.querySelectorAll('.cp-connector-arrow').forEach(function(a) { a.style.transform = 'scale(1.1)'; });
    });
    stage3.addEventListener('mouseleave', function() {
      hoveredFeature = -1; resetAllStages();
    });

    // --- Stage 3: per-node orbit animation ---
    var nnNodes = stage3.querySelectorAll('.nn-node[data-node-idx]');
    var nodePhases = [];
    nnNodes.forEach(function(node, i) {
      // Each node gets unique phase, speed, radius based on layer position
      var layer = parseInt(node.getAttribute('data-layer') || '0');
      nodePhases.push({
        phase: i * 1.3 + layer * 0.7,
        speed: 0.4 + layer * 0.15 + (i % 3) * 0.1,
        radius: 1.0 + layer * 0.5,
        baseCx: parseFloat(node.getAttribute('data-base-cx')),
        baseCy: parseFloat(node.getAttribute('data-base-cy'))
      });
    });

    var nnAnimFrame = null;
    function animateNodes(time) {
      var t = time * 0.001;
      nnNodes.forEach(function(node, i) {
        var p = nodePhases[i];
        var dx = Math.sin(t * p.speed + p.phase) * p.radius;
        var dy = Math.cos(t * p.speed * 0.7 + p.phase + 1.5) * p.radius * 0.6;
        node.setAttribute('cx', (p.baseCx + dx).toFixed(2));
        node.setAttribute('cy', (p.baseCy + dy).toFixed(2));
      });
      nnAnimFrame = requestAnimationFrame(animateNodes);
    }

    // Start orbit after initial animation completes
    setTimeout(function() {
      if (nnNodes.length) requestAnimationFrame(animateNodes);
    }, 2200);

    // Click outside to reset
    document.addEventListener('click', function(e) {
      if (!root.contains(e.target)) { hoveredFeature = -1; resetAllStages(); }
    });
  });
</script>
</div></div></figure> </div>
<h3 id="stage-1-correlation-guided-feature-selection"><a href="#stage-1-correlation-guided-feature-selection">Stage 1: Correlation-Guided Feature Selection</a></h3>
<p>Given a dataset of prompts, we generate responses and capture SAE activations at each layer. For each feature <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, we compute its Pearson correlation with task outcomes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span>:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mtext>Cov</mtext><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><msqrt><mrow><mtext>Var</mtext><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>⋅</mo><mtext>Var</mtext><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">r_i = \frac{\text{Cov}(z_i, y)}{\sqrt{\text{Var}(z_i) \cdot \text{Var}(y)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.8396em;vertical-align:-0.8296em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.4642em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369em"><span class="svg-align" style="top:-3.4286em"><span class="pstrut" style="height:3.4286em"></span><span class="mord mtight" style="padding-left:1.19em"><span class="mord text mtight"><span class="mord mtight">Var</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.044em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mbin mtight">⋅</span><span class="mord text mtight"><span class="mord mtight">Var</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="mclose mtight">)</span></span></span><span style="top:-3.0089em"><span class="pstrut" style="height:3.4286em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.5429em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4197em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Cov</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.044em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8296em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The streaming correlation accumulator uses Welford’s algorithm, requiring only O(1) memory per feature regardless of dataset size. This allows scaling to 10^5+ features.</p> </aside> </div>  
<p>The key insight: we compute correlations on <strong>generation-time activations</strong> (the tokens the model produces), not context tokens (the prompt). This captures features that drive output behavior.</p>
<p>We use <strong>max-pooling</strong> across generated tokens to aggregate multi-token activations, capturing peak feature engagement.</p>
<h3 id="stage-2-coefficient-estimation"><a href="#stage-2-coefficient-estimation">Stage 2: Coefficient Estimation</a></h3>
<p>For each selected feature, the steering coefficient is the mean activation across samples with positive outcomes:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">{</mo><mi>j</mi><mo>:</mo><msub><mi>y</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn><mo stretchy="false">}</mo><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>j</mi><mo>:</mo><msub><mi>y</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow></msub><msub><mi>z</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_i = \frac{1}{|\{j: y_j &gt; 0\}|} \sum_{j: y_j &gt; 0} z_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.3874em;vertical-align:-0.5423em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mopen mtight">{</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em"><span></span></span></span></span></span></span><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span><span class="mclose mtight">}</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em"><span></span></span></span></span></span></span><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.497em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></p>
<p>This anchors the coefficient to the feature’s natural scale during successful generation, exploiting SAE’s non-negative activations.</p>
<h3 id="stage-3-inference-time-steering"><a href="#stage-3-inference-time-steering">Stage 3: Inference-Time Steering</a></h3>
<p>At generation time, we add the steering vector to the residual stream:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">x</mi><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><msub><mi mathvariant="bold">x</mi><mi>t</mi></msub><mo>+</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi mathvariant="bold">W</mi><mtext>dec</mtext></msub><mo stretchy="false">[</mo><mo>:</mo><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{x}&#39;_t = \mathbf{x}_t + \sum_i c_i \cdot \mathbf{W}_{\text{dec}}[:, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9989em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">dec</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></p>
<p>Applied only to generation positions (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t \geq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> is prompt length). The SAE itself is not needed at inference; only the pre-computed steering vectors.</p>
<h2 id="three-variants"><a href="#three-variants">Three Variants</a></h2>
<p>CorrSteer comes in three variants that trade off simplicity against performance:</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">CorrSteer Variants</figcaption><div class="html-embed__card"><div id="frag-sumd7pelmkb" data-datafiles="features_gemma_all.json"><div class="variant-selector"></div>
<style>
  .variant-selector {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .variant-selector .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    margin-top: 12px;
  }

  .variant-selector .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .variant-selector .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .variant-selector .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%23999' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }

  .variant-selector .controls select:focus {
    outline: 2px solid var(--primary-color, #6B5CE7);
    outline-offset: 1px;
  }

  .variant-selector .variant-tabs {
    display: flex;
    gap: 0;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
  }

  .variant-selector .variant-tab {
    padding: 7px 16px;
    font-size: 12px;
    font-weight: 600;
    color: var(--muted-color);
    background: var(--surface-bg);
    border: none;
    border-right: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    white-space: nowrap;
  }

  .variant-selector .variant-tab:last-child {
    border-right: none;
  }

  .variant-selector .variant-tab:hover {
    background: var(--page-bg);
  }

  .variant-selector .variant-tab.active {
    background: var(--primary-color, #6B5CE7);
    color: #fff;
  }

  .variant-selector .axes path,
  .variant-selector .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .variant-selector .axes text {
    fill: var(--tick-color, var(--muted-color));
  }

  .variant-selector .grid line {
    stroke: var(--grid-color, rgba(0,0,0,.08));
  }

  .variant-selector .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }

  .variant-selector .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 8px;
  }

  .variant-selector .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .variant-selector .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .variant-selector .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .variant-selector .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .variant-selector .legend .swatch--line {
    width: 20px;
    height: 3px;
    border-radius: 2px;
    border: none;
  }

  .variant-selector .legend .swatch--dashed {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    border: 2px dashed;
    background: transparent;
  }

  .variant-selector .feature-dot {
    transition: filter 0.15s ease;
  }

  .variant-selector .variant-desc {
    font-size: 12px;
    color: var(--muted-color);
    margin-top: 4px;
    line-height: 1.5;
    min-height: 18px;
  }

  @media (max-width: 600px) {
    .variant-selector .controls {
      flex-direction: column;
      align-items: flex-start;
    }
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('variant-selector'))) {
        const cs = Array.from(document.querySelectorAll('.variant-selector')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, { position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none', padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)', background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease', zIndex: '10', maxWidth: '260px' });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      const showTip = (evt, html) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const pt = d3.pointer(evt, container);
        const tipW = tip.offsetWidth || 180;
        const tipH = tip.offsetHeight || 60;
        const cW = container.clientWidth;
        let x = pt[0] + 12, y = pt[1] - tipH - 8;
        if (x + tipW > cW) x = pt[0] - tipW - 12;
        if (y < 0) y = pt[1] + 16;
        tip.style.transform = `translate(${x}px, ${y}px)`;
      };
      const hideTip = () => { tip.style.opacity = '0'; setTimeout(() => { tip.style.transform = 'translate(-9999px, -9999px)'; }, 120); };

      // SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gDots = gRoot.append('g').attr('class', 'dots');
      const gLine = gRoot.append('g').attr('class', 'connector-line');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      let width = 800, height = 360;
      const margin = { top: 20, right: 24, bottom: 52, left: 56 };
      const xScale = d3.scaleLinear();
      const yScale = d3.scaleLinear();

      // State
      let activeVariant = 'S';
      let activeTask = 'mmlu';
      let rawData = null;

      // Colors
      const PRIMARY = () => {
        try { if (window.ColorPalettes) return window.ColorPalettes.getPrimary(); } catch (_) { }
        return getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#6B5CE7';
      };
      const GREY = () => {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        return isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.15)';
      };
      const PRUNED_COLOR = () => {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        return isDark ? 'rgba(255,255,255,0.35)' : 'rgba(0,0,0,0.25)';
      };

      // Controls: variant tabs + task selector
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls';

      // Variant tabs
      const tabGroup = document.createElement('div');
      tabGroup.className = 'control-group';
      const tabLabel = document.createElement('label');
      tabLabel.textContent = 'Variant';
      tabGroup.appendChild(tabLabel);
      const tabContainer = document.createElement('div');
      tabContainer.className = 'variant-tabs';
      const variants = [
        { key: 'S', label: 'CorrSteer-S' },
        { key: 'A', label: 'CorrSteer-A' },
        { key: 'P', label: 'CorrSteer-P' }
      ];
      variants.forEach(v => {
        const btn = document.createElement('button');
        btn.className = 'variant-tab' + (v.key === activeVariant ? ' active' : '');
        btn.textContent = v.label;
        btn.dataset.variant = v.key;
        btn.addEventListener('click', () => {
          activeVariant = v.key;
          tabContainer.querySelectorAll('.variant-tab').forEach(b => b.classList.toggle('active', b.dataset.variant === v.key));
          updateDesc();
          render();
        });
        tabContainer.appendChild(btn);
      });
      tabGroup.appendChild(tabContainer);

      // Task selector
      const taskGroup = document.createElement('div');
      taskGroup.className = 'control-group';
      const taskLabel = document.createElement('label');
      taskLabel.textContent = 'Task';
      taskLabel.setAttribute('for', 'variant-task-select');
      taskGroup.appendChild(taskLabel);
      const taskSelect = document.createElement('select');
      taskSelect.id = 'variant-task-select';
      taskGroup.appendChild(taskSelect);
      taskSelect.addEventListener('change', () => { activeTask = taskSelect.value; render(); });

      // Right group: Task + Model side by side
      const selectsGroup = document.createElement('div');
      selectsGroup.style.cssText = 'display:flex;gap:8px;align-items:flex-end;';
      selectsGroup.appendChild(taskGroup);

      controlsDiv.appendChild(tabGroup);
      controlsDiv.appendChild(selectsGroup);
      container.appendChild(controlsDiv);

      // Description
      const descDiv = document.createElement('div');
      descDiv.className = 'variant-desc';
      container.appendChild(descDiv);
      const descriptions = {
        S: 'CorrSteer-S selects only the single highest-correlation feature across ALL layers.',
        A: 'CorrSteer-A selects the top feature from EACH layer, forming a per-layer steering vector.',
        P: 'CorrSteer-P prunes low-correlation features from CorrSteer-A, keeping only those above the median.'
      };
      function updateDesc() { descDiv.textContent = descriptions[activeVariant]; }
      updateDesc();

      // Legend
      const legendDiv = document.createElement('div');
      legendDiv.className = 'legend';
      container.appendChild(legendDiv);

      function buildLegend() {
        legendDiv.innerHTML = '';
        const title = document.createElement('div');
        title.className = 'legend-title'; title.textContent = 'Legend';
        legendDiv.appendChild(title);
        const items = document.createElement('div');
        items.className = 'items';

        const primaryColor = PRIMARY();
        const entries = [
          { label: 'Selected feature', style: `background:${primaryColor}`, cls: 'swatch' },
          { label: 'Unselected feature', style: `background:${GREY()}`, cls: 'swatch' }
        ];
        if (activeVariant === 'A' || activeVariant === 'P') {
          entries.push({ label: 'Connection line', style: `background:${primaryColor}`, cls: 'swatch swatch--line' });
        }
        if (activeVariant === 'P') {
          entries.push({ label: 'Pruned feature', style: `border-color:${PRUNED_COLOR()}`, cls: 'swatch swatch--dashed' });
        }
        entries.forEach(e => {
          const el = document.createElement('span'); el.className = 'item';
          const sw = document.createElement('span'); sw.className = e.cls; sw.style.cssText = e.style;
          const txt = document.createElement('span'); txt.textContent = e.label;
          el.appendChild(sw); el.appendChild(txt); items.appendChild(el);
        });
        legendDiv.appendChild(items);
      }

      // Model selector (appended into rightGroup next to Task)
      const modelGroup = document.createElement('div');
      modelGroup.className = 'control-group';
      const modelLabel = document.createElement('label');
      modelLabel.textContent = 'Model';
      modelLabel.setAttribute('for', 'variant-model-select');
      modelGroup.appendChild(modelLabel);
      const modelSelect = document.createElement('select');
      modelSelect.id = 'variant-model-select';
      modelGroup.appendChild(modelSelect);
      selectsGroup.appendChild(modelGroup);

      let activeModel = 'gemma';
      let allModelData = {};

      modelSelect.addEventListener('change', () => {
        activeModel = modelSelect.value;
        rawData = allModelData[activeModel] || null;
        // Refresh task list
        if (rawData) {
          const tasks = Object.keys(rawData.tasks);
          taskSelect.innerHTML = '';
          tasks.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t; opt.textContent = t.toUpperCase();
            if (t === activeTask) opt.selected = true;
            taskSelect.appendChild(opt);
          });
          if (!tasks.includes(activeTask) && tasks.length > 0) {
            activeTask = tasks[0]; taskSelect.value = activeTask;
          }
        }
        render();
      });

      // Data loading
      const GEMMA_PATHS = [
        '/data/features_gemma_all.json',
        './assets/data/features_gemma_all.json',
        '../assets/data/features_gemma_all.json',
        '../../assets/data/features_gemma_all.json'
      ];
      const LLAMA_PATHS = [
        '/data/features_llama_all.json',
        './assets/data/features_llama_all.json',
        '../assets/data/features_llama_all.json',
        '../../assets/data/features_llama_all.json'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try { const r = await fetch(p, { cache: 'no-cache' }); if (r.ok) return await r.json(); } catch (_) { }
        }
        throw new Error('Data not found');
      };

      // Prepare flat data from raw: for each layer, get the top positive feature (highest correlation)
      function getTaskData(task) {
        if (!rawData || !rawData.tasks || !rawData.tasks[task]) return [];
        const taskObj = rawData.tasks[task];
        const layers = taskObj.layers;
        const result = [];
        for (const layerKey of Object.keys(layers).sort((a, b) => +a - +b)) {
          const pos = layers[layerKey].positive;
          if (!pos || pos.length === 0) continue;
          // All features for this layer
          pos.forEach(f => {
            result.push({
              layer: +layerKey,
              correlation: f.correlation,
              coefficient: f.coefficient,
              feature_index: f.feature_index,
              description: f.description || '',
              frequency: f.frequency,
              neuronpedia_url: f.neuronpedia_url || '',
              isTop: false
            });
          });
        }
        return result;
      }

      function computeSelection(allFeatures) {
        if (allFeatures.length === 0) return allFeatures;

        // For each layer, determine the top feature
        const layerMap = {};
        allFeatures.forEach(f => {
          if (!layerMap[f.layer] || f.correlation > layerMap[f.layer].correlation) {
            layerMap[f.layer] = f;
          }
        });

        // Mark isTop for per-layer tops
        allFeatures.forEach(f => {
          f.isTop = (layerMap[f.layer] && layerMap[f.layer].feature_index === f.feature_index && layerMap[f.layer].layer === f.layer);
        });

        if (activeVariant === 'S') {
          // Only the single best across all layers
          const globalBest = Object.values(layerMap).reduce((a, b) => a.correlation > b.correlation ? a : b);
          allFeatures.forEach(f => {
            f.state = (f.layer === globalBest.layer && f.feature_index === globalBest.feature_index) ? 'selected' : 'unselected';
          });
        } else if (activeVariant === 'A') {
          // Top per layer is selected
          allFeatures.forEach(f => {
            f.state = f.isTop ? 'selected' : 'unselected';
          });
        } else if (activeVariant === 'P') {
          // Like A, but prune features below median correlation among the per-layer tops
          const topCorrs = Object.values(layerMap).map(f => f.correlation).sort((a, b) => a - b);
          const medianCorr = topCorrs[Math.floor(topCorrs.length / 2)];
          allFeatures.forEach(f => {
            if (f.isTop) {
              f.state = f.correlation >= medianCorr ? 'selected' : 'pruned';
            } else {
              f.state = 'unselected';
            }
          });
        }
        return allFeatures;
      }

      function getConnectorData(allFeatures) {
        if (activeVariant === 'S') return [];
        const layerMap = {};
        allFeatures.forEach(f => {
          if (f.isTop && (f.state === 'selected' || f.state === 'pruned')) {
            layerMap[f.layer] = f;
          }
        });
        return Object.keys(layerMap).sort((a, b) => +a - +b).map(k => layerMap[k]);
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(300, Math.round(width / 2.6));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function render() {
        const { innerWidth, innerHeight } = updateSize();
        const primaryColor = PRIMARY();
        const greyColor = GREY();
        const prunedColor = PRUNED_COLOR();

        buildLegend();

        const allFeatures = getTaskData(activeTask);
        computeSelection(allFeatures);
        const connectorData = getConnectorData(allFeatures);

        // Scales
        const layers = [...new Set(allFeatures.map(f => f.layer))].sort((a, b) => a - b);
        const minLayer = layers.length > 0 ? layers[0] : 1;
        const maxLayer = layers.length > 0 ? layers[layers.length - 1] : 25;
        const maxCorr = d3.max(allFeatures, f => f.correlation) || 0.5;
        xScale.domain([minLayer - 0.5, maxLayer + 0.5]).range([0, innerWidth]);
        yScale.domain([0, maxCorr * 1.08]).range([innerHeight, 0]).nice();

        // Grid
        gGrid.selectAll('.grid-line-y').data(yScale.ticks(5)).join('line')
          .attr('class', 'grid-line-y')
          .attr('x1', 0).attr('x2', innerWidth)
          .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color, rgba(0,0,0,.08))')
          .attr('stroke-dasharray', '3,3');

        // Axes
        gAxes.selectAll('.x-axis').data([0]).join('g').attr('class', 'x-axis axes')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).ticks(Math.min(layers.length, 13)).tickFormat(d => Number.isInteger(d) ? d : ''));

        gAxes.selectAll('.y-axis').data([0]).join('g').attr('class', 'y-axis axes')
          .call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format('.2f')));

        // Axis labels
        gAxes.selectAll('.x-label').data([0]).join('text').attr('class', 'x-label axis-label')
          .attr('x', innerWidth / 2).attr('y', innerHeight + 40)
          .attr('text-anchor', 'middle').text('Layer');

        gAxes.selectAll('.y-label').data([0]).join('text').attr('class', 'y-label axis-label')
          .attr('transform', `translate(${-42}, ${innerHeight / 2}) rotate(-90)`)
          .attr('text-anchor', 'middle').text('Correlation');

        // Connector line for A and P
        const lineGen = d3.line()
          .x(d => xScale(d.layer))
          .y(d => yScale(d.correlation))
          .curve(d3.curveMonotoneX);

        gLine.selectAll('.connector-path')
          .data(connectorData.length > 1 ? [connectorData] : [])
          .join(
            enter => enter.append('path')
              .attr('class', 'connector-path')
              .attr('fill', 'none')
              .attr('stroke', primaryColor)
              .attr('stroke-width', 2)
              .attr('stroke-opacity', 0)
              .attr('d', lineGen)
              .call(e => e.transition().duration(500).attr('stroke-opacity', 0.5)),
            update => update
              .attr('stroke', primaryColor)
              .call(u => u.transition().duration(500).attr('d', lineGen).attr('stroke-opacity', 0.5)),
            exit => exit.call(x => x.transition().duration(300).attr('stroke-opacity', 0).remove())
          );

        // Dots
        const dots = gDots.selectAll('.feature-dot')
          .data(allFeatures, d => `${d.layer}-${d.feature_index}`);

        const dotSize = (d) => {
          if (d.state === 'selected') return activeVariant === 'S' ? 7 : 6;
          if (d.state === 'pruned') return 6;
          return 3.5;
        };

        const dotColor = (d) => {
          if (d.state === 'selected') return primaryColor;
          if (d.state === 'pruned') return 'transparent';
          return greyColor;
        };

        const dotStroke = (d) => {
          if (d.state === 'pruned') return prunedColor;
          return 'none';
        };

        const dotDash = (d) => {
          if (d.state === 'pruned') return '3,2';
          return 'none';
        };

        const dotOpacity = (d) => {
          if (d.state === 'selected') return 1;
          if (d.state === 'pruned') return 0.7;
          return 0.5;
        };

        dots.join(
          enter => enter.append('circle')
            .attr('class', 'feature-dot')
            .attr('cx', d => xScale(d.layer))
            .attr('cy', d => yScale(d.correlation))
            .attr('r', 0)
            .attr('fill', dotColor)
            .attr('stroke', dotStroke)
            .attr('stroke-dasharray', dotDash)
            .attr('stroke-width', d => d.state === 'pruned' ? 2 : 0)
            .attr('opacity', dotOpacity)
            .style('cursor', 'pointer')
            .on('mouseenter', function (evt, d) {
              const stateLabel = d.state === 'selected' ? 'Selected' : d.state === 'pruned' ? 'Pruned' : 'Unselected';
              showTip(evt, `
                <div style="font-weight:700;">Layer ${d.layer} - Feature #${d.feature_index}</div>
                <div style="font-size:11px;color:var(--muted-color);margin-top:2px;">${stateLabel}</div>
                <div style="margin-top:4px;">Correlation: <strong>${d.correlation.toFixed(4)}</strong></div>
                <div>Coefficient: ${d.coefficient.toFixed(4)}</div>
                <div>Frequency: ${d.frequency.toFixed(1)}%</div>
                <div style="font-size:11px;margin-top:3px;color:var(--muted-color);">${d.description}</div>
              `);
              d3.select(this)
                .transition().duration(150)
                .attr('r', dotSize(d) * 1.5)
                .style('filter', 'drop-shadow(0 0 4px ' + primaryColor + ')')
                .attr('opacity', 1);
              gDots.selectAll('.feature-dot')
                .filter(dd => dd.layer === d.layer && dd !== d)
                .transition().duration(150)
                .attr('opacity', dd => Math.min(1, dotOpacity(dd) + 0.3));
            })
            .on('mouseleave', function (evt, d) {
              hideTip();
              d3.select(this)
                .transition().duration(200)
                .attr('r', dotSize(d))
                .style('filter', 'none')
                .attr('opacity', dotOpacity(d));
              gDots.selectAll('.feature-dot')
                .filter(dd => dd.layer === d.layer && dd !== d)
                .transition().duration(200)
                .attr('opacity', dotOpacity);
            })
            .on('click', function (evt, d) {
              if (d.neuronpedia_url) window.open(d.neuronpedia_url, '_blank');
            })
            .call(enter => enter.transition().duration(500)
              .attr('r', dotSize)
            ),
          update => update
            .on('mouseenter', function (evt, d) {
              const stateLabel = d.state === 'selected' ? 'Selected' : d.state === 'pruned' ? 'Pruned' : 'Unselected';
              showTip(evt, `
                <div style="font-weight:700;">Layer ${d.layer} - Feature #${d.feature_index}</div>
                <div style="font-size:11px;color:var(--muted-color);margin-top:2px;">${stateLabel}</div>
                <div style="margin-top:4px;">Correlation: <strong>${d.correlation.toFixed(4)}</strong></div>
                <div>Coefficient: ${d.coefficient.toFixed(4)}</div>
                <div>Frequency: ${d.frequency.toFixed(1)}%</div>
                <div style="font-size:11px;margin-top:3px;color:var(--muted-color);">${d.description}</div>
              `);
              d3.select(this)
                .transition().duration(150)
                .attr('r', dotSize(d) * 1.5)
                .style('filter', 'drop-shadow(0 0 4px ' + primaryColor + ')')
                .attr('opacity', 1);
              gDots.selectAll('.feature-dot')
                .filter(dd => dd.layer === d.layer && dd !== d)
                .transition().duration(150)
                .attr('opacity', dd => Math.min(1, dotOpacity(dd) + 0.3));
            })
            .on('mouseleave', function (evt, d) {
              hideTip();
              d3.select(this)
                .transition().duration(200)
                .attr('r', dotSize(d))
                .style('filter', 'none')
                .attr('opacity', dotOpacity(d));
              gDots.selectAll('.feature-dot')
                .filter(dd => dd.layer === d.layer && dd !== d)
                .transition().duration(200)
                .attr('opacity', dotOpacity);
            })
            .on('click', function (evt, d) {
              if (d.neuronpedia_url) window.open(d.neuronpedia_url, '_blank');
            })
            .style('cursor', 'pointer')
            .call(update => update.transition().duration(500)
              .attr('cx', d => xScale(d.layer))
              .attr('cy', d => yScale(d.correlation))
              .attr('r', dotSize)
              .attr('fill', dotColor)
              .attr('stroke', dotStroke)
              .attr('stroke-dasharray', dotDash)
              .attr('stroke-width', d => d.state === 'pruned' ? 2 : 0)
              .attr('opacity', dotOpacity)
            ),
          exit => exit.transition().duration(300).attr('r', 0).remove()
        );

        // Bring selected dots to front
        gDots.selectAll('.feature-dot')
          .sort((a, b) => {
            const order = { unselected: 0, pruned: 1, selected: 2 };
            return (order[a.state] || 0) - (order[b.state] || 0);
          });
      }

      // Load data for both models
      Promise.all([
        fetchFirstAvailable(GEMMA_PATHS).catch(() => null),
        fetchFirstAvailable(LLAMA_PATHS).catch(() => null)
      ]).then(([gemmaData, llamaData]) => {
          if (gemmaData) allModelData.gemma = gemmaData;
          if (llamaData) allModelData.llama = llamaData;

          // Populate model selector
          modelSelect.innerHTML = '';
          const models = [];
          if (gemmaData) models.push({ key: 'gemma', label: gemmaData.model || 'Gemma 2B' });
          if (llamaData) models.push({ key: 'llama', label: llamaData.model || 'Llama 3.1 8B' });
          if (models.length === 0) throw new Error('No data');
          models.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m.key; opt.textContent = m.label;
            modelSelect.appendChild(opt);
          });
          if (models.length <= 1) modelGroup.style.display = 'none';
          activeModel = models[0].key;
          modelSelect.value = activeModel;
          rawData = allModelData[activeModel];

          // Populate task dropdown
          const tasks = Object.keys(rawData.tasks);
          taskSelect.innerHTML = '';
          tasks.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t; opt.textContent = t.toUpperCase();
            if (t === activeTask) opt.selected = true;
            taskSelect.appendChild(opt);
          });
          if (!tasks.includes(activeTask) && tasks.length > 0) {
            activeTask = tasks[0]; taskSelect.value = activeTask;
          }
          render();

          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Failed to load feature data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Toggle between S (single global feature), A (one per layer), and P (pruned via validation) to see which features are selected across layers.</figcaption></figure> </div>
<ul>
<li><strong>CorrSteer-S</strong>: The single most positively correlated feature across all layers. Simplest possible steering.</li>
<li><strong>CorrSteer-A</strong>: The top feature from each layer. Multi-layer steering captures distributed representations.</li>
<li><strong>CorrSteer-P</strong>: CorrSteer-A with validation-based pruning. Each feature is tested individually; only features that improve performance when amplified are retained. This identifies a minimal “steering subcircuit.”</li>
</ul>
<h3 id="feature-activation-frequencies"><a href="#feature-activation-frequencies">Feature Activation Frequencies</a></h3>
<p>How often do the selected features actually fire? The frequency distribution across layers reveals where the model’s most active steering features live, and how they differ between tasks.</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Feature Activation Frequency Distribution</figcaption><div class="html-embed__card"><div id="frag-z5wt9v2rov" data-datafiles="features_gemma_all.json,features_llama_all.json"><div class="feature-frequency"></div>
<style>
  .feature-frequency {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
  }

  .feature-frequency .ff-loading {
    text-align: center;
    padding: 60px 20px;
    font-size: 14px;
  }

  .feature-frequency .ff-spinner {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 2px solid var(--border-color, #d2d2d7);
    border-top-color: var(--primary-color, #6B5CE7);
    border-radius: 50%;
    animation: ff-spin 0.7s linear infinite;
    margin-bottom: 12px;
  }

  @keyframes ff-spin {
    to { transform: rotate(360deg); }
  }

  /* Controls bar */
  .feature-frequency .ff-controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    flex-wrap: wrap;
    margin-bottom: 16px;
  }

  .feature-frequency .ff-control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .feature-frequency .ff-control-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Model toggle */
  .feature-frequency .ff-model-tabs {
    display: inline-flex;
    border-radius: 8px;
    padding: 2px;
    border: 1px solid var(--border-color, #d2d2d7);
    gap: 0;
  }

  .feature-frequency .ff-model-btn {
    padding: 5px 14px;
    font-size: 12px;
    font-weight: 600;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease;
    white-space: nowrap;
    font-family: inherit;
  }

  .feature-frequency .ff-model-btn.active {
    background: var(--primary-color, #6B5CE7);
    color: #fff;
    box-shadow: 0 1px 4px rgba(107,92,231,0.3);
  }

  /* Task checkboxes */
  .feature-frequency .ff-task-checks {
    display: flex;
    flex-wrap: wrap;
    gap: 4px 10px;
    align-items: center;
  }

  .feature-frequency .ff-task-check {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    cursor: pointer;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .feature-frequency .ff-task-check input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 2px solid currentColor;
    cursor: pointer;
    position: relative;
    flex-shrink: 0;
  }

  .feature-frequency .ff-task-check input[type="checkbox"]:checked {
    background: currentColor;
  }

  .feature-frequency .ff-task-check input[type="checkbox"]:checked::after {
    content: '';
    position: absolute;
    left: 1.5px;
    top: -0.5px;
    width: 5px;
    height: 8px;
    border: solid #fff;
    border-width: 0 1.5px 1.5px 0;
    transform: rotate(45deg);
  }

  /* Chart container */
  .feature-frequency .ff-chart {
    position: relative;
    width: 100%;
  }

  .feature-frequency .ff-chart svg {
    display: block;
    width: 100%;
  }

  /* Tooltip */
  .feature-frequency .ff-tooltip {
    position: absolute;
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.4;
    border: 1px solid var(--border-color, #d2d2d7);
    background: var(--surface-bg, #ffffff);
    color: var(--text-color, #1d1d1f);
    box-shadow: 0 4px 24px rgba(0,0,0,0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 10;
    max-width: 280px;
    transform: translate(-9999px, -9999px);
  }

  .feature-frequency .ff-tooltip .tt-task {
    display: inline-block;
    padding: 1px 6px;
    border-radius: 4px;
    font-weight: 700;
    font-size: 11px;
    color: #fff;
    margin-bottom: 4px;
  }

  .feature-frequency .ff-tooltip .tt-desc {
    font-style: italic;
    margin-top: 4px;
  }

  .feature-frequency .ff-tooltip .tt-row {
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }

  .feature-frequency .ff-tooltip .tt-label {
    font-weight: 400;
  }

  .feature-frequency .ff-tooltip .tt-value {
    font-weight: 700;
    font-variant-numeric: tabular-nums;
  }

  /* Summary bar */
  .feature-frequency .ff-summary {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    padding: 8px 0 0;
    font-size: 12px;
  }

  .feature-frequency .ff-summary strong {
    font-weight: 700;
  }

  /* Legend */
  .feature-frequency .ff-legend {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    padding-top: 4px;
    font-size: 11px;
  }

  .feature-frequency .ff-legend-item {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .feature-frequency .ff-legend-dot-filled {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #888;
  }

  .feature-frequency .ff-legend-dot-ring {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 1.5px solid #888;
    background: transparent;
    box-sizing: border-box;
  }

  /* Error state */
  .feature-frequency .ff-error {
    text-align: center;
    padding: 40px 20px;
    color: #e15759;
    font-size: 14px;
  }

  @media (max-width: 600px) {
    .feature-frequency .ff-controls {
      gap: 10px;
    }
    .feature-frequency .ff-task-checks {
      gap: 2px 8px;
    }
  }
</style>
<script>
(() => {
  // Prevent multiple initializations
  if (window.__ffFreqInit) return;
  window.__ffFreqInit = true;

  const ensureD3 = (cb) => {
    if (window.d3 && typeof window.d3.select === 'function') return cb();
    let s = document.getElementById('d3-cdn-script');
    if (!s) {
      s = document.createElement('script');
      s.id = 'd3-cdn-script';
      s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
      document.head.appendChild(s);
    }
    const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
    s.addEventListener('load', onReady, { once: true });
    if (window.d3) onReady();
  };

  const bootstrap = () => {
    const scriptEl = document.currentScript;
    let container = scriptEl ? scriptEl.previousElementSibling : null;
    if (!(container && container.classList && container.classList.contains('feature-frequency'))) {
      const cs = Array.from(document.querySelectorAll('.feature-frequency'))
        .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
      container = cs[cs.length - 1] || null;
    }
    if (!container) return;
    if (container.dataset) {
      if (container.dataset.mounted === 'true') return;
      container.dataset.mounted = 'true';
    }

    const d3 = window.d3;

    // Show loading
    container.innerHTML = '<div class="ff-loading"><div class="ff-spinner"></div><div>Loading feature data...</div></div>';

    // ---- Constants ----
    const TASK_COLORS = {
      mmlu: '#4e79a7', mmlupro: '#59a14f', simpleqa: '#f28e2b',
      bbq_ambig: '#e15759', bbq_disambig: '#76b7b2',
      harmbench: '#ff9da7', xstest: '#edc948', gsm8k: '#b07aa1'
    };

    const TASK_LABELS = {
      mmlu: 'MMLU', mmlupro: 'MMLU-Pro', simpleqa: 'SimpleQA',
      bbq_ambig: 'BBQ (Ambig)', bbq_disambig: 'BBQ (Disambig)',
      harmbench: 'HarmBench', xstest: 'XSTest', gsm8k: 'GSM8K'
    };

    const DATA_PATHS = {
      gemma: [
        '/data/features_gemma_all.json',
        './assets/data/features_gemma_all.json',
        '../assets/data/features_gemma_all.json',
        '../../assets/data/features_gemma_all.json'
      ],
      llama: [
        '/data/features_llama_all.json',
        './assets/data/features_llama_all.json',
        '../assets/data/features_llama_all.json',
        '../../assets/data/features_llama_all.json'
      ]
    };

    // ---- Theme detection ----
    const isDark = () => document.documentElement.getAttribute('data-theme') === 'dark';
    const palette = () => isDark()
      ? { text: '#e0e0e0', axis: '#888', grid: '#333', muted: 'rgba(255,255,255,0.5)', tooltipBg: '#1a1d28', tooltipBorder: 'rgba(255,255,255,0.12)' }
      : { text: '#333', axis: '#666', grid: '#eee', muted: 'rgba(0,0,0,0.45)', tooltipBg: '#fff', tooltipBorder: '#d2d2d7' };

    // ---- State ----
    let state = {
      model: 'gemma',
      activeTasks: new Set(['harmbench'])
    };
    let dataCache = {};

    // ---- Data loading ----
    async function fetchJSON(paths) {
      for (const p of paths) {
        try {
          const r = await fetch(p, { cache: 'no-cache' });
          if (r.ok) return await r.json();
        } catch (e) { /* try next */ }
      }
      return null;
    }

    async function loadModel(key) {
      if (dataCache[key]) return dataCache[key];
      const data = await fetchJSON(DATA_PATHS[key]);
      if (data) dataCache[key] = data;
      return data;
    }

    // ---- Extract all features into flat array ----
    function extractFeatures(data) {
      if (!data || !data.tasks) return [];
      const features = [];
      const availableTasks = Object.keys(data.tasks);

      for (const taskKey of availableTasks) {
        if (!state.activeTasks.has(taskKey)) continue;
        const taskData = data.tasks[taskKey];
        if (!taskData.layers) continue;

        for (const [layerKey, layerData] of Object.entries(taskData.layers)) {
          const layer = parseInt(layerKey);

          // Positive features
          if (layerData.positive) {
            for (const feat of layerData.positive) {
              features.push({
                ...feat,
                task: taskKey,
                layer,
                polarity: 'positive'
              });
            }
          }

          // Negative features
          if (layerData.negative) {
            for (const feat of layerData.negative) {
              features.push({
                ...feat,
                task: taskKey,
                layer,
                polarity: 'negative'
              });
            }
          }
        }
      }
      return features;
    }

    // ---- Compute summary stats ----
    function computeSummary(features) {
      if (features.length === 0) return { count: 0, avgFreq: 0, mostActiveLayer: '-' };
      const avgFreq = d3.mean(features, d => d.frequency) || 0;
      const layerCounts = d3.rollup(features, v => v.length, d => d.layer);
      let maxCount = 0, mostActiveLayer = '-';
      for (const [layer, count] of layerCounts) {
        if (count > maxCount) { maxCount = count; mostActiveLayer = layer; }
      }
      return { count: features.length, avgFreq, mostActiveLayer };
    }

    // ---- Build UI ----
    let svg, gRoot, gDots, gXAxis, gYAxis, gGrid, tooltip;
    let chartDiv, summaryDiv;
    const margin = { top: 16, right: 20, bottom: 44, left: 56 };
    let width = 800, innerWidth, innerHeight;
    const chartHeight = 350;

    function buildUI() {
      container.innerHTML = '';
      const p = palette();

      // Controls bar
      const controls = document.createElement('div');
      controls.className = 'ff-controls';

      // Model toggle
      const modelGroup = document.createElement('div');
      modelGroup.className = 'ff-control-group';
      const modelLabel = document.createElement('div');
      modelLabel.className = 'ff-control-label';
      modelLabel.textContent = 'Model';
      modelLabel.style.color = p.muted;
      modelGroup.appendChild(modelLabel);

      const modelTabs = document.createElement('div');
      modelTabs.className = 'ff-model-tabs';

      ['gemma', 'llama'].forEach(m => {
        const btn = document.createElement('button');
        btn.className = 'ff-model-btn' + (state.model === m ? ' active' : '');
        btn.textContent = m === 'gemma' ? 'Gemma-2 2B' : 'LLaMA-3.1 8B';
        btn.style.color = state.model === m ? '#fff' : p.text;
        btn.dataset.model = m;
        btn.addEventListener('click', () => {
          state.model = m;
          modelTabs.querySelectorAll('.ff-model-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.model === m);
            b.style.color = b.dataset.model === m ? '#fff' : palette().text;
          });
          render();
        });
        modelTabs.appendChild(btn);
      });
      modelGroup.appendChild(modelTabs);
      controls.appendChild(modelGroup);

      // Task checkboxes
      const taskGroup = document.createElement('div');
      taskGroup.className = 'ff-control-group';
      const taskLabel = document.createElement('div');
      taskLabel.className = 'ff-control-label';
      taskLabel.textContent = 'Tasks';
      taskLabel.style.color = p.muted;
      taskGroup.appendChild(taskLabel);

      const taskChecks = document.createElement('div');
      taskChecks.className = 'ff-task-checks';

      Object.keys(TASK_COLORS).forEach(t => {
        const label = document.createElement('label');
        label.className = 'ff-task-check';
        label.style.color = TASK_COLORS[t];

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = state.activeTasks.has(t);
        cb.addEventListener('change', () => {
          if (cb.checked) state.activeTasks.add(t);
          else state.activeTasks.delete(t);
          render();
        });

        const span = document.createElement('span');
        span.textContent = TASK_LABELS[t];

        label.appendChild(cb);
        label.appendChild(span);
        taskChecks.appendChild(label);
      });

      taskGroup.appendChild(taskChecks);
      controls.appendChild(taskGroup);
      container.appendChild(controls);

      // Chart container
      chartDiv = document.createElement('div');
      chartDiv.className = 'ff-chart';
      container.appendChild(chartDiv);

      // Create SVG
      svg = d3.select(chartDiv).append('svg').attr('height', chartHeight);
      gRoot = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
      gGrid = gRoot.append('g').attr('class', 'ff-grid');
      gXAxis = gRoot.append('g').attr('class', 'ff-x-axis');
      gYAxis = gRoot.append('g').attr('class', 'ff-y-axis');
      gDots = gRoot.append('g').attr('class', 'ff-dots');

      // X axis label
      gRoot.append('text')
        .attr('class', 'ff-x-label')
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('font-weight', '600')
        .text('Layer');

      // Y axis label
      gRoot.append('text')
        .attr('class', 'ff-y-label')
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('font-weight', '600')
        .text('Feature Activation Frequency (%)');

      // Tooltip
      tooltip = document.createElement('div');
      tooltip.className = 'ff-tooltip';
      chartDiv.appendChild(tooltip);

      // Legend
      const legendDiv = document.createElement('div');
      legendDiv.className = 'ff-legend';
      legendDiv.style.color = p.muted;

      const filledItem = document.createElement('span');
      filledItem.className = 'ff-legend-item';
      filledItem.innerHTML = '<span class="ff-legend-dot-filled"></span> Positive';
      legendDiv.appendChild(filledItem);

      const ringItem = document.createElement('span');
      ringItem.className = 'ff-legend-item';
      ringItem.innerHTML = '<span class="ff-legend-dot-ring"></span> Negative';
      legendDiv.appendChild(ringItem);

      const sizeItem = document.createElement('span');
      sizeItem.className = 'ff-legend-item';
      sizeItem.textContent = 'Dot size = |correlation|';
      legendDiv.appendChild(sizeItem);

      container.appendChild(legendDiv);

      // Summary
      summaryDiv = document.createElement('div');
      summaryDiv.className = 'ff-summary';
      container.appendChild(summaryDiv);
    }

    // ---- Render chart ----
    function render() {
      if (!svg) return;
      const data = dataCache[state.model];
      if (!data) return;

      const p = palette();
      const features = extractFeatures(data);
      const summary = computeSummary(features);

      // Update summary
      summaryDiv.style.color = p.muted;
      summaryDiv.innerHTML = `
        <span><strong style="color:${p.text}">${summary.count}</strong> features shown</span>
        <span>Avg frequency: <strong style="color:${p.text}">${summary.avgFreq.toFixed(1)}%</strong></span>
        <span>Most active layer: <strong style="color:${p.text}">${summary.mostActiveLayer}</strong></span>
      `;

      // Update theme colors on controls
      container.querySelectorAll('.ff-control-label').forEach(el => el.style.color = p.muted);
      container.querySelectorAll('.ff-model-btn').forEach(btn => {
        if (!btn.classList.contains('active')) btn.style.color = p.text;
      });
      container.querySelector('.ff-legend').style.color = p.muted;

      // Dimensions
      width = chartDiv.clientWidth || 800;
      innerWidth = width - margin.left - margin.right;
      innerHeight = chartHeight - margin.top - margin.bottom;

      svg.attr('width', width);

      // Determine layer range from data
      const allLayers = [];
      const tasksData = data.tasks;
      for (const taskKey of Object.keys(tasksData)) {
        const layers = tasksData[taskKey].layers;
        if (layers) {
          for (const k of Object.keys(layers)) allLayers.push(parseInt(k));
        }
      }
      const layerExtent = d3.extent(allLayers);
      const layerDomain = d3.range(layerExtent[0], layerExtent[1] + 1);

      // Scales
      const xScale = d3.scaleLinear()
        .domain([layerExtent[0] - 0.5, layerExtent[1] + 0.5])
        .range([0, innerWidth]);

      const freqMax = features.length > 0 ? d3.max(features, d => d.frequency) : 100;
      const yScale = d3.scaleLinear()
        .domain([0, Math.min(105, (freqMax || 100) * 1.05)])
        .range([innerHeight, 0])
        .nice();

      const corrExtent = features.length > 0
        ? d3.extent(features, d => Math.abs(d.correlation))
        : [0, 1];
      const rScale = d3.scaleSqrt()
        .domain([0, Math.max(corrExtent[1], 0.01)])
        .range([2, 8]);

      // Grid lines
      const yTicks = yScale.ticks(6);
      gGrid.selectAll('.ff-grid-line')
        .data(yTicks, d => d)
        .join('line')
        .attr('class', 'ff-grid-line')
        .attr('x1', 0)
        .attr('x2', innerWidth)
        .attr('y1', d => yScale(d))
        .attr('y2', d => yScale(d))
        .attr('stroke', p.grid)
        .attr('stroke-width', 1);

      // X axis
      const xTickValues = layerDomain.filter((d, i) => {
        if (layerDomain.length <= 16) return true;
        return d % 2 === 1 || d === layerDomain[layerDomain.length - 1];
      });
      const xAxis = d3.axisBottom(xScale)
        .tickValues(xTickValues)
        .tickFormat(d => d)
        .tickSize(4);

      gXAxis
        .attr('transform', `translate(0, ${innerHeight})`)
        .call(xAxis);

      gXAxis.select('.domain').attr('stroke', p.axis);
      gXAxis.selectAll('line').attr('stroke', p.axis);
      gXAxis.selectAll('text')
        .style('fill', p.axis)
        .style('font-size', '11px');

      // Y axis
      const yAxis = d3.axisLeft(yScale)
        .ticks(6)
        .tickSize(4);

      gYAxis.call(yAxis);
      gYAxis.select('.domain').attr('stroke', p.axis);
      gYAxis.selectAll('line').attr('stroke', p.axis);
      gYAxis.selectAll('text')
        .style('fill', p.axis)
        .style('font-size', '11px');

      // Axis labels
      gRoot.select('.ff-x-label')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 36)
        .style('fill', p.text);

      gRoot.select('.ff-y-label')
        .attr('transform', `translate(${-40}, ${innerHeight / 2}) rotate(-90)`)
        .style('fill', p.text);

      // Jitter: use a seeded pseudo-random based on feature index + layer + task
      function jitter(feat) {
        const seed = feat.feature_index * 13 + feat.layer * 7 + feat.task.charCodeAt(0) * 3;
        const pseudo = Math.sin(seed) * 10000;
        return (pseudo - Math.floor(pseudo) - 0.5) * 0.6;  // range [-0.3, +0.3] layers
      }

      // Jitter on Y axis too (small amount to separate overlapping frequencies)
      function jitterY(feat) {
        const seed = feat.feature_index * 17 + feat.layer * 11 + feat.task.charCodeAt(1) * 5;
        const pseudo = Math.sin(seed) * 10000;
        const freqRange = yScale.domain()[1] - yScale.domain()[0];
        return (pseudo - Math.floor(pseudo) - 0.5) * freqRange * 0.015;
      }

      // Dots
      const dots = gDots.selectAll('.ff-dot')
        .data(features, d => `${d.task}-${d.layer}-${d.feature_index}-${d.polarity}`);

      dots.join(
        enter => enter.append('circle')
          .attr('class', 'ff-dot')
          .attr('cx', d => xScale(d.layer + jitter(d)))
          .attr('cy', d => yScale(d.frequency + jitterY(d)))
          .attr('r', 0)
          .attr('fill', d => d.polarity === 'positive' ? TASK_COLORS[d.task] : 'transparent')
          .attr('stroke', d => TASK_COLORS[d.task])
          .attr('stroke-width', d => d.polarity === 'positive' ? 0.5 : 1.8)
          .attr('opacity', 0.7)
          .style('cursor', 'pointer')
          .call(enter => enter.transition().duration(400)
            .attr('r', d => rScale(Math.abs(d.correlation))))
          .on('mouseenter', handleMouseEnter)
          .on('mousemove', handleMouseMove)
          .on('mouseleave', handleMouseLeave),
        update => update
          .call(update => update.transition().duration(400)
            .attr('cx', d => xScale(d.layer + jitter(d)))
            .attr('cy', d => yScale(d.frequency + jitterY(d)))
            .attr('r', d => rScale(Math.abs(d.correlation)))
            .attr('fill', d => d.polarity === 'positive' ? TASK_COLORS[d.task] : 'transparent')
            .attr('stroke', d => TASK_COLORS[d.task])
            .attr('stroke-width', d => d.polarity === 'positive' ? 0.5 : 1.8)
            .attr('opacity', 0.7)),
        exit => exit.transition().duration(300)
          .attr('r', 0)
          .attr('opacity', 0)
          .remove()
      );
    }

    // ---- Tooltip handlers ----
    function handleMouseEnter(evt, d) {
      const p = palette();
      d3.select(this)
        .transition().duration(150)
        .attr('opacity', 1)
        .attr('r', function() {
          const corrExtent = [0, 0.5];
          return d3.scaleSqrt().domain(corrExtent).range([2, 8])(Math.abs(d.correlation)) + 3;
        });

      const taskColor = TASK_COLORS[d.task];
      tooltip.innerHTML = `
        <div class="tt-task" style="background:${taskColor}">${TASK_LABELS[d.task]}</div>
        <div style="margin-top:2px;font-weight:600;">Layer ${d.layer} &middot; #${d.feature_index} &middot; ${d.polarity === 'positive' ? 'Positive' : 'Negative'}</div>
        <div class="tt-row"><span class="tt-label">Frequency</span><span class="tt-value">${d.frequency.toFixed(1)}%</span></div>
        <div class="tt-row"><span class="tt-label">Correlation</span><span class="tt-value">${d.correlation.toFixed(4)}</span></div>
        <div class="tt-row"><span class="tt-label">Coefficient</span><span class="tt-value">${d.coefficient.toFixed(4)}</span></div>
        ${d.description ? `<div class="tt-desc">${d.description}</div>` : ''}
      `;
      tooltip.style.opacity = '1';
      tooltip.style.background = p.tooltipBg;
      tooltip.style.borderColor = p.tooltipBorder;
      tooltip.style.color = p.text;
      positionTooltip(evt);
    }

    function handleMouseMove(evt) {
      positionTooltip(evt);
    }

    function handleMouseLeave(evt, d) {
      const corrExtent = dataCache[state.model]
        ? d3.extent(extractFeatures(dataCache[state.model]), f => Math.abs(f.correlation))
        : [0, 0.5];
      const rScale = d3.scaleSqrt()
        .domain([0, Math.max(corrExtent[1], 0.01)])
        .range([2, 8]);

      d3.select(this)
        .transition().duration(150)
        .attr('opacity', 0.7)
        .attr('r', rScale(Math.abs(d.correlation)));

      tooltip.style.opacity = '0';
      setTimeout(() => { tooltip.style.transform = 'translate(-9999px, -9999px)'; }, 120);
    }

    function positionTooltip(evt) {
      const pt = d3.pointer(evt, chartDiv);
      const tipW = tooltip.offsetWidth || 200;
      const tipH = tooltip.offsetHeight || 80;
      const cW = chartDiv.clientWidth;
      let x = pt[0] + 14, y = pt[1] - tipH - 8;
      if (x + tipW > cW) x = pt[0] - tipW - 14;
      if (y < 0) y = pt[1] + 16;
      tooltip.style.transform = `translate(${x}px, ${y}px)`;
    }

    // ---- Initialize ----
    async function init() {
      const [gemmaData, llamaData] = await Promise.all([
        loadModel('gemma'),
        loadModel('llama')
      ]);

      if (!gemmaData && !llamaData) {
        container.innerHTML = '<div class="ff-error">Failed to load feature data. Ensure the JSON files are available.</div>';
        return;
      }

      // If gemma not available, default to llama
      if (!gemmaData && llamaData) {
        state.model = 'llama';
      }

      // Adjust active tasks based on available data
      const currentData = dataCache[state.model];
      if (currentData) {
        const availableTasks = new Set(Object.keys(currentData.tasks));
        state.activeTasks = new Set([...state.activeTasks].filter(t => availableTasks.has(t)));
      }

      buildUI();
      render();

      // Resize observer
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => render());
        ro.observe(container);
      } else {
        window.addEventListener('resize', render);
      }

      // Theme observer
      const mo = new MutationObserver((muts) => {
        for (const m of muts) {
          if (m.attributeName === 'data-theme') {
            render();
            break;
          }
        }
      });
      mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
    }

    ensureD3(init);
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
  } else {
    bootstrap();
  }
})();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Each dot is a feature. X = layer, Y = activation frequency. Filled dots are positively correlated; rings are negatively correlated. Size encodes correlation strength.</figcaption></figure> </div>
<p>High-frequency features fire on many inputs and represent broad patterns (e.g., formatting, punctuation), while low-frequency features are highly specific (e.g., particular mathematical operations, refusal phrases). The distribution shifts across layers: early layers tend to have high-frequency syntactic features, while deeper layers surface task-specific semantic features with lower but more discriminative activation rates.</p>
<h2 id="exploring-the-feature-space"><a href="#exploring-the-feature-space">Exploring the Feature Space</a></h2>
<p>What do the selected features look like? Each SAE feature has a human-readable description from Neuronpedia, allowing us to inspect <em>what the model is doing differently</em> when steered.</p>
<div class="full-width"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-pbedbjclw0b" data-datafiles="features_gemma_all.json,features_llama_all.json"><!--
  3D SAE Feature Space Explorer

  Interactive Three.js scatter plot of SAE features from CorrSteer analysis.
  Each point is a sparse autoencoder feature. Axes: Layer x Correlation x Coefficient.
  Color encodes task, size encodes activation frequency.

  Data: features_gemma_all.json, features_llama_all.json

  Usage in MDX:
  <HtmlEmbed
    src="feature-space-3d.html"
    title="3D SAE Feature Atlas"
    data="features_gemma_all.json,features_llama_all.json"
  />
-->
<div class="feature-space-3d"></div>
<style>
  .feature-space-3d {
    position: relative;
    width: 100%;
    height: 550px;
    overflow: hidden;
    border-radius: 8px;
    background: #0a0a14;
    user-select: none;
    -webkit-user-select: none;
  }
  .feature-space-3d canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    border-radius: 8px;
  }

  /* ---- Controls panel ---- */
  .fs3d-controls {
    position: absolute;
    top: 12px;
    left: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
    pointer-events: none;
  }
  .fs3d-controls > * {
    pointer-events: auto;
  }
  .fs3d-panel {
    background: rgba(10, 10, 20, 0.88);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 10px 14px;
    color: #ccc;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 11px;
    line-height: 1.5;
  }
  .fs3d-panel-title {
    font-weight: 600;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: rgba(255,255,255,0.45);
    margin-bottom: 6px;
  }

  /* Model toggle */
  .fs3d-model-toggle {
    display: flex;
    gap: 2px;
    background: rgba(255,255,255,0.06);
    border-radius: 6px;
    padding: 2px;
  }
  .fs3d-model-btn {
    flex: 1;
    padding: 5px 10px;
    border: none;
    border-radius: 5px;
    background: transparent;
    color: rgba(255,255,255,0.5);
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.25s ease;
    font-family: inherit;
    white-space: nowrap;
  }
  .fs3d-model-btn.active {
    background: rgba(107, 92, 231, 0.6);
    color: #fff;
    box-shadow: 0 2px 8px rgba(107, 92, 231, 0.3);
  }
  .fs3d-model-btn:hover:not(.active) {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.7);
  }

  /* Task checkboxes */
  .fs3d-tasks {
    display: flex;
    flex-direction: column;
    gap: 3px;
  }
  .fs3d-task-row {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    padding: 1px 0;
    transition: opacity 0.2s;
  }
  .fs3d-task-row:hover {
    opacity: 0.85;
  }
  .fs3d-task-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
  }
  .fs3d-task-row input[type="checkbox"] {
    display: none;
  }
  .fs3d-task-label {
    font-size: 11px;
    color: #bbb;
    transition: color 0.2s;
  }
  .fs3d-task-row.unchecked .fs3d-task-dot {
    opacity: 0.2;
    box-shadow: none;
  }
  .fs3d-task-row.unchecked .fs3d-task-label {
    color: #555;
    text-decoration: line-through;
    text-decoration-color: rgba(255,255,255,0.15);
  }

  /* Buttons row */
  .fs3d-btn-row {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }
  .fs3d-btn {
    padding: 5px 10px;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 5px;
    background: rgba(255,255,255,0.04);
    color: #999;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }
  .fs3d-btn:hover {
    background: rgba(255,255,255,0.1);
    color: #ddd;
    border-color: rgba(255,255,255,0.2);
  }
  .fs3d-btn.active {
    background: rgba(107, 92, 231, 0.35);
    color: #ddd;
    border-color: rgba(107, 92, 231, 0.5);
  }

  /* View presets */
  .fs3d-views {
    display: flex;
    gap: 3px;
  }
  .fs3d-view-btn {
    padding: 4px 8px;
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 4px;
    background: rgba(255,255,255,0.03);
    color: #777;
    font-size: 9px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }
  .fs3d-view-btn:hover {
    background: rgba(255,255,255,0.08);
    color: #ccc;
    border-color: rgba(255,255,255,0.15);
  }

  /* Interaction hint */
  .fs3d-hint {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 15;
    background: rgba(10, 10, 20, 0.85);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    padding: 8px 20px;
    color: rgba(255,255,255,0.5);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 11px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 1;
    transition: opacity 0.8s ease;
  }
  .fs3d-hint.hidden {
    opacity: 0;
  }
  .fs3d-hint kbd {
    display: inline-block;
    padding: 1px 5px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 3px;
    background: rgba(255,255,255,0.06);
    font-family: inherit;
    font-size: 10px;
    color: rgba(255,255,255,0.6);
    margin: 0 2px;
  }

  /* Stats badge */
  .fs3d-stats {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
  }
  .fs3d-stats-inner {
    background: rgba(10, 10, 20, 0.82);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    padding: 8px 12px;
    color: rgba(255,255,255,0.5);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 10px;
    text-align: right;
    line-height: 1.6;
  }
  .fs3d-stats-count {
    font-size: 16px;
    font-weight: 700;
    color: rgba(255,255,255,0.85);
    font-variant-numeric: tabular-nums;
  }

  /* Axis labels */
  .fs3d-axis-label {
    position: absolute;
    z-index: 5;
    color: rgba(255,255,255,0.35);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 11px;
    font-weight: 500;
    letter-spacing: 0.04em;
    pointer-events: none;
    text-transform: uppercase;
  }
  .fs3d-axis-x {
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
  }
  .fs3d-axis-y {
    left: 50%;
    bottom: 36px;
    transform: translateX(-50%) rotate(0deg);
  }
  .fs3d-axis-z {
    right: 60px;
    bottom: 16px;
  }

  /* Tooltip */
  .fs3d-tooltip {
    position: absolute;
    z-index: 20;
    pointer-events: none;
    background: rgba(8, 8, 18, 0.94);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 10px;
    padding: 12px 16px;
    max-width: 320px;
    min-width: 200px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 12px;
    color: #ddd;
    line-height: 1.55;
    opacity: 0;
    transform: translateY(4px);
    transition: opacity 0.18s ease, transform 0.18s ease;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }
  .fs3d-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }
  .fs3d-tooltip-task {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .fs3d-tooltip-task-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .fs3d-tooltip-task-name {
    font-weight: 600;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }
  .fs3d-tooltip-desc {
    color: rgba(255,255,255,0.8);
    font-size: 12px;
    margin-bottom: 8px;
    line-height: 1.5;
  }
  .fs3d-tooltip-meta {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 2px 10px;
    font-size: 11px;
    color: rgba(255,255,255,0.5);
  }
  .fs3d-tooltip-meta-val {
    color: rgba(255,255,255,0.85);
    font-variant-numeric: tabular-nums;
    font-weight: 500;
  }
  .fs3d-tooltip-link {
    display: inline-block;
    margin-top: 8px;
    font-size: 10px;
    color: rgba(107, 92, 231, 0.85);
    text-decoration: none;
    pointer-events: auto;
    border-bottom: 1px solid rgba(107, 92, 231, 0.3);
    transition: color 0.2s;
  }
  .fs3d-tooltip-link:hover {
    color: rgba(107, 92, 231, 1);
  }

  /* Loading spinner */
  .fs3d-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 30;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    color: rgba(255,255,255,0.5);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 13px;
  }
  .fs3d-spinner {
    width: 32px;
    height: 32px;
    border: 2px solid rgba(255,255,255,0.08);
    border-top-color: rgba(107,92,231,0.7);
    border-radius: 50%;
    animation: fs3d-spin 0.8s linear infinite;
  }
  @keyframes fs3d-spin {
    to { transform: rotate(360deg); }
  }
  .fs3d-error {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 30;
    color: #e15759;
    font-family: monospace;
    font-size: 12px;
    text-align: center;
    max-width: 80%;
    background: rgba(10,10,20,0.9);
    padding: 16px;
    border-radius: 8px;
    border: 1px solid rgba(225,87,89,0.3);
  }

  /* Mobile adjustments */
  @media (max-width: 640px) {
    .feature-space-3d {
      height: 420px;
    }
    .fs3d-panel {
      padding: 8px 10px;
      font-size: 10px;
    }
    .fs3d-model-btn {
      padding: 4px 7px;
      font-size: 10px;
    }
    .fs3d-task-label {
      font-size: 10px;
    }
    .fs3d-tooltip {
      max-width: 240px;
      font-size: 11px;
    }
  }
</style>
<script>
(function() {
  const CONTAINER_CLASS = 'feature-space-3d';

  // ---- Task configuration ----
  const TASK_COLORS = {
    mmlu: '#6B5CE7',
    mmlupro: '#4EA5B7',
    simpleqa: '#E38A42',
    bbq_ambig: '#9B59B6',
    bbq_disambig: '#CEC0FA',
    harmbench: '#E15759',
    xstest: '#59A14F',
    gsm8k: '#F28E2B'
  };
  const TASK_LABELS = {
    mmlu: 'MMLU',
    mmlupro: 'MMLU-Pro',
    simpleqa: 'SimpleQA',
    bbq_ambig: 'BBQ Ambig',
    bbq_disambig: 'BBQ Disambig',
    harmbench: 'HarmBench',
    xstest: 'XSTest',
    gsm8k: 'GSM8K'
  };

  // Robust container resolution (works with HtmlEmbed eval execution)
  const scriptEl = document.currentScript;
  let container = scriptEl ? scriptEl.previousElementSibling : null;
  if (!(container && container.classList && container.classList.contains(CONTAINER_CLASS))) {
    const candidates = Array.from(document.querySelectorAll('.' + CONTAINER_CLASS))
      .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
    container = candidates[candidates.length - 1] || null;
  }
  if (!container) return;
  if (container.dataset) {
    if (container.dataset.mounted === 'true') return;
    container.dataset.mounted = 'true';
  }

  // ---- Resolve data-datafiles ----
  let mountEl = container;
  while (mountEl && !mountEl.getAttribute?.('data-datafiles') && !mountEl.getAttribute?.('data-config')) {
    mountEl = mountEl.parentElement;
  }
  let providedFiles = null;
  try {
    const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
    if (attr && attr.trim()) {
      const val = attr.trim();
      if (val.startsWith('[')) {
        providedFiles = JSON.parse(val);
      } else {
        providedFiles = val.split(',').map(s => s.trim()).filter(Boolean);
      }
    }
  } catch (e) { /* ignore */ }

  function buildPaths(filename) {
    const name = filename.includes('/') ? filename : filename;
    const paths = [];
    if (name.includes('/')) {
      paths.push(name);
    } else {
      paths.push('/data/' + name);
      paths.push('./assets/data/' + name);
      paths.push('../assets/data/' + name);
    }
    return paths;
  }

  async function fetchFirstAvailable(paths) {
    for (const p of paths) {
      try {
        const r = await fetch(p, { cache: 'no-cache' });
        if (r.ok) return await r.json();
      } catch (e) { /* try next */ }
    }
    throw new Error('Could not load data from: ' + paths.join(', '));
  }

  // ---- Show loading ----
  const loadingEl = document.createElement('div');
  loadingEl.className = 'fs3d-loading';
  loadingEl.innerHTML = '<div class="fs3d-spinner"></div><div>Loading feature data...</div>';
  container.appendChild(loadingEl);

  // ---- Load Three.js (matching template's D3 CDN pattern) ----
  // Strategy 1: ESM dynamic import (modern Three.js via esm.sh)
  // Strategy 2: Script tag injection (r143 — last version with global OrbitControls)
  async function loadThreeJS() {
    if (window.__THREE_ATLAS) return window.__THREE_ATLAS;

    // Try ESM import first (modern, r171)
    try {
      var coreMod = await import('https://esm.sh/three@0.171.0');
      var orbitMod = await import('https://esm.sh/three@0.171.0/examples/jsm/controls/OrbitControls.js');
      // Build a plain object namespace (module namespaces are sealed)
      var ns = {};
      var keys = Object.keys(coreMod);
      for (var k = 0; k < keys.length; k++) ns[keys[k]] = coreMod[keys[k]];
      ns.OrbitControls = orbitMod.OrbitControls;
      window.__THREE_ATLAS = ns;
      return ns;
    } catch (esmErr) {
      console.warn('ESM import failed, falling back to script tags:', esmErr);
    }

    // Fallback: script tag injection (r143, same pattern as template's D3 loading)
    return new Promise(function(resolve, reject) {
      function loadScript(id, url, check, onDone) {
        if (check()) return onDone();
        var s = document.getElementById(id);
        if (!s) {
          s = document.createElement('script');
          s.id = id;
          s.src = url;
          s.onerror = function() { reject(new Error('Failed to load: ' + url)); };
          document.head.appendChild(s);
        }
        var handler = function() { if (check()) onDone(); };
        s.addEventListener('load', handler, { once: true });
        if (check()) onDone();
      }
      loadScript(
        'three-cdn-core',
        'https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.min.js',
        function() { return !!window.THREE; },
        function() {
          loadScript(
            'three-cdn-orbit',
            'https://cdn.jsdelivr.net/npm/three@0.143.0/examples/js/controls/OrbitControls.js',
            function() { return !!(window.THREE && window.THREE.OrbitControls); },
            function() { window.__THREE_ATLAS = window.THREE; resolve(window.THREE); }
          );
        }
      );
    });
  }

  async function init() {
    var THREE;
    try {
      THREE = await loadThreeJS();
    } catch (e) {
      showError('Failed to load Three.js: ' + e.message);
      return;
    }

    // ---- Load data ----
    const gemmaFile = (providedFiles && providedFiles.find(f => f.includes('gemma'))) || 'features_gemma_all.json';
    const llamaFile = (providedFiles && providedFiles.find(f => f.includes('llama'))) || 'features_llama_all.json';

    let gemmaData, llamaData;
    try {
      [gemmaData, llamaData] = await Promise.all([
        fetchFirstAvailable(buildPaths(gemmaFile)),
        fetchFirstAvailable(buildPaths(llamaFile))
      ]);
    } catch (e) {
      showError('Data load failed: ' + e.message);
      return;
    }

    loadingEl.remove();

    // ---- Parse features into flat array ----
    function parseFeatures(data) {
      const features = [];
      const tasks = data.tasks || {};
      for (const taskName of Object.keys(tasks)) {
        const layers = tasks[taskName].layers || {};
        for (const layerStr of Object.keys(layers)) {
          const layer = parseInt(layerStr, 10);
          const positive = layers[layerStr].positive || [];
          for (const feat of positive) {
            features.push({
              task: taskName,
              layer: layer,
              correlation: feat.correlation || 0,
              coefficient: feat.coefficient || 0.01,
              frequency: feat.frequency || 0,
              featureIndex: feat.feature_index,
              description: feat.description || '',
              neuronpediaUrl: feat.neuronpedia_url || '',
              stats: feat.stats || {}
            });
          }
        }
      }
      return features;
    }

    const datasets = {
      gemma: { features: parseFeatures(gemmaData), model: gemmaData.model || 'gemma-2-2b', maxLayer: 25 },
      llama: { features: parseFeatures(llamaData), model: llamaData.model || 'llama-3.1-8b', maxLayer: 31 }
    };

    // Find max layer from data
    for (const key of Object.keys(datasets)) {
      const ds = datasets[key];
      let mx = 0;
      for (const f of ds.features) { if (f.layer > mx) mx = f.layer; }
      ds.maxLayer = mx;
    }

    // ---- State ----
    let currentModel = 'gemma';
    const taskVisibility = {};
    for (const t of Object.keys(TASK_COLORS)) taskVisibility[t] = true;

    // ---- Three.js setup ----
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a14);
    scene.fog = new THREE.FogExp2(0x0a0a14, 0.012);

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(22, 16, 28);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 8;
    controls.maxDistance = 80;
    controls.target.set(6, 3, 3);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.6;
    controls.update();

    // Stop auto-rotate on first user interaction
    let userInteracted = false;
    function onUserInteract() {
      if (!userInteracted) {
        userInteracted = true;
        controls.autoRotate = false;
        // Hide hint
        const hint = container.querySelector('.fs3d-hint');
        if (hint) hint.classList.add('hidden');
        setTimeout(() => { if (hint) hint.remove(); }, 1000);
      }
    }
    renderer.domElement.addEventListener('pointerdown', onUserInteract, { once: false });
    renderer.domElement.addEventListener('wheel', onUserInteract, { once: false });

    // ---- Ambient light ----
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    // ---- Scene dimensions ----
    // X: layer (0..maxLayer) mapped to 0..sceneWidth
    // Y: correlation (0..0.8) mapped to 0..sceneHeight
    // Z: coefficient (log scale) mapped to 0..sceneDepth
    const SCENE_W = 20;  // x extent
    const SCENE_H = 12;  // y extent
    const SCENE_D = 12;  // z extent

    function mapFeature(f, maxLayer) {
      const x = (f.layer / maxLayer) * SCENE_W;
      const y = (Math.min(f.correlation, 0.8) / 0.8) * SCENE_H;
      const logCoeff = Math.log10(Math.max(f.coefficient, 0.01));
      // coefficient range: ~0.01 to ~200 => log: -2 to 2.3
      const zNorm = (logCoeff - (-2)) / (2.5 - (-2));
      const z = Math.max(0, Math.min(1, zNorm)) * SCENE_D;
      return { x, y, z };
    }

    // ---- Create grid & axes ----
    function createGrid() {
      const gridGroup = new THREE.Group();

      // Floor grid
      const gridMat = new THREE.LineBasicMaterial({ color: 0x1a1a2e, transparent: true, opacity: 0.6 });

      // X-Z grid lines on floor (y=0)
      const xLines = 10;
      const zLines = 6;
      for (let i = 0; i <= xLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3((i / xLines) * SCENE_W, 0, 0),
          new THREE.Vector3((i / xLines) * SCENE_W, 0, SCENE_D)
        ]);
        gridGroup.add(new THREE.Line(geo, gridMat));
      }
      for (let i = 0; i <= zLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, (i / zLines) * SCENE_D),
          new THREE.Vector3(SCENE_W, 0, (i / zLines) * SCENE_D)
        ]);
        gridGroup.add(new THREE.Line(geo, gridMat));
      }

      // Back wall grid (z=0)
      const wallMat = new THREE.LineBasicMaterial({ color: 0x141428, transparent: true, opacity: 0.4 });
      const yLines = 6;
      for (let i = 0; i <= xLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3((i / xLines) * SCENE_W, 0, 0),
          new THREE.Vector3((i / xLines) * SCENE_W, SCENE_H, 0)
        ]);
        gridGroup.add(new THREE.Line(geo, wallMat));
      }
      for (let i = 0; i <= yLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, (i / yLines) * SCENE_H, 0),
          new THREE.Vector3(SCENE_W, (i / yLines) * SCENE_H, 0)
        ]);
        gridGroup.add(new THREE.Line(geo, wallMat));
      }

      // Side wall grid (x=0)
      for (let i = 0; i <= zLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, (i / zLines) * SCENE_D),
          new THREE.Vector3(0, SCENE_H, (i / zLines) * SCENE_D)
        ]);
        gridGroup.add(new THREE.Line(geo, wallMat));
      }
      for (let i = 0; i <= yLines; i++) {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, (i / yLines) * SCENE_H, 0),
          new THREE.Vector3(0, (i / yLines) * SCENE_H, SCENE_D)
        ]);
        gridGroup.add(new THREE.Line(geo, wallMat));
      }

      // Axis lines (brighter)
      const axisMat = new THREE.LineBasicMaterial({ color: 0x333355, transparent: true, opacity: 0.8 });
      // X axis
      const xAxis = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0), new THREE.Vector3(SCENE_W, 0, 0)
      ]);
      gridGroup.add(new THREE.Line(xAxis, axisMat));
      // Y axis
      const yAxis = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, SCENE_H, 0)
      ]);
      gridGroup.add(new THREE.Line(yAxis, axisMat));
      // Z axis
      const zAxis = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, SCENE_D)
      ]);
      gridGroup.add(new THREE.Line(zAxis, axisMat));

      // Tick marks as small sprites
      function addTickLabel(text, pos) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.font = '14px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 64, 16);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        const sprite = new THREE.Sprite(mat);
        sprite.position.copy(pos);
        sprite.scale.set(2.5, 0.6, 1);
        gridGroup.add(sprite);
      }

      return gridGroup;
    }

    const gridGroup = createGrid();
    scene.add(gridGroup);

    // ---- Axis tick labels (3D sprites) ----
    function addAxisTicks(maxLayer) {
      // Remove old ticks
      if (scene.__tickGroup) scene.remove(scene.__tickGroup);
      const tickGroup = new THREE.Group();
      scene.__tickGroup = tickGroup;

      function makeLabel(text, pos, scale) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 40;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 128, 40);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '500 14px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 64, 20);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        const sprite = new THREE.Sprite(mat);
        sprite.position.copy(pos);
        sprite.scale.set(scale || 2.2, 0.6, 1);
        tickGroup.add(sprite);
      }

      // X-axis ticks (Layer)
      const xSteps = maxLayer <= 25 ? [1, 5, 10, 15, 20, 25] : [1, 5, 10, 15, 20, 25, 31];
      for (const l of xSteps) {
        if (l > maxLayer) continue;
        const x = (l / maxLayer) * SCENE_W;
        makeLabel(String(l), new THREE.Vector3(x, -0.6, -0.3));
      }

      // Y-axis ticks (Correlation)
      for (let c = 0; c <= 0.8; c += 0.2) {
        const y = (c / 0.8) * SCENE_H;
        makeLabel(c.toFixed(1), new THREE.Vector3(-1.2, y, -0.3));
      }

      // Z-axis ticks (Coefficient - log)
      const coeffTicks = [0.1, 1, 10, 100];
      for (const cv of coeffTicks) {
        const logVal = Math.log10(cv);
        const zNorm = (logVal - (-2)) / (2.5 - (-2));
        const z = Math.max(0, Math.min(1, zNorm)) * SCENE_D;
        makeLabel(cv >= 1 ? String(cv) : cv.toFixed(1), new THREE.Vector3(-1.2, -0.6, z));
      }

      // Axis name labels
      function makeAxisName(text, pos) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 48;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 256, 48);
        ctx.fillStyle = 'rgba(255,255,255,0.45)';
        ctx.font = '600 16px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 24);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
        const sprite = new THREE.Sprite(mat);
        sprite.position.copy(pos);
        sprite.scale.set(4, 0.8, 1);
        tickGroup.add(sprite);
      }

      makeAxisName('Layer', new THREE.Vector3(SCENE_W / 2, -1.6, -0.3));
      makeAxisName('Correlation', new THREE.Vector3(-2.5, SCENE_H / 2, -0.3));
      makeAxisName('Coefficient (log)', new THREE.Vector3(-2.5, -1.6, SCENE_D / 2));

      scene.add(tickGroup);
    }

    // ---- Custom shader for points ----
    const vertexShader = `
      attribute float aSize;
      attribute vec3 aColor;
      attribute float aVisible;
      varying vec3 vColor;
      varying float vAlpha;
      uniform float uPixelRatio;
      uniform float uHoverIndex;
      uniform float uTime;

      void main() {
        vColor = aColor;
        vAlpha = aVisible;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        float dist = -mvPosition.z;
        float baseSize = aSize * uPixelRatio * (120.0 / dist);

        // Subtle pulse
        float pulse = 1.0 + sin(uTime * 2.0 + position.x * 0.5 + position.z * 0.3) * 0.04;

        gl_PointSize = baseSize * pulse;
        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    const fragmentShader = `
      varying vec3 vColor;
      varying float vAlpha;

      void main() {
        if (vAlpha < 0.01) discard;

        vec2 center = gl_PointCoord - 0.5;
        float dist = length(center);

        // Glowing point with additive blending
        float alpha = 1.0 - smoothstep(0.15, 0.45, dist);
        float glow = exp(-dist * dist * 8.0) * 0.4;

        vec3 color = vColor;
        float finalAlpha = (alpha + glow * 0.3) * vAlpha;

        if (finalAlpha < 0.01) discard;
        gl_FragColor = vec4(color, finalAlpha * 0.75);
      }
    `;

    // ---- Points cloud ----
    let pointsMesh = null;
    let currentFeatures = [];
    let pointsGeometry = null;

    function buildPoints(modelKey) {
      const ds = datasets[modelKey];
      currentFeatures = ds.features;
      const n = currentFeatures.length;

      if (pointsMesh) {
        scene.remove(pointsMesh);
        pointsGeometry.dispose();
      }

      pointsGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(n * 3);
      const colors = new Float32Array(n * 3);
      const sizes = new Float32Array(n);
      const visible = new Float32Array(n);

      for (let i = 0; i < n; i++) {
        const f = currentFeatures[i];
        const p = mapFeature(f, ds.maxLayer);
        positions[i * 3] = p.x;
        positions[i * 3 + 1] = p.y;
        positions[i * 3 + 2] = p.z;

        const hex = TASK_COLORS[f.task] || '#888888';
        const c = new THREE.Color(hex);
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;

        // Size based on frequency (0.8 to 2 range — small to reduce overlap)
        sizes[i] = 0.8 + Math.min(f.frequency / 100, 1) * 1.2;
        visible[i] = taskVisibility[f.task] ? 1.0 : 0.0;
      }

      pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      pointsGeometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
      pointsGeometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
      pointsGeometry.setAttribute('aVisible', new THREE.BufferAttribute(visible, 1));

      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
          uHoverIndex: { value: -1 },
          uTime: { value: 0 }
        },
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      pointsMesh = new THREE.Points(pointsGeometry, material);
      scene.add(pointsMesh);

      addAxisTicks(ds.maxLayer);
      updateStats();
    }

    // buildPoints called after UI setup (statsEl needed)

    // ---- Raycaster for hover ----
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.4;
    const mouse = new THREE.Vector2();
    let hoveredIndex = -1;

    // Hover highlight point (separate)
    const hoverGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const hoverMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
    const hoverSphere = new THREE.Mesh(hoverGeo, hoverMat);
    scene.add(hoverSphere);

    // Hover ring
    const ringGeo = new THREE.RingGeometry(0.2, 0.35, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const hoverRing = new THREE.Mesh(ringGeo, ringMat);
    hoverRing.lookAt(camera.position);
    scene.add(hoverRing);

    // ---- Tooltip ----
    const tooltip = document.createElement('div');
    tooltip.className = 'fs3d-tooltip';
    container.appendChild(tooltip);

    function showTooltip(feat, screenX, screenY) {
      const taskColor = TASK_COLORS[feat.task] || '#888';
      const taskLabel = TASK_LABELS[feat.task] || feat.task;

      let html = `
        <div class="fs3d-tooltip-task">
          <div class="fs3d-tooltip-task-dot" style="background:${taskColor};box-shadow:0 0 6px ${taskColor}"></div>
          <div class="fs3d-tooltip-task-name" style="color:${taskColor}">${taskLabel}</div>
        </div>
        <div class="fs3d-tooltip-desc">${feat.description || 'No description'}</div>
        <div class="fs3d-tooltip-meta">
          <span>Layer</span><span class="fs3d-tooltip-meta-val">${feat.layer}</span>
          <span>Correlation</span><span class="fs3d-tooltip-meta-val">${feat.correlation.toFixed(4)}</span>
          <span>Coefficient</span><span class="fs3d-tooltip-meta-val">${feat.coefficient.toFixed(3)}</span>
          <span>Frequency</span><span class="fs3d-tooltip-meta-val">${feat.frequency.toFixed(1)}%</span>
          <span>Feature</span><span class="fs3d-tooltip-meta-val">#${feat.featureIndex}</span>
        </div>
      `;
      if (feat.neuronpediaUrl) {
        html += `<a class="fs3d-tooltip-link" href="${feat.neuronpediaUrl}" target="_blank" rel="noopener">View on Neuronpedia &#8599;</a>`;
      }
      tooltip.innerHTML = html;

      const rect = container.getBoundingClientRect();
      let tx = screenX - rect.left + 16;
      let ty = screenY - rect.top - 10;

      const tw = tooltip.offsetWidth || 240;
      const th = tooltip.offsetHeight || 150;
      if (tx + tw > rect.width - 10) tx = screenX - rect.left - tw - 16;
      if (ty + th > rect.height - 10) ty = rect.height - th - 10;
      if (ty < 10) ty = 10;

      tooltip.style.left = tx + 'px';
      tooltip.style.top = ty + 'px';
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
    }

    function onMouseMove(e) {
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(pointsMesh);

      // Filter out hidden features
      let validIntersect = null;
      for (const hit of intersects) {
        const idx = hit.index;
        if (idx < currentFeatures.length) {
          const f = currentFeatures[idx];
          if (taskVisibility[f.task]) {
            validIntersect = hit;
            break;
          }
        }
      }

      if (validIntersect) {
        const idx = validIntersect.index;
        if (idx !== hoveredIndex) {
          hoveredIndex = idx;
          const f = currentFeatures[idx];
          const pos = validIntersect.point;

          hoverSphere.position.copy(pos);
          hoverSphere.material.opacity = 0.8;
          hoverSphere.material.color.set(TASK_COLORS[f.task] || '#fff');
          hoverSphere.scale.set(1.5, 1.5, 1.5);

          hoverRing.position.copy(pos);
          hoverRing.material.opacity = 0.4;
          hoverRing.material.color.set(TASK_COLORS[f.task] || '#fff');
          hoverRing.lookAt(camera.position);
        }
        showTooltip(currentFeatures[hoveredIndex], e.clientX, e.clientY);
        container.style.cursor = 'pointer';
      } else {
        if (hoveredIndex !== -1) {
          hoveredIndex = -1;
          hoverSphere.material.opacity = 0;
          hoverRing.material.opacity = 0;
          hideTooltip();
        }
        container.style.cursor = 'grab';
      }
    }

    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('mouseleave', () => {
      hoveredIndex = -1;
      hoverSphere.material.opacity = 0;
      hoverRing.material.opacity = 0;
      hideTooltip();
    });

    // Click to open Neuronpedia
    container.addEventListener('click', (e) => {
      if (hoveredIndex >= 0 && hoveredIndex < currentFeatures.length) {
        const f = currentFeatures[hoveredIndex];
        if (f.neuronpediaUrl) {
          window.open(f.neuronpediaUrl, '_blank');
        }
      }
    });

    // ---- UI Controls ----
    const controlsEl = document.createElement('div');
    controlsEl.className = 'fs3d-controls';

    // Model toggle
    const modelPanel = document.createElement('div');
    modelPanel.className = 'fs3d-panel';
    modelPanel.innerHTML = `
      <div class="fs3d-panel-title">Model</div>
      <div class="fs3d-model-toggle">
        <button class="fs3d-model-btn active" data-model="gemma">Gemma-2 2B</button>
        <button class="fs3d-model-btn" data-model="llama">LLaMA-3.1 8B</button>
      </div>
    `;
    controlsEl.appendChild(modelPanel);

    // Task filter
    const taskPanel = document.createElement('div');
    taskPanel.className = 'fs3d-panel';
    let taskHTML = '<div class="fs3d-panel-title">Tasks</div><div class="fs3d-tasks">';
    for (const [task, color] of Object.entries(TASK_COLORS)) {
      const label = TASK_LABELS[task] || task;
      taskHTML += `
        <label class="fs3d-task-row" data-task="${task}">
          <input type="checkbox" checked>
          <div class="fs3d-task-dot" style="background:${color};color:${color}"></div>
          <span class="fs3d-task-label">${label}</span>
        </label>
      `;
    }
    taskHTML += '</div>';
    taskPanel.innerHTML = taskHTML;
    controlsEl.appendChild(taskPanel);

    // View presets
    const viewPanel = document.createElement('div');
    viewPanel.className = 'fs3d-panel';
    viewPanel.innerHTML = `
      <div class="fs3d-panel-title">View</div>
      <div class="fs3d-views">
        <button class="fs3d-view-btn" data-view="default" title="Default perspective">3D</button>
        <button class="fs3d-view-btn" data-view="front" title="Layer vs Correlation">Front</button>
        <button class="fs3d-view-btn" data-view="top" title="Layer vs Coefficient">Top</button>
        <button class="fs3d-view-btn" data-view="side" title="Correlation vs Coefficient">Side</button>
      </div>
    `;
    controlsEl.appendChild(viewPanel);

    // Buttons
    const btnPanel = document.createElement('div');
    btnPanel.className = 'fs3d-btn-row';
    btnPanel.innerHTML = `
      <button class="fs3d-btn" id="fs3d-reset">Reset</button>
      <button class="fs3d-btn" id="fs3d-toggle-all">Hide All</button>
      <button class="fs3d-btn active" id="fs3d-auto-rotate">Auto-Rotate</button>
    `;
    controlsEl.appendChild(btnPanel);

    container.appendChild(controlsEl);

    // Interaction hint
    const hintEl = document.createElement('div');
    hintEl.className = 'fs3d-hint';
    hintEl.innerHTML = '<kbd>Drag</kbd> rotate · <kbd>Scroll</kbd> zoom · <kbd>Hover</kbd> details · <kbd>Dblclick</kbd> isolate task';
    container.appendChild(hintEl);

    // Stats
    const statsEl = document.createElement('div');
    statsEl.className = 'fs3d-stats';
    statsEl.innerHTML = '<div class="fs3d-stats-inner"><div class="fs3d-stats-count">0</div>features visible</div>';
    container.appendChild(statsEl);

    function updateStats() {
      let count = 0;
      for (const f of currentFeatures) {
        if (taskVisibility[f.task]) count++;
      }
      const countEl = statsEl.querySelector('.fs3d-stats-count');
      if (countEl) countEl.textContent = count.toLocaleString();
    }

    // Now that UI (statsEl) exists, build initial points
    buildPoints('gemma');

    // ---- Model toggle handler ----
    modelPanel.querySelectorAll('.fs3d-model-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const model = btn.dataset.model;
        if (model === currentModel) return;
        currentModel = model;
        modelPanel.querySelectorAll('.fs3d-model-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        // Smooth camera transition
        const targetPos = camera.position.clone();
        const targetLookAt = controls.target.clone();

        buildPoints(model);
        updateVisibility();

        // Animate camera smoothly
        animateCamera(targetPos, targetLookAt);
      });
    });

    function animateCamera(fromPos, fromTarget) {
      const toPos = fromPos.clone();
      const toTarget = new THREE.Vector3(
        datasets[currentModel].maxLayer <= 25 ? 6 : 8,
        3, 3
      );
      // Just update target smoothly
      controls.target.copy(toTarget);
    }

    // ---- Task checkbox handlers (with solo on right-click) ----
    let soloTask = null;
    taskPanel.querySelectorAll('.fs3d-task-row').forEach(row => {
      const cb = row.querySelector('input[type="checkbox"]');
      const task = row.dataset.task;

      // Checkbox toggle
      cb.addEventListener('change', () => {
        soloTask = null;
        taskVisibility[task] = cb.checked;
        row.classList.toggle('unchecked', !cb.checked);
        updateVisibility();
      });

      // Double-click to solo/unsolo a task
      row.addEventListener('dblclick', (e) => {
        e.preventDefault();
        if (soloTask === task) {
          // Unsolo: show all
          soloTask = null;
          for (const t of Object.keys(taskVisibility)) taskVisibility[t] = true;
          taskPanel.querySelectorAll('.fs3d-task-row').forEach(r => {
            r.querySelector('input[type="checkbox"]').checked = true;
            r.classList.remove('unchecked');
          });
        } else {
          // Solo this task
          soloTask = task;
          for (const t of Object.keys(taskVisibility)) taskVisibility[t] = (t === task);
          taskPanel.querySelectorAll('.fs3d-task-row').forEach(r => {
            const t = r.dataset.task;
            const checked = (t === task);
            r.querySelector('input[type="checkbox"]').checked = checked;
            r.classList.toggle('unchecked', !checked);
          });
        }
        updateVisibility();
      });
    });

    function updateVisibility() {
      if (!pointsGeometry) return;
      const vis = pointsGeometry.getAttribute('aVisible');
      for (let i = 0; i < currentFeatures.length; i++) {
        vis.array[i] = taskVisibility[currentFeatures[i].task] ? 1.0 : 0.0;
      }
      vis.needsUpdate = true;
      updateStats();
    }

    // ---- Smooth camera transition ----
    const VIEW_PRESETS = {
      default: { pos: [22, 16, 28], target: [6, 3, 3] },
      front:   { pos: [10, 6, 30], target: [10, 6, 0] },   // Layer vs Correlation
      top:     { pos: [10, 28, 6], target: [10, 0, 6] },    // Layer vs Coefficient
      side:    { pos: [-12, 6, 6], target: [10, 6, 6] }     // Correlation vs Coefficient
    };

    function smoothTransition(toPos, toTarget, duration) {
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endPos = new THREE.Vector3(toPos[0], toPos[1], toPos[2]);
      const endTarget = new THREE.Vector3(toTarget[0], toTarget[1], toTarget[2]);
      const startTime = performance.now();
      const dur = duration || 800;

      function step(now) {
        let t = (now - startTime) / dur;
        if (t > 1) t = 1;
        const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        camera.position.lerpVectors(startPos, endPos, ease);
        controls.target.lerpVectors(startTarget, endTarget, ease);
        controls.update();
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // Auto-rotate toggle
    const autoRotateBtn = document.getElementById('fs3d-auto-rotate');
    autoRotateBtn?.addEventListener('click', function() {
      controls.autoRotate = !controls.autoRotate;
      this.classList.toggle('active', controls.autoRotate);
    });

    // Reset button
    document.getElementById('fs3d-reset')?.addEventListener('click', () => {
      smoothTransition([22, 16, 28], [
        datasets[currentModel].maxLayer <= 25 ? 6 : 8, 3, 3
      ], 800);
      controls.autoRotate = true;
      if (autoRotateBtn) autoRotateBtn.classList.add('active');
      userInteracted = false;
    });

    // Toggle all button
    let allVisible = true;
    document.getElementById('fs3d-toggle-all')?.addEventListener('click', function() {
      allVisible = !allVisible;
      soloTask = null;
      this.textContent = allVisible ? 'Hide All' : 'Show All';
      for (const t of Object.keys(taskVisibility)) {
        taskVisibility[t] = allVisible;
      }
      taskPanel.querySelectorAll('.fs3d-task-row').forEach(row => {
        const cb = row.querySelector('input[type="checkbox"]');
        cb.checked = allVisible;
        row.classList.toggle('unchecked', !allVisible);
      });
      updateVisibility();
    });

    // View preset buttons
    viewPanel.querySelectorAll('.fs3d-view-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        const preset = VIEW_PRESETS[view];
        if (!preset) return;
        onUserInteract();
        controls.autoRotate = false;
        if (autoRotateBtn) autoRotateBtn.classList.remove('active');
        smoothTransition(preset.pos, preset.target, 800);
      });
    });

    // ---- Ambient particles (background dust) ----
    const dustCount = 200;
    const dustGeo = new THREE.BufferGeometry();
    const dustPositions = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
      dustPositions[i * 3] = (Math.random() - 0.3) * 40;
      dustPositions[i * 3 + 1] = Math.random() * 20;
      dustPositions[i * 3 + 2] = (Math.random() - 0.3) * 30;
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
    const dustMat = new THREE.PointsMaterial({
      color: 0x2a2a4a,
      size: 0.06,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    scene.add(new THREE.Points(dustGeo, dustMat));

    // ---- Render loop ----
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      const elapsed = clock.getElapsedTime();
      if (pointsMesh && pointsMesh.material.uniforms) {
        pointsMesh.material.uniforms.uTime.value = elapsed;
      }

      // Hover ring always faces camera
      if (hoverRing.material.opacity > 0) {
        hoverRing.lookAt(camera.position);
        hoverRing.scale.set(
          1 + Math.sin(elapsed * 4) * 0.15,
          1 + Math.sin(elapsed * 4) * 0.15,
          1
        );
      }

      renderer.render(scene, camera);
    }
    animate();

    // ---- Resize ----
    const ro = new ResizeObserver(() => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      if (w === 0 || h === 0) return;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
    ro.observe(container);
  }

  function showError(msg) {
    if (!container) return;
    const loading = container.querySelector('.fs3d-loading');
    if (loading) loading.remove();
    const err = document.createElement('div');
    err.className = 'fs3d-error';
    err.textContent = msg;
    container.appendChild(err);
  }

  init();
})();
</script>
</div></div></figure> </div>
<p><em>Each point is an SAE feature. X = layer, Y = correlation with task success, Z = steering coefficient. Color encodes task. Rotate to explore; hover for feature descriptions.</em></p>
<p>Features cluster into interpretable categories:</p>
<ul>
<li><strong>Structured-output features</strong> for multiple-choice tasks (MMLU, BBQ) encoding format patterns</li>
<li><strong>Refusal features</strong> for safety tasks (HarmBench) encoding rejection behavior</li>
<li><strong>Neutrality features</strong> for bias mitigation (BBQ) encoding balanced perspective</li>
<li><strong>Mathematical features</strong> appearing across tasks, consistent with the finding that math pre-training boosts broad accuracy</li>
</ul>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Feature Explorer</figcaption><div class="html-embed__card"><div id="frag-rxco23d2yf" data-datafiles="features_gemma_all.json,features_llama_all.json"><div class="feature-explorer"></div>
<style>
  .feature-explorer {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --fe-primary: #6B5CE7;
    --fe-primary-light: #8B7FED;
    --fe-primary-dark: #5346C7;
    --fe-positive: #6B5CE7;
    --fe-negative: #E74C5C;
    --fe-success: #34C759;
    --fe-warning: #FF9F0A;
    --fe-card-bg: var(--surface-bg, #ffffff);
    --fe-page-bg: var(--page-bg, #f5f5f7);
    --fe-text: var(--text-color, #1d1d1f);
    --fe-muted: var(--muted-color, #86868b);
    --fe-border: var(--border-color, #d2d2d7);
    --fe-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.04);
    --fe-shadow-hover: 0 2px 8px rgba(0,0,0,0.12), 0 8px 24px rgba(0,0,0,0.08);
    line-height: 1.5;
    color: var(--fe-text);
  }

  /* ---- Controls ---- */
  .feature-explorer .fe-controls {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 20px;
    padding: 16px;
    background: var(--fe-card-bg);
    border-radius: 12px;
    border: 1px solid var(--fe-border);
  }

  .feature-explorer .fe-control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .feature-explorer .fe-control-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--fe-muted);
  }

  /* Segmented control for model toggle */
  .feature-explorer .fe-segmented {
    display: inline-flex;
    background: var(--fe-page-bg);
    border-radius: 8px;
    padding: 2px;
    border: 1px solid var(--fe-border);
    gap: 0;
  }

  .feature-explorer .fe-seg-btn {
    padding: 6px 14px;
    font-size: 13px;
    font-weight: 500;
    border: none;
    background: transparent;
    color: var(--fe-muted);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease;
    white-space: nowrap;
    font-family: inherit;
  }

  .feature-explorer .fe-seg-btn:hover {
    color: var(--fe-text);
  }

  .feature-explorer .fe-seg-btn.active {
    background: var(--fe-primary);
    color: #fff;
    box-shadow: 0 1px 4px rgba(107,92,231,0.3);
  }

  /* Polarity segmented control */
  .feature-explorer .fe-seg-btn.polarity-pos.active {
    background: var(--fe-positive);
  }

  .feature-explorer .fe-seg-btn.polarity-neg.active {
    background: var(--fe-negative);
  }

  /* Dropdowns */
  .feature-explorer select {
    padding: 6px 28px 6px 10px;
    font-size: 13px;
    font-family: inherit;
    border: 1px solid var(--fe-border);
    border-radius: 8px;
    background: var(--fe-card-bg);
    color: var(--fe-text);
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%2386868b'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    min-width: 140px;
  }

  .feature-explorer select:focus {
    outline: none;
    border-color: var(--fe-primary);
    box-shadow: 0 0 0 3px rgba(107,92,231,0.15);
  }

  /* ---- Summary strip ---- */
  .feature-explorer .fe-summary {
    display: flex;
    gap: 24px;
    align-items: center;
    margin-bottom: 16px;
    padding: 0 4px;
    font-size: 13px;
    color: var(--fe-muted);
  }

  .feature-explorer .fe-summary strong {
    color: var(--fe-text);
    font-weight: 600;
  }

  /* ---- Card grid ---- */
  .feature-explorer .fe-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 14px;
  }

  @media (max-width: 900px) {
    .feature-explorer .fe-grid {
      grid-template-columns: 1fr;
    }
    .feature-explorer .fe-controls {
      gap: 12px;
    }
  }

  /* ---- Feature card ---- */
  .feature-explorer .fe-card {
    background: var(--fe-card-bg);
    border: 1px solid var(--fe-border);
    border-radius: 12px;
    padding: 16px;
    cursor: pointer;
    transition: box-shadow 0.2s ease, transform 0.15s ease, opacity 0.3s ease;
    box-shadow: var(--fe-shadow);
    position: relative;
    overflow: hidden;
  }

  .feature-explorer .fe-card:hover {
    box-shadow: var(--fe-shadow-hover);
    transform: translateY(-1px);
  }

  .feature-explorer .fe-card.expanded {
    grid-column: 1 / -1;
  }

  .feature-explorer .fe-card-entering {
    opacity: 0;
    transform: translateY(8px);
  }

  .feature-explorer .fe-card-visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Card header */
  .feature-explorer .fe-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
  }

  .feature-explorer .fe-layer-badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 700;
    background: var(--fe-primary);
    color: #fff;
    letter-spacing: 0.3px;
    white-space: nowrap;
  }

  .feature-explorer .fe-feature-idx {
    font-size: 12px;
    color: var(--fe-muted);
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  }

  .feature-explorer .fe-np-link {
    margin-left: auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: var(--fe-primary);
    text-decoration: none;
    opacity: 0.7;
    transition: opacity 0.15s;
    white-space: nowrap;
  }

  .feature-explorer .fe-np-link:hover {
    opacity: 1;
    text-decoration: underline;
  }

  .feature-explorer .fe-np-link svg {
    width: 12px;
    height: 12px;
    fill: currentColor;
  }

  /* Description */
  .feature-explorer .fe-description {
    font-size: 14px;
    line-height: 1.45;
    color: var(--fe-text);
    margin-bottom: 14px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .feature-explorer .fe-card.expanded .fe-description {
    -webkit-line-clamp: unset;
    overflow: visible;
  }

  /* Metrics row */
  .feature-explorer .fe-metrics {
    display: flex;
    gap: 16px;
    align-items: flex-end;
    flex-wrap: wrap;
  }

  .feature-explorer .fe-metric {
    flex: 1;
    min-width: 100px;
  }

  .feature-explorer .fe-metric-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.4px;
    color: var(--fe-muted);
    margin-bottom: 4px;
  }

  .feature-explorer .fe-metric-value {
    font-size: 15px;
    font-weight: 600;
    color: var(--fe-text);
    font-variant-numeric: tabular-nums;
  }

  /* Correlation bar */
  .feature-explorer .fe-corr-bar-bg {
    width: 100%;
    height: 6px;
    background: var(--fe-page-bg);
    border-radius: 3px;
    overflow: hidden;
    margin-top: 4px;
  }

  .feature-explorer .fe-corr-bar-fill {
    height: 100%;
    border-radius: 3px;
    background: linear-gradient(90deg, var(--fe-primary-light), var(--fe-primary));
    transition: width 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  /* Frequency mini stacked bar */
  .feature-explorer .fe-freq-bar-bg {
    display: flex;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    overflow: hidden;
    margin-top: 4px;
    background: var(--fe-page-bg);
  }

  .feature-explorer .fe-freq-correct {
    height: 100%;
    background: var(--fe-success);
    transition: width 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .feature-explorer .fe-freq-incorrect {
    height: 100%;
    background: var(--fe-negative);
    opacity: 0.6;
    transition: width 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .feature-explorer .fe-freq-text {
    font-size: 12px;
    color: var(--fe-muted);
    margin-top: 2px;
  }

  /* ---- Expanded details ---- */
  .feature-explorer .fe-expanded-details {
    display: none;
    margin-top: 16px;
    padding-top: 14px;
    border-top: 1px solid var(--fe-border);
  }

  .feature-explorer .fe-card.expanded .fe-expanded-details {
    display: block;
  }

  .feature-explorer .fe-detail-row {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }

  .feature-explorer .fe-detail-item {
    flex: 1;
    min-width: 140px;
  }

  .feature-explorer .fe-detail-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--fe-muted);
    margin-bottom: 2px;
  }

  .feature-explorer .fe-detail-value {
    font-size: 14px;
    font-weight: 500;
    color: var(--fe-text);
    font-variant-numeric: tabular-nums;
  }

  .feature-explorer .fe-coeff-compare {
    display: flex;
    gap: 2px;
    align-items: flex-end;
    height: 32px;
    margin-top: 4px;
  }

  .feature-explorer .fe-coeff-bar {
    flex: 1;
    border-radius: 3px 3px 0 0;
    position: relative;
    min-height: 4px;
    transition: height 0.4s ease;
  }

  .feature-explorer .fe-coeff-bar.success {
    background: var(--fe-success);
  }

  .feature-explorer .fe-coeff-bar.failure {
    background: var(--fe-negative);
    opacity: 0.6;
  }

  .feature-explorer .fe-coeff-labels {
    display: flex;
    gap: 2px;
    margin-top: 2px;
  }

  .feature-explorer .fe-coeff-label {
    flex: 1;
    font-size: 10px;
    color: var(--fe-muted);
    text-align: center;
  }

  .feature-explorer .fe-np-button {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 500;
    color: var(--fe-primary);
    background: rgba(107,92,231,0.08);
    text-decoration: none;
    transition: background 0.15s;
    border: none;
    cursor: pointer;
    font-family: inherit;
  }

  .feature-explorer .fe-np-button:hover {
    background: rgba(107,92,231,0.15);
  }

  .feature-explorer .fe-np-button svg {
    width: 14px;
    height: 14px;
    fill: currentColor;
  }

  /* ---- Loading state ---- */
  .feature-explorer .fe-loading {
    text-align: center;
    padding: 60px 20px;
    color: var(--fe-muted);
    font-size: 14px;
  }

  .feature-explorer .fe-spinner {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 2px solid var(--fe-border);
    border-top-color: var(--fe-primary);
    border-radius: 50%;
    animation: fe-spin 0.7s linear infinite;
    margin-bottom: 12px;
  }

  @keyframes fe-spin {
    to { transform: rotate(360deg); }
  }

  /* ---- Empty state ---- */
  .feature-explorer .fe-empty {
    text-align: center;
    padding: 40px 20px;
    color: var(--fe-muted);
    font-size: 14px;
    grid-column: 1 / -1;
  }

  /* ---- Negative polarity styling ---- */
  .feature-explorer[data-polarity="negative"] .fe-layer-badge {
    background: var(--fe-negative);
  }

  .feature-explorer[data-polarity="negative"] .fe-corr-bar-fill {
    background: linear-gradient(90deg, #F08090, var(--fe-negative));
  }

  .feature-explorer[data-polarity="negative"] .fe-np-link {
    color: var(--fe-negative);
  }
</style>
<script>
(() => {
  // Prevent multiple initializations
  if (window.__feExplorerInit) return;
  window.__feExplorerInit = true;

  const ensureD3 = (cb) => {
    if (window.d3 && typeof window.d3.select === 'function') return cb();
    let s = document.getElementById('d3-cdn-script');
    if (!s) {
      s = document.createElement('script');
      s.id = 'd3-cdn-script';
      s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
      document.head.appendChild(s);
    }
    const check = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
    s.addEventListener('load', check, { once: true });
    if (window.d3) check();
  };

  const bootstrap = () => {
    const scriptEl = document.currentScript;
    let container = scriptEl ? scriptEl.previousElementSibling : null;
    if (!(container && container.classList && container.classList.contains('feature-explorer'))) {
      const cs = Array.from(document.querySelectorAll('.feature-explorer'))
        .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
      container = cs[cs.length - 1] || null;
    }
    if (!container) return;
    if (container.dataset) {
      if (container.dataset.mounted === 'true') return;
      container.dataset.mounted = 'true';
    }

    // Show loading
    container.innerHTML = '<div class="fe-loading"><div class="fe-spinner"></div><div>Loading feature data...</div></div>';

    // Data paths
    const DATA_PATHS = {
      gemma: [
        '/data/features_gemma_all.json',
        '../assets/data/features_gemma_all.json',
        './data/features_gemma_all.json'
      ],
      llama: [
        '/data/features_llama_all.json',
        '../assets/data/features_llama_all.json',
        './data/features_llama_all.json'
      ]
    };

    const TASK_LABELS = {
      mmlu: 'MMLU',
      mmlupro: 'MMLU-Pro',
      simpleqa: 'SimpleQA',
      bbq_ambig: 'BBQ (Ambig)',
      bbq_disambig: 'BBQ (Disambig)',
      harmbench: 'HarmBench',
      xstest: 'XSTest',
      gsm8k: 'GSM8K'
    };

    const SORT_MODES = {
      correlation: 'By Correlation',
      coefficient: 'By Coefficient',
      layer: 'By Layer'
    };

    const EXTERNAL_ICON = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M6.22 8.72a.75.75 0 001.06 1.06l5.22-5.22v1.69a.75.75 0 001.5 0V3a.75.75 0 00-.75-.75h-3.25a.75.75 0 000 1.5h1.69L6.22 8.72zM3.5 6.75c0-.69.56-1.25 1.25-1.25H7A.75.75 0 007 4H4.75A2.75 2.75 0 002 6.75v4.5A2.75 2.75 0 004.75 14h4.5A2.75 2.75 0 0012 11.25V9a.75.75 0 00-1.5 0v2.25c0 .69-.56 1.25-1.25 1.25h-4.5c-.69 0-1.25-.56-1.25-1.25v-4.5z"/></svg>';

    // State
    let state = {
      model: 'gemma',
      task: 'mmlu',
      sort: 'correlation',
      polarity: 'positive',
      expandedCard: null
    };
    let dataCache = {};

    // Fetch with fallback
    async function fetchJSON(paths) {
      for (const p of paths) {
        try {
          const r = await fetch(p, { cache: 'no-cache' });
          if (r.ok) return await r.json();
        } catch(e) { /* try next */ }
      }
      return null;
    }

    // Load data for a model
    async function loadModel(key) {
      if (dataCache[key]) return dataCache[key];
      const data = await fetchJSON(DATA_PATHS[key]);
      if (data) dataCache[key] = data;
      return data;
    }

    // Extract top feature per layer for current task
    function getFeatures(data) {
      if (!data || !data.tasks || !data.tasks[state.task]) return [];
      const taskData = data.tasks[state.task];
      if (!taskData.layers) return [];

      const features = [];
      const layers = Object.keys(taskData.layers).sort((a, b) => parseInt(a) - parseInt(b));

      for (const layerKey of layers) {
        const layerData = taskData.layers[layerKey];
        const arr = layerData[state.polarity];
        if (!arr || arr.length === 0) continue;
        // Top feature (first one, already sorted by correlation in data)
        const feat = arr[0];
        features.push({
          layer: parseInt(layerKey),
          ...feat
        });
      }

      return features;
    }

    // Sort features
    function sortFeatures(features) {
      const copy = [...features];
      switch (state.sort) {
        case 'correlation':
          copy.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
          break;
        case 'coefficient':
          copy.sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient));
          break;
        case 'layer':
          copy.sort((a, b) => a.layer - b.layer);
          break;
      }
      return copy;
    }

    // Build UI
    function buildUI() {
      container.innerHTML = '';

      // Controls bar
      const controls = document.createElement('div');
      controls.className = 'fe-controls';

      // Model toggle
      const modelGroup = document.createElement('div');
      modelGroup.className = 'fe-control-group';
      modelGroup.innerHTML = '<div class="fe-control-label">Model</div>';
      const modelSeg = document.createElement('div');
      modelSeg.className = 'fe-segmented';
      ['gemma', 'llama'].forEach(m => {
        const btn = document.createElement('button');
        btn.className = 'fe-seg-btn' + (state.model === m ? ' active' : '');
        btn.textContent = m === 'gemma' ? 'Gemma-2 2B' : 'LLaMA-3.1 8B';
        btn.addEventListener('click', () => { state.model = m; state.expandedCard = null; render(); });
        modelSeg.appendChild(btn);
      });
      modelGroup.appendChild(modelSeg);
      controls.appendChild(modelGroup);

      // Polarity toggle
      const polGroup = document.createElement('div');
      polGroup.className = 'fe-control-group';
      polGroup.innerHTML = '<div class="fe-control-label">Direction</div>';
      const polSeg = document.createElement('div');
      polSeg.className = 'fe-segmented';
      [['positive', 'Positive'], ['negative', 'Negative']].forEach(([val, label]) => {
        const btn = document.createElement('button');
        btn.className = 'fe-seg-btn polarity-' + (val === 'positive' ? 'pos' : 'neg') + (state.polarity === val ? ' active' : '');
        btn.textContent = label;
        btn.addEventListener('click', () => { state.polarity = val; state.expandedCard = null; render(); });
        polSeg.appendChild(btn);
      });
      polGroup.appendChild(polSeg);
      controls.appendChild(polGroup);

      // Task dropdown
      const taskGroup = document.createElement('div');
      taskGroup.className = 'fe-control-group';
      taskGroup.innerHTML = '<div class="fe-control-label">Task</div>';
      const taskSelect = document.createElement('select');
      Object.keys(TASK_LABELS).forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = TASK_LABELS[t];
        opt.selected = state.task === t;
        taskSelect.appendChild(opt);
      });
      taskSelect.addEventListener('change', (e) => { state.task = e.target.value; state.expandedCard = null; render(); });
      taskGroup.appendChild(taskSelect);
      controls.appendChild(taskGroup);

      // Sort dropdown
      const sortGroup = document.createElement('div');
      sortGroup.className = 'fe-control-group';
      sortGroup.innerHTML = '<div class="fe-control-label">Sort</div>';
      const sortSelect = document.createElement('select');
      Object.keys(SORT_MODES).forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = SORT_MODES[s];
        opt.selected = state.sort === s;
        sortSelect.appendChild(opt);
      });
      sortSelect.addEventListener('change', (e) => { state.sort = e.target.value; render(); });
      sortGroup.appendChild(sortSelect);
      controls.appendChild(sortGroup);

      container.appendChild(controls);

      // Summary strip
      const summary = document.createElement('div');
      summary.className = 'fe-summary';
      container.appendChild(summary);

      // Grid
      const grid = document.createElement('div');
      grid.className = 'fe-grid';
      container.appendChild(grid);
    }

    // Render cards
    async function render() {
      const grid = container.querySelector('.fe-grid');
      const summary = container.querySelector('.fe-summary');
      if (!grid || !summary) return;

      // Update polarity attribute for styling
      container.setAttribute('data-polarity', state.polarity);

      // Update active states in controls
      container.querySelectorAll('.fe-segmented').forEach((seg, idx) => {
        seg.querySelectorAll('.fe-seg-btn').forEach(btn => btn.classList.remove('active'));
      });
      const modelBtns = container.querySelectorAll('.fe-segmented')[0];
      if (modelBtns) {
        modelBtns.children[state.model === 'gemma' ? 0 : 1].classList.add('active');
      }
      const polBtns = container.querySelectorAll('.fe-segmented')[1];
      if (polBtns) {
        polBtns.children[state.polarity === 'positive' ? 0 : 1].classList.add('active');
      }

      // Disable unavailable tasks
      const taskSelect = container.querySelector('select');
      if (taskSelect) {
        taskSelect.value = state.task;
      }

      // Fade out existing cards
      const existingCards = grid.querySelectorAll('.fe-card');
      existingCards.forEach(card => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(8px)';
      });

      // Load data
      const data = await loadModel(state.model);
      if (!data) {
        grid.innerHTML = '<div class="fe-empty">Failed to load feature data. Please check that the data files are available.</div>';
        summary.innerHTML = '';
        return;
      }

      // Check if task exists for this model
      if (!data.tasks[state.task]) {
        // Disable options that don't exist
        if (taskSelect) {
          Array.from(taskSelect.options).forEach(opt => {
            opt.disabled = !data.tasks[opt.value];
          });
        }
        grid.innerHTML = '<div class="fe-empty">This task is not available for the selected model.</div>';
        summary.innerHTML = '';
        return;
      }

      // Enable all valid options
      if (taskSelect) {
        Array.from(taskSelect.options).forEach(opt => {
          opt.disabled = !data.tasks[opt.value];
        });
      }

      const features = getFeatures(data);
      const sorted = sortFeatures(features);

      // Compute max values for scaling
      const maxCorr = Math.max(...sorted.map(f => Math.abs(f.correlation)), 0.001);
      const maxCoeff = Math.max(...sorted.map(f => Math.abs(f.coefficient)), 0.001);

      // Update summary
      summary.innerHTML = `<span>Showing <strong>${sorted.length}</strong> layers</span><span>Top ${state.polarity} feature per layer</span><span>Model: <strong>${data.model}</strong></span>`;

      // Small delay for fade-out, then rebuild
      await new Promise(r => setTimeout(r, 150));
      grid.innerHTML = '';

      if (sorted.length === 0) {
        grid.innerHTML = '<div class="fe-empty">No features found for this selection.</div>';
        return;
      }

      // Create cards
      sorted.forEach((feat, idx) => {
        const card = document.createElement('div');
        card.className = 'fe-card fe-card-entering';
        const cardId = `${feat.layer}-${feat.feature_index}`;

        if (state.expandedCard === cardId) {
          card.classList.add('expanded');
        }

        // Frequency values
        const freqCorrect = feat.stats ? (feat.stats.freq_correct || 0) : 0;
        const freqIncorrect = feat.stats ? (feat.stats.freq_incorrect || 0) : 0;
        const freqTotal = freqCorrect + freqIncorrect || 1;
        const freqCorrectPct = (freqCorrect / freqTotal * 100).toFixed(0);
        const freqIncorrectPct = (freqIncorrect / freqTotal * 100).toFixed(0);

        // Coefficient success/failure
        const coeffSuccess = feat.stats ? (feat.stats.coeff_success || 0) : 0;
        const coeffFailure = feat.stats ? (feat.stats.coeff_failure || 0) : 0;
        const coeffMax = Math.max(Math.abs(coeffSuccess), Math.abs(coeffFailure), 0.001);
        const coeffSuccessH = Math.max(4, Math.abs(coeffSuccess) / coeffMax * 28);
        const coeffFailureH = Math.max(4, Math.abs(coeffFailure) / coeffMax * 28);

        // Correlation bar width
        const corrPct = (Math.abs(feat.correlation) / maxCorr * 100).toFixed(1);

        // Description
        const desc = feat.description || 'No description available';
        const hasDesc = desc !== 'No description available';

        card.innerHTML = `
          <div class="fe-card-header">
            <span class="fe-layer-badge">Layer ${feat.layer}</span>
            <span class="fe-feature-idx">#${feat.feature_index}</span>
            <a class="fe-np-link" href="${feat.neuronpedia_url || '#'}" target="_blank" rel="noopener" onclick="event.stopPropagation()" title="View on Neuronpedia">
              ${EXTERNAL_ICON} Neuronpedia
            </a>
          </div>
          <div class="fe-description" style="${hasDesc ? '' : 'font-style:italic;color:var(--fe-muted);'}">${desc}</div>
          <div class="fe-metrics">
            <div class="fe-metric">
              <div class="fe-metric-label">Correlation</div>
              <div class="fe-metric-value">${feat.correlation.toFixed(4)}</div>
              <div class="fe-corr-bar-bg"><div class="fe-corr-bar-fill" style="width: 0%"></div></div>
            </div>
            <div class="fe-metric">
              <div class="fe-metric-label">Coefficient</div>
              <div class="fe-metric-value">${Math.abs(feat.coefficient).toFixed(3)}</div>
            </div>
            <div class="fe-metric" style="min-width:130px">
              <div class="fe-metric-label">Frequency</div>
              <div class="fe-freq-text">${freqCorrect.toFixed(0)} correct / ${freqIncorrect.toFixed(0)} incorrect</div>
              <div class="fe-freq-bar-bg">
                <div class="fe-freq-correct" style="width: 0%"></div>
                <div class="fe-freq-incorrect" style="width: 0%"></div>
              </div>
            </div>
          </div>
          <div class="fe-expanded-details">
            <div class="fe-detail-row">
              <div class="fe-detail-item">
                <div class="fe-detail-label">Coeff (Success vs Failure)</div>
                <div class="fe-coeff-compare">
                  <div class="fe-coeff-bar success" style="height: 0px"></div>
                  <div class="fe-coeff-bar failure" style="height: 0px"></div>
                </div>
                <div class="fe-coeff-labels">
                  <div class="fe-coeff-label">${coeffSuccess.toFixed(3)}</div>
                  <div class="fe-coeff-label">${coeffFailure.toFixed(3)}</div>
                </div>
              </div>
              <div class="fe-detail-item">
                <div class="fe-detail-label">Overall Frequency</div>
                <div class="fe-detail-value">${feat.frequency != null ? feat.frequency.toFixed(1) + '%' : 'N/A'}</div>
              </div>
              <div class="fe-detail-item">
                <div class="fe-detail-label">Layer Position</div>
                <div class="fe-detail-value">Layer ${feat.layer} of ${state.model === 'gemma' ? '25' : '31'}</div>
              </div>
            </div>
            <a class="fe-np-button" href="${feat.neuronpedia_url || '#'}" target="_blank" rel="noopener" onclick="event.stopPropagation()">
              ${EXTERNAL_ICON} View full feature on Neuronpedia
            </a>
          </div>
        `;

        card.addEventListener('click', (e) => {
          // Don't toggle if clicking links
          if (e.target.closest('a')) return;
          const wasExpanded = card.classList.contains('expanded');
          // Collapse all
          grid.querySelectorAll('.fe-card.expanded').forEach(c => c.classList.remove('expanded'));
          state.expandedCard = null;
          if (!wasExpanded) {
            card.classList.add('expanded');
            state.expandedCard = cardId;
            // Animate coefficient bars
            requestAnimationFrame(() => {
              const bars = card.querySelectorAll('.fe-coeff-bar');
              if (bars[0]) bars[0].style.height = coeffSuccessH + 'px';
              if (bars[1]) bars[1].style.height = coeffFailureH + 'px';
            });
          }
        });

        grid.appendChild(card);

        // Staggered entrance animation
        requestAnimationFrame(() => {
          setTimeout(() => {
            card.classList.remove('fe-card-entering');
            card.classList.add('fe-card-visible');
            card.style.transition = `opacity 0.3s ease ${idx * 30}ms, transform 0.3s ease ${idx * 30}ms, box-shadow 0.2s ease`;

            // Animate bars
            const corrFill = card.querySelector('.fe-corr-bar-fill');
            if (corrFill) {
              setTimeout(() => { corrFill.style.width = corrPct + '%'; }, idx * 30 + 100);
            }
            const freqC = card.querySelector('.fe-freq-correct');
            const freqI = card.querySelector('.fe-freq-incorrect');
            if (freqC) {
              setTimeout(() => { freqC.style.width = freqCorrectPct + '%'; }, idx * 30 + 100);
            }
            if (freqI) {
              setTimeout(() => { freqI.style.width = freqIncorrectPct + '%'; }, idx * 30 + 100);
            }

            // If expanded on load, animate coeff bars
            if (state.expandedCard === cardId) {
              setTimeout(() => {
                const bars = card.querySelectorAll('.fe-coeff-bar');
                if (bars[0]) bars[0].style.height = coeffSuccessH + 'px';
                if (bars[1]) bars[1].style.height = coeffFailureH + 'px';
              }, idx * 30 + 200);
            }
          }, 10);
        });
      });
    }

    // Initialize
    ensureD3(async () => {
      // Pre-load both datasets in parallel
      const [gemmaData, llamaData] = await Promise.all([
        loadModel('gemma'),
        loadModel('llama')
      ]);

      if (!gemmaData && !llamaData) {
        container.innerHTML = '<div class="fe-loading" style="color:var(--fe-negative)">Failed to load feature data. Ensure the JSON files are in the data directory.</div>';
        return;
      }

      // If gemma not available, default to llama
      if (!gemmaData && llamaData) {
        state.model = 'llama';
      }

      buildUI();
      render();
    });
  };

  // Execute
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrap);
  } else {
    bootstrap();
  }
})();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Browse selected features by task and model. Click a feature card to see full details and Neuronpedia link.</figcaption></figure> </div>
<h2 id="results"><a href="#results">Results</a></h2>
<p>We evaluate on 8 benchmarks across 5 categories: knowledge (MMLU, MMLU-Pro), reasoning (GSM8K), bias (BBQ), factuality (SimpleQA), and safety (HarmBench, XSTest).</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Performance Comparison</figcaption><div class="html-embed__card"><div id="frag-hq57eji3wvu" data-datafiles="accuracy_results_full.json"><div class="d3-performance-dashboard"></div>
<style>
  .d3-performance-dashboard {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .d3-performance-dashboard svg {
    display: block;
    width: 100%;
  }

  .d3-performance-dashboard .axes path,
  .d3-performance-dashboard .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .d3-performance-dashboard .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }

  .d3-performance-dashboard .grid line {
    stroke: var(--grid-color, rgba(0, 0, 0, .08));
    stroke-dasharray: 3, 3;
  }

  .d3-performance-dashboard .grid path {
    display: none;
  }

  .d3-performance-dashboard .bar-rect {
    transition: opacity 0.18s ease;
    cursor: pointer;
  }

  .d3-performance-dashboard .error-bar {
    stroke-width: 1.2;
    pointer-events: none;
  }

  .d3-performance-dashboard .error-cap {
    stroke-width: 1.2;
    pointer-events: none;
  }

  .d3-performance-dashboard .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-performance-dashboard .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
    z-index: 10;
    max-width: 260px;
  }

  .d3-performance-dashboard .d3-tooltip__inner {
    text-align: left;
  }

  .d3-performance-dashboard .d3-tooltip__inner .tt-method {
    font-weight: 700;
    margin-bottom: 2px;
  }

  .d3-performance-dashboard .d3-tooltip__inner .tt-task {
    font-size: 11px;
    color: var(--muted-color);
    margin-bottom: 4px;
  }

  .d3-performance-dashboard .d3-tooltip__inner .tt-value {
    font-size: 13px;
    font-weight: 600;
  }

  .d3-performance-dashboard .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
    margin-top: 12px;
  }

  .d3-performance-dashboard .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-performance-dashboard .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 6px 16px;
  }

  .d3-performance-dashboard .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    user-select: none;
    transition: opacity 0.18s ease;
  }

  .d3-performance-dashboard .legend .item.disabled {
    opacity: 0.35;
  }

  .d3-performance-dashboard .legend .item.disabled .swatch {
    background: var(--muted-color, #999) !important;
  }

  .d3-performance-dashboard .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    flex-shrink: 0;
    transition: background 0.18s ease;
  }

  .d3-performance-dashboard .legend .item input[type="checkbox"] {
    display: none;
  }

  .d3-performance-dashboard .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  .d3-performance-dashboard .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-performance-dashboard .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-performance-dashboard .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3' fill='none' stroke='%23999' stroke-width='1.5'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    cursor: pointer;
    min-width: 140px;
  }

  .d3-performance-dashboard .controls select:focus {
    outline: 2px solid var(--primary-color, #6B5CE7);
    outline-offset: 1px;
  }

  .d3-performance-dashboard .no-data-msg {
    fill: var(--muted-color);
    font-size: 10px;
    font-style: italic;
  }

  @media (max-width: 600px) {
    .d3-performance-dashboard .legend .items {
      gap: 4px 10px;
    }
    .d3-performance-dashboard .legend .item {
      font-size: 11px;
    }
    .d3-performance-dashboard .legend .swatch {
      width: 12px;
      height: 12px;
    }
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-performance-dashboard'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-performance-dashboard'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // --- Tooltip ---
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const rect = container.getBoundingClientRect();
        const [mx, my] = d3.pointer(event, container);
        const tipW = tip.offsetWidth || 200;
        const tipH = tip.offsetHeight || 80;
        let tx = mx + 14;
        let ty = my - 14;
        if (tx + tipW > rect.width) tx = mx - tipW - 14;
        if (ty < 0) ty = my + 14;
        if (ty + tipH > rect.height) ty = rect.height - tipH - 4;
        tip.style.transform = `translate(${tx}px, ${ty}px)`;
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // --- Task definitions ---
      const TASKS = [
        { key: 'mmlu', label: 'MMLU' },
        { key: 'mmlupro', label: 'MMLU-Pro' },
        { key: 'simpleqa', label: 'SimpleQA' },
        { key: 'bbq_ambig', label: 'BBQ Ambig' },
        { key: 'bbq_disambig', label: 'BBQ Disambig' },
        { key: 'harmbench', label: 'HarmBench' },
        { key: 'xstest', label: 'XSTest' },
        { key: 'gsm8k', label: 'GSM8K' }
      ];

      // --- Method ordering and colors ---
      const METHOD_ORDER = [
        'Non-steered',
        'CorrSteer-S',
        'CorrSteer-P',
        'CorrSteer-A',
        'Fine-tuning',
        'SPARE (MI)',
        'DSG (Fisher)',
        'CAA'
      ];

      const METHOD_COLORS = {
        'CorrSteer-S': '#4EA5B7',
        'CorrSteer-P': '#9B59B6',
        'CorrSteer-A': '#6B5CE7',
        'Non-steered': '#999999',
        'Fine-tuning': '#E15759',
        'SPARE (MI)': '#E38A42',
        'DSG (Fisher)': '#59A14F',
        'CAA': '#CEC0FA'
      };

      function getMethodColor(method) {
        return METHOD_COLORS[method] || '#888';
      }

      // --- SVG scaffolding ---
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gErrors = gRoot.append('g').attr('class', 'errors');

      let width = 800, height = 420;
      const margin = { top: 24, right: 20, bottom: 72, left: 52 };

      // --- State ---
      let rawData = [];
      let enabledMethods = new Set(METHOD_ORDER);
      let currentModel = 'gemma2b';

      // --- Controls: Model selector ---
      const controls = document.createElement('div');
      controls.className = 'controls';
      const modelGroup = document.createElement('div');
      modelGroup.className = 'control-group';
      const modelLabel = document.createElement('label');
      modelLabel.setAttribute('for', 'perf-dash-model-select');
      modelLabel.textContent = 'Model';
      const modelSelect = document.createElement('select');
      modelSelect.id = 'perf-dash-model-select';
      modelGroup.appendChild(modelLabel);
      modelGroup.appendChild(modelSelect);
      controls.appendChild(modelGroup);
      container.appendChild(controls);

      // --- Legend ---
      const legend = document.createElement('div');
      legend.className = 'legend';
      const legendTitle = document.createElement('div');
      legendTitle.className = 'legend-title';
      legendTitle.textContent = 'Legend';
      legend.appendChild(legendTitle);
      const legendItems = document.createElement('div');
      legendItems.className = 'items';
      legend.appendChild(legendItems);
      container.appendChild(legend);

      function buildLegend(methods) {
        legendItems.innerHTML = '';
        methods.forEach(method => {
          const item = document.createElement('span');
          item.className = 'item' + (enabledMethods.has(method) ? '' : ' disabled');
          item.setAttribute('data-method', method);

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = enabledMethods.has(method);

          const swatch = document.createElement('span');
          swatch.className = 'swatch';
          swatch.style.background = enabledMethods.has(method) ? getMethodColor(method) : '';

          const txt = document.createElement('span');
          txt.textContent = method;

          item.appendChild(cb);
          item.appendChild(swatch);
          item.appendChild(txt);

          item.addEventListener('click', () => {
            if (enabledMethods.has(method)) {
              if (enabledMethods.size <= 1) return;
              enabledMethods.delete(method);
            } else {
              enabledMethods.add(method);
            }
            item.classList.toggle('disabled', !enabledMethods.has(method));
            cb.checked = enabledMethods.has(method);
            swatch.style.background = enabledMethods.has(method) ? getMethodColor(method) : '';
            render();
          });

          legendItems.appendChild(item);
        });
      }

      // --- Data loading ---
      const JSON_PATHS = [
        '/data/accuracy_results_full.json',
        './assets/data/accuracy_results_full.json',
        '../assets/data/accuracy_results_full.json',
        '../../assets/data/accuracy_results_full.json'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.json();
          } catch (e) { }
        }
        throw new Error('JSON not found');
      };

      // --- Size update ---
      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(340, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      // --- Rounded top bar path ---
      function roundedTopBar(x, y, w, h, r) {
        if (h <= 0) return '';
        r = Math.min(r, h / 2, w / 2);
        return `M${x},${y + h}L${x},${y + r}Q${x},${y} ${x + r},${y}L${x + w - r},${y}Q${x + w},${y} ${x + w},${y + r}L${x + w},${y + h}Z`;
      }

      // --- Main render ---
      function render() {
        const { innerWidth, innerHeight } = updateSize();

        // Filter data by current model
        const modelData = rawData.filter(d => d.model === currentModel);
        const availableMethods = METHOD_ORDER.filter(m => modelData.some(d => d.method === m));
        const visibleMethods = availableMethods.filter(m => enabledMethods.has(m));

        // Build legend for available methods
        buildLegend(availableMethods);

        // Clear previous
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();
        gBars.selectAll('*').remove();
        gErrors.selectAll('*').remove();

        if (visibleMethods.length === 0) return;

        // Scales
        const taskLabels = TASKS.map(t => t.label);
        const x0 = d3.scaleBand()
          .domain(taskLabels)
          .range([0, innerWidth])
          .paddingInner(0.2)
          .paddingOuter(0.1);

        const x1 = d3.scaleBand()
          .domain(visibleMethods)
          .range([0, x0.bandwidth()])
          .padding(0.08);

        // Compute y domain from visible data
        let yMax = 0;
        TASKS.forEach(task => {
          visibleMethods.forEach(method => {
            const row = modelData.find(d => d.method === method);
            if (row && row[task.key] != null) {
              const val = row[task.key] + (row[task.key + '_std'] || 0);
              if (val > yMax) yMax = val;
            }
          });
        });
        yMax = Math.min(100, Math.ceil(yMax / 10) * 10 + 5);

        const y = d3.scaleLinear()
          .domain([0, yMax])
          .range([innerHeight, 0])
          .nice();

        // --- Grid ---
        gGrid.selectAll('line')
          .data(y.ticks(6))
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => y(d))
          .attr('y2', d => y(d));

        // --- X Axis ---
        const xAxisG = gAxes.append('g')
          .attr('transform', `translate(0,${innerHeight})`);

        xAxisG.call(d3.axisBottom(x0).tickSize(0).tickPadding(10));
        xAxisG.select('.domain').remove();

        // Rotate labels if narrow
        if (x0.bandwidth() < 70) {
          xAxisG.selectAll('text')
            .attr('transform', 'rotate(-35)')
            .style('text-anchor', 'end')
            .attr('dx', '-0.6em')
            .attr('dy', '0.4em');
        }

        // --- Y Axis ---
        const yAxisG = gAxes.append('g');
        yAxisG.call(d3.axisLeft(y).ticks(6).tickSize(-innerWidth));
        yAxisG.select('.domain').remove();
        yAxisG.selectAll('.tick line')
          .attr('stroke', 'none');

        // Y axis label
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -40)
          .attr('text-anchor', 'middle')
          .text('Accuracy (%)');

        // --- Bars ---
        const barDuration = 400;

        TASKS.forEach(task => {
          const taskGroup = gBars.append('g')
            .attr('transform', `translate(${x0(task.label)},0)`);

          visibleMethods.forEach(method => {
            const row = modelData.find(d => d.method === method);
            const val = row && row[task.key] != null ? row[task.key] : null;
            const std = row && row[task.key + '_std'] != null ? row[task.key + '_std'] : 0;

            const bx = x1(method);
            const bw = x1.bandwidth();
            const barRadius = Math.min(3, bw / 4);

            if (val === null) {
              // Show "N/A" indicator
              taskGroup.append('text')
                .attr('class', 'no-data-msg')
                .attr('x', bx + bw / 2)
                .attr('y', innerHeight - 4)
                .attr('text-anchor', 'middle')
                .text('N/A');
              return;
            }

            const by = y(val);
            const bh = innerHeight - by;

            // Bar path with rounded top
            const bar = taskGroup.append('path')
              .attr('class', 'bar-rect')
              .attr('fill', getMethodColor(method))
              .attr('data-method', method)
              .attr('data-task', task.key);

            // Animate from zero
            bar.attr('d', roundedTopBar(bx, innerHeight, bw, 0, barRadius))
              .transition()
              .duration(barDuration)
              .ease(d3.easeCubicOut)
              .attr('d', roundedTopBar(bx, by, bw, bh, barRadius));

            // Error bar
            if (std > 0) {
              const errGroup = gErrors.append('g')
                .attr('transform', `translate(${x0(task.label)},0)`)
                .style('opacity', 0);

              const cx = bx + bw / 2;
              const capW = Math.min(bw * 0.4, 6);
              const errTop = y(val + std);
              const errBot = y(Math.max(0, val - std));
              const errColor = getMethodColor(method);

              // Vertical line
              errGroup.append('line')
                .attr('class', 'error-bar')
                .attr('x1', cx).attr('x2', cx)
                .attr('y1', errTop).attr('y2', errBot)
                .attr('stroke', errColor);

              // Top cap
              errGroup.append('line')
                .attr('class', 'error-cap')
                .attr('x1', cx - capW).attr('x2', cx + capW)
                .attr('y1', errTop).attr('y2', errTop)
                .attr('stroke', errColor);

              // Bottom cap
              errGroup.append('line')
                .attr('class', 'error-cap')
                .attr('x1', cx - capW).attr('x2', cx + capW)
                .attr('y1', errBot).attr('y2', errBot)
                .attr('stroke', errColor);

              // Fade in after bar animation
              errGroup.transition()
                .delay(barDuration * 0.6)
                .duration(200)
                .style('opacity', 1);
            }

            // Hover interaction
            bar.on('mouseenter', function (event) {
              // Dim other bars
              gBars.selectAll('.bar-rect')
                .transition().duration(100)
                .style('opacity', function () {
                  return this.getAttribute('data-method') === method ? 1 : 0.25;
                });

              const html = `
                <div class="tt-method" style="color:${getMethodColor(method)}">${method}</div>
                <div class="tt-task">${task.label}</div>
                <div class="tt-value">${val.toFixed(2)}${std > 0 ? ' &plusmn; ' + std.toFixed(2) : ''}</div>
              `;
              showTooltip(html, event);
            })
            .on('mousemove', function (event) {
              const html = `
                <div class="tt-method" style="color:${getMethodColor(method)}">${method}</div>
                <div class="tt-task">${task.label}</div>
                <div class="tt-value">${val.toFixed(2)}${std > 0 ? ' &plusmn; ' + std.toFixed(2) : ''}</div>
              `;
              showTooltip(html, event);
            })
            .on('mouseleave', function () {
              gBars.selectAll('.bar-rect')
                .transition().duration(150)
                .style('opacity', 1);
              hideTooltip();
            });
          });
        });
      }

      // --- Model name formatting ---
      function formatModelName(model) {
        const map = {
          'gemma2b': 'Gemma 2B',
          'gemma7b': 'Gemma 7B',
          'llama2_7b': 'Llama-2 7B',
          'llama2_13b': 'Llama-2 13B',
          'llama3_8b': 'Llama-3 8B',
          'mistral7b': 'Mistral 7B'
        };
        return map[model] || model;
      }

      // --- Init ---
      fetchFirstAvailable(JSON_PATHS)
        .then(data => {
          rawData = data;

          // Discover models
          const models = [...new Set(data.map(d => d.model))];
          if (models.length > 0) currentModel = models[0];

          // Populate model selector
          modelSelect.innerHTML = '';
          models.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m;
            opt.textContent = formatModelName(m);
            modelSelect.appendChild(opt);
          });
          modelSelect.value = currentModel;
          modelSelect.addEventListener('change', () => {
            currentModel = modelSelect.value;
            render();
          });

          // Hide model selector if only one model
          if (models.length <= 1) {
            controls.style.display = 'none';
          }

          // Initial render
          render();

          // Resize observer
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }

          // Theme change observer
          const observer = new MutationObserver(() => render());
          observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['data-theme']
          });
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color: #c0392b; padding: 12px; font-size: 13px;';
          pre.textContent = 'Failed to load data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Accuracy across all methods on Gemma-2 2B. Hover for exact values with standard deviations.</figcaption></figure> </div>
<div class="note note--success" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Key Finding</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>CorrSteer-A matches fine-tuning accuracy on MMLU (55.48% vs 55.75%) while <strong>halving the Side Effect Ratio</strong> (0.21 vs 0.41). On HarmBench, CorrSteer achieves +27.2% improvement in harmful request refusal.</p> </div> </div> </div> 
<h3 id="side-effect-trade-offs"><a href="#side-effect-trade-offs">Side Effect Trade-offs</a></h3>
<p>We introduce the <strong>Side Effect Ratio (SER)</strong>: the fraction of changed answers that become incorrect. Lower SER means the method changes answers more precisely, converting wrong answers to right without breaking correct ones.</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Side Effect Ratio Comparison</figcaption><div class="html-embed__card"><div id="frag-2hr2xbitnii" data-datafiles="ser_results.json"><div class="ser-comparison"></div>
<style>
  .ser-comparison {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .ser-comparison svg {
    display: block;
    width: 100%;
  }

  .ser-comparison .bar {
    cursor: pointer;
    transition: opacity 0.2s ease;
  }

  .ser-comparison.legend-filtering .bar.ghost {
    opacity: 0.1;
  }

  .ser-comparison .axes path {
    display: none;
  }

  .ser-comparison .axes line {
    stroke: var(--axis-color, #ccc);
  }

  .ser-comparison .axes text {
    fill: var(--tick-color, var(--muted-color, #6b6f80));
    font-size: 11px;
  }

  .ser-comparison .grid line {
    stroke: var(--grid-color, rgba(0, 0, 0, 0.06));
    stroke-width: 1;
  }

  .ser-comparison .grid path {
    display: none;
  }

  .ser-comparison .ref-line {
    stroke-dasharray: 6, 4;
    stroke-width: 1.5;
  }

  .ser-comparison .ref-label {
    font-size: 10px;
    font-weight: 600;
  }

  .ser-comparison .legend-bar {
    display: flex;
    justify-content: center;
    gap: 14px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .ser-comparison .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color, #1a1a2e);
    cursor: pointer;
    transition: opacity 0.2s ease;
    user-select: none;
    padding: 3px 0;
  }

  .ser-comparison .legend-item.hidden {
    opacity: 0.3;
  }

  .ser-comparison .legend-item.hidden .legend-swatch {
    background: var(--muted-color, #999) !important;
  }

  .ser-comparison .legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    transition: background 0.2s ease;
    flex-shrink: 0;
  }

  .ser-comparison .legend-text {
    white-space: nowrap;
  }

  .ser-comparison .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid var(--border-color, #e2e4ea);
    background: var(--surface-bg, #fff);
    color: var(--text-color, #1a1a2e);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 10;
    max-width: 220px;
  }

  .ser-comparison .d3-tooltip__inner {
    text-align: left;
  }

  .ser-comparison .d3-tooltip .tt-method {
    font-weight: 700;
    margin-bottom: 4px;
  }

  .ser-comparison .d3-tooltip .tt-row {
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }

  .ser-comparison .d3-tooltip .tt-label {
    color: var(--muted-color, #6b6f80);
  }

  .ser-comparison .d3-tooltip .tt-val {
    font-weight: 600;
  }

  .ser-comparison .lower-label {
    font-size: 11px;
    font-style: italic;
    fill: var(--muted-color, #6b6f80);
  }

  .ser-comparison .axis-title {
    font-size: 12px;
    font-weight: 700;
    fill: var(--text-color, #1a1a2e);
  }
</style>
<script>
  (() => {
    const DATA_PATHS = [
      '/data/ser_results.json',
      './assets/data/ser_results.json',
      '../assets/data/ser_results.json',
      '../../assets/data/ser_results.json',
      '../../../assets/data/ser_results.json'
    ];

    const METHOD_COLORS = {
      'CorrSteer-S': '#4EA5B7',
      'CorrSteer-P': '#9B59B6',
      'CorrSteer-A': '#6B5CE7',
      'SPARE (MI)': '#E38A42',
      'DSG (Fisher)': '#59A14F',
      'CAA': '#CEC0FA',
      'Fine-tuning': '#E15759'
    };

    const METHOD_ORDER = [
      'CorrSteer-S', 'CorrSteer-P', 'CorrSteer-A',
      'SPARE (MI)', 'DSG (Fisher)', 'CAA', 'Fine-tuning'
    ];

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const fetchFirstAvailable = async (paths) => {
      for (const p of paths) {
        try {
          const r = await fetch(p, { cache: 'no-cache' });
          if (r.ok) return await r.json();
        } catch (e) { }
      }
      throw new Error('Data not found');
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('ser-comparison'))) {
        const candidates = Array.from(document.querySelectorAll('.ser-comparison'))
          .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      container.style.position = container.style.position || 'relative';

      // Tooltip
      let tip = document.createElement('div');
      tip.className = 'd3-tooltip';
      let tipInner = document.createElement('div');
      tipInner.className = 'd3-tooltip__inner';
      tip.appendChild(tipInner);
      container.appendChild(tip);

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const rect = container.getBoundingClientRect();
        const mx = event.clientX - rect.left;
        const my = event.clientY - rect.top;
        // Prevent overflow right
        const tipWidth = tip.offsetWidth || 200;
        const maxX = rect.width - tipWidth - 10;
        const x = Math.min(mx + 14, maxX);
        tip.style.transform = `translate(${x}px, ${my - 14}px)`;
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // Legend
      const legendBar = document.createElement('div');
      legendBar.className = 'legend-bar';
      container.appendChild(legendBar);

      const hiddenMethods = new Set();

      METHOD_ORDER.forEach(m => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.dataset.method = m;
        item.innerHTML = `<div class="legend-swatch" style="background:${METHOD_COLORS[m] || '#888'}"></div><span class="legend-text">${m}</span>`;
        item.addEventListener('click', () => {
          if (hiddenMethods.has(m)) {
            hiddenMethods.delete(m);
            item.classList.remove('hidden');
          } else {
            hiddenMethods.add(m);
            item.classList.add('hidden');
          }
          render();
        });
        legendBar.appendChild(item);
      });

      // SVG
      const svg = d3.select(container).append('svg').style('display', 'block');
      const gRoot = svg.append('g');

      const margin = { top: 24, right: 16, bottom: 56, left: 52 };
      let rawData = [];

      const render = () => {
        const width = container.clientWidth || 700;
        const height = Math.max(340, Math.round(width * 0.5));
        svg.attr('width', width).attr('height', height);

        const innerW = width - margin.left - margin.right;
        const innerH = height - margin.top - margin.bottom;

        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        gRoot.selectAll('*').remove();

        // Determine tasks and visible methods
        const tasks = [...new Set(rawData.map(d => d.task))];
        const allMethods = [...new Set(rawData.map(d => d.method))];
        const orderedVisible = METHOD_ORDER.filter(m => allMethods.includes(m) && !hiddenMethods.has(m));
        // Include any methods from data not in METHOD_ORDER
        allMethods.forEach(m => {
          if (!METHOD_ORDER.includes(m) && !hiddenMethods.has(m) && !orderedVisible.includes(m)) {
            orderedVisible.push(m);
          }
        });

        // Scales
        const x0 = d3.scaleBand().domain(tasks).range([0, innerW]).paddingInner(0.2).paddingOuter(0.1);
        const x1 = d3.scaleBand().domain(orderedVisible).range([0, x0.bandwidth()]).padding(0.08);
        const y = d3.scaleLinear().domain([0, 1.0]).range([innerH, 0]);

        // Grid lines
        const grid = gRoot.append('g').attr('class', 'grid');
        grid.selectAll('line')
          .data(y.ticks(5))
          .enter().append('line')
          .attr('x1', 0).attr('x2', innerW)
          .attr('y1', d => y(d)).attr('y2', d => y(d));

        // Reference line at 0.5
        gRoot.append('line')
          .attr('class', 'ref-line')
          .attr('x1', 0).attr('x2', innerW)
          .attr('y1', y(0.5)).attr('y2', y(0.5))
          .attr('stroke', 'var(--muted-color, #999)');

        gRoot.append('text')
          .attr('class', 'ref-label')
          .attr('x', innerW + 4).attr('y', y(0.5) + 4)
          .attr('fill', 'var(--muted-color, #999)')
          .text('0.5');

        // X axis
        const xAxisG = gRoot.append('g').attr('class', 'axes')
          .attr('transform', `translate(0, ${innerH})`);
        xAxisG.call(d3.axisBottom(x0).tickSize(0).tickPadding(10));
        xAxisG.selectAll('text')
          .style('font-size', width < 500 ? '9px' : '11px');

        // Y axis
        const yAxisG = gRoot.append('g').attr('class', 'axes');
        yAxisG.call(d3.axisLeft(y).ticks(5).tickFormat(d3.format('.1f')).tickSize(-innerW));
        yAxisG.selectAll('.tick line')
          .attr('stroke', 'var(--grid-color, rgba(0,0,0,0.06))');

        // Y axis title
        gRoot.append('text')
          .attr('class', 'axis-title')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerH / 2).attr('y', -40)
          .attr('text-anchor', 'middle')
          .text('SER');

        // "Lower is better" indicator
        gRoot.append('text')
          .attr('class', 'lower-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerH + 10).attr('y', -40)
          .attr('text-anchor', 'start')
          .attr('dominant-baseline', 'central')
          .text('lower is better');

        // Arrow for "lower is better"
        gRoot.append('path')
          .attr('d', `M${-28},${innerH - 16} L${-28},${innerH - 4}`)
          .attr('stroke', 'var(--muted-color, #6b6f80)')
          .attr('stroke-width', 1.5)
          .attr('marker-end', 'none')
          .attr('fill', 'none');

        // Bars (grouped)
        const roundedTopBar = (x, yTop, w, h, r) => {
          if (h <= 0) return '';
          const rr = Math.min(r, h / 2, w / 2);
          return `M${x},${yTop + h} L${x},${yTop + rr} Q${x},${yTop} ${x + rr},${yTop} L${x + w - rr},${yTop} Q${x + w},${yTop} ${x + w},${yTop + rr} L${x + w},${yTop + h} Z`;
        };

        const taskGroups = gRoot.selectAll('.task-group')
          .data(tasks).enter().append('g')
          .attr('class', 'task-group')
          .attr('transform', d => `translate(${x0(d)}, 0)`);

        taskGroups.each(function(task) {
          const group = d3.select(this);
          const taskData = rawData.filter(d => d.task === task);

          orderedVisible.forEach(method => {
            const d = taskData.find(r => r.method === method);
            if (!d) return;

            const barX = x1(method);
            const barW = x1.bandwidth();
            const barH = innerH - y(d.ser);
            const barY = y(d.ser);

            group.append('path')
              .attr('class', 'bar')
              .attr('data-method', method)
              .attr('d', roundedTopBar(barX, barY, barW, barH, 2))
              .attr('fill', METHOD_COLORS[method] || '#888')
              .on('mouseenter', function(event) {
                container.classList.add('legend-filtering');
                container.querySelectorAll('.bar').forEach(b => {
                  if (b.getAttribute('data-method') !== method) b.classList.add('ghost');
                });
                const html = `
                  <div class="tt-method" style="color:${METHOD_COLORS[method] || '#888'}">${method}</div>
                  <div style="font-size:11px;color:var(--muted-color,#888);margin-bottom:4px">${task}</div>
                  <div class="tt-row"><span class="tt-label">SER</span><span class="tt-val">${d.ser.toFixed(2)}</span></div>
                  <div class="tt-row"><span class="tt-label">NEG</span><span class="tt-val">${d.neg}</span></div>
                  <div class="tt-row"><span class="tt-label">POS</span><span class="tt-val">${d.pos}</span></div>
                `;
                showTooltip(html, event);
              })
              .on('mousemove', function(event) {
                const rect = container.getBoundingClientRect();
                const mx = event.clientX - rect.left;
                const my = event.clientY - rect.top;
                const tipWidth = tip.offsetWidth || 200;
                const maxX = rect.width - tipWidth - 10;
                const x = Math.min(mx + 14, maxX);
                tip.style.transform = `translate(${x}px, ${my - 14}px)`;
              })
              .on('mouseleave', function() {
                container.classList.remove('legend-filtering');
                container.querySelectorAll('.bar').forEach(b => b.classList.remove('ghost'));
                hideTooltip();
              });
          });
        });
      };

      fetchFirstAvailable(DATA_PATHS).then(data => {
        rawData = data;

        // Ensure legend includes all methods from data
        const allMethods = [...new Set(data.map(d => d.method))];
        allMethods.forEach(m => {
          if (!METHOD_ORDER.includes(m)) {
            METHOD_ORDER.push(m);
            if (!METHOD_COLORS[m]) METHOD_COLORS[m] = '#888';
            // Add legend item
            const item = document.createElement('div');
            item.className = 'legend-item';
            item.dataset.method = m;
            item.innerHTML = `<div class="legend-swatch" style="background:${METHOD_COLORS[m]}"></div><span class="legend-text">${m}</span>`;
            item.addEventListener('click', () => {
              if (hiddenMethods.has(m)) {
                hiddenMethods.delete(m);
                item.classList.remove('hidden');
              } else {
                hiddenMethods.add(m);
                item.classList.add('hidden');
              }
              render();
            });
            legendBar.appendChild(item);
          }
        });

        render();

        // Responsive
        let resizeTimer;
        const ro = new ResizeObserver(() => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(render, 80);
        });
        ro.observe(container);
      }).catch(err => {
        container.innerHTML = `<div style="text-align:center;padding:40px;font-size:13px;color:var(--muted-color,#888)">Could not load SER data: ${err.message}</div>`;
      });

      // Dark mode: listen for data-theme changes on <html>
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
            if (rawData.length > 0) render();
          }
        });
      });
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">SER across methods and tasks. CorrSteer variants achieve lower SER than fine-tuning and CAA on most tasks.</figcaption></figure> </div>
<p>On MMLU, CorrSteer-A changes 879 answers compared to fine-tuning’s 2,724, yet achieves comparable accuracy. CorrSteer-A outperforms CorrSteer-S on 5 of 8 tasks, indicating that multi-layer feature combinations produce gains beyond single-feature steering. Positive-only SAE methods (CorrSteer, SPARE, DSG) consistently show lower SER than fine-tuning, because sparse features provide targeted rather than global modifications.</p>
<h2 id="feature-interpretability"><a href="#feature-interpretability">Feature Interpretability</a></h2>
<p>The layer-by-layer distribution of top features reveals how different tasks engage different parts of the network:</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Layer x Task Feature Heatmap</figcaption><div class="html-embed__card"><div id="frag-d74u5n87sod" data-datafiles="feature_heatmap_data.json"><div class="feature-heatmap"></div>
<style>
  .feature-heatmap {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .feature-heatmap .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    margin-top: 12px;
  }

  .feature-heatmap .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .feature-heatmap .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .feature-heatmap .model-tabs {
    display: flex;
    gap: 0;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
  }

  .feature-heatmap .model-tab {
    padding: 7px 16px;
    font-size: 12px;
    font-weight: 600;
    color: var(--muted-color);
    background: var(--surface-bg);
    border: none;
    border-right: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    white-space: nowrap;
  }

  .feature-heatmap .model-tab:last-child {
    border-right: none;
  }

  .feature-heatmap .model-tab:hover {
    background: var(--page-bg);
  }

  .feature-heatmap .model-tab.active {
    background: #2563eb;
    color: #fff;
  }

  .feature-heatmap .axes path,
  .feature-heatmap .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .feature-heatmap .axes text {
    fill: var(--tick-color, var(--muted-color));
  }

  .feature-heatmap .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }

  /* Dark mode: ensure all text is visible */
  [data-theme="dark"] .feature-heatmap .axes text {
    fill: rgba(255, 255, 255, 0.7) !important;
  }
  [data-theme="dark"] .feature-heatmap .axis-label {
    fill: rgba(255, 255, 255, 0.9) !important;
  }
  [data-theme="dark"] .feature-heatmap .axes path,
  [data-theme="dark"] .feature-heatmap .axes line {
    stroke: rgba(255, 255, 255, 0.3) !important;
  }
  [data-theme="dark"] .feature-heatmap .controls label {
    color: rgba(255, 255, 255, 0.9);
  }
  [data-theme="dark"] .feature-heatmap .legend-title {
    color: rgba(255, 255, 255, 0.9);
  }
  [data-theme="dark"] .feature-heatmap .legend .item {
    color: rgba(255, 255, 255, 0.8);
  }
  [data-theme="dark"] .feature-heatmap .colorbar-label {
    color: rgba(255, 255, 255, 0.6);
  }
  [data-theme="dark"] .feature-heatmap .detail-panel {
    background: #1a1d28;
    border-color: rgba(255, 255, 255, 0.12);
    color: rgba(255, 255, 255, 0.9);
  }
  [data-theme="dark"] .feature-heatmap .detail-panel .detail-key {
    color: rgba(255, 255, 255, 0.5);
  }

  .feature-heatmap .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 8px;
  }

  .feature-heatmap .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .feature-heatmap .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    align-items: center;
  }

  .feature-heatmap .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .feature-heatmap .colorbar-container {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 2px;
  }

  .feature-heatmap .colorbar-canvas {
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .feature-heatmap .colorbar-label {
    font-size: 11px;
    color: var(--muted-color);
  }

  .feature-heatmap .detail-panel {
    margin-top: 12px;
    padding: 14px 16px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background: var(--surface-bg);
    font-size: 13px;
    line-height: 1.55;
    color: var(--text-color);
    display: none;
  }

  .feature-heatmap .detail-panel.visible {
    display: block;
    animation: fhFadeIn 0.25s ease;
  }

  @keyframes fhFadeIn {
    from { opacity: 0; transform: translateY(-6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .feature-heatmap .detail-panel .detail-title {
    font-weight: 700;
    font-size: 14px;
    margin-bottom: 8px;
  }

  .feature-heatmap .detail-panel .detail-row {
    display: flex;
    gap: 24px;
    flex-wrap: wrap;
    margin-bottom: 4px;
  }

  .feature-heatmap .detail-panel .detail-key {
    font-weight: 600;
    color: var(--muted-color);
    min-width: 90px;
  }

  .feature-heatmap .detail-panel .detail-link {
    color: #2563eb;
    text-decoration: none;
    font-weight: 600;
  }

  .feature-heatmap .detail-panel .detail-link:hover {
    text-decoration: underline;
  }

  .feature-heatmap .detail-panel .detail-close {
    float: right;
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: var(--muted-color);
    padding: 0 4px;
    line-height: 1;
  }

  .feature-heatmap .detail-panel .detail-close:hover {
    color: var(--text-color);
  }

  @media (max-width: 600px) {
    .feature-heatmap .controls {
      justify-content: flex-start;
    }
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('feature-heatmap'))) {
        const cs = Array.from(document.querySelectorAll('.feature-heatmap')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, { position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none', padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)', background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease', zIndex: '10', maxWidth: '300px' });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      const showTip = (evt, html) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const pt = d3.pointer(evt, container);
        const tipW = tip.offsetWidth || 200;
        const tipH = tip.offsetHeight || 60;
        const cW = container.clientWidth;
        let x = pt[0] + 14, y = pt[1] - tipH - 8;
        if (x + tipW > cW) x = pt[0] - tipW - 14;
        if (y < 0) y = pt[1] + 16;
        tip.style.transform = `translate(${x}px, ${y}px)`;
      };
      const hideTip = () => { tip.style.opacity = '0'; setTimeout(() => { tip.style.transform = 'translate(-9999px, -9999px)'; }, 120); };

      // SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gCells = gRoot.append('g').attr('class', 'cells');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      let width = 800, height = 500;
      const margin = { top: 64, right: 20, bottom: 40, left: 50 };

      // State
      let activeModel = 'gemma2b';
      let rawData = null;
      let selectedCell = null;

      // Theme detection
      const isDark = () => document.documentElement.getAttribute('data-theme') === 'dark';
      const themeTextColor = () => isDark() ? 'rgba(255,255,255,0.85)' : '#333';
      const themeMutedColor = () => isDark() ? 'rgba(255,255,255,0.6)' : '#666';
      const themeAxisColor = () => isDark() ? 'rgba(255,255,255,0.3)' : '#ccc';

      // Model names for display
      const modelLabels = { gemma2b: 'Gemma-2 2B', llama8: 'LLaMA-3.1 8B' };

      // Color scale
      const getColorScale = (minVal, maxVal) => {
        return d3.scaleSequential()
          .domain([minVal, maxVal])
          .interpolator(d3.interpolate('#2563eb', '#e0eaf8'));
      };

      // Controls
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls';
      const tabGroup = document.createElement('div');
      tabGroup.className = 'control-group';
      const tabLabel = document.createElement('label');
      tabLabel.textContent = 'Model';
      tabLabel.style.color = themeTextColor();
      tabGroup.appendChild(tabLabel);
      const tabContainer = document.createElement('div');
      tabContainer.className = 'model-tabs';
      Object.entries(modelLabels).forEach(([key, label]) => {
        const btn = document.createElement('button');
        btn.className = 'model-tab' + (key === activeModel ? ' active' : '');
        btn.textContent = label;
        btn.dataset.model = key;
        btn.addEventListener('click', () => {
          activeModel = key;
          tabContainer.querySelectorAll('.model-tab').forEach(b => b.classList.toggle('active', b.dataset.model === key));
          selectedCell = null;
          detailPanel.classList.remove('visible');
          render();
        });
        tabContainer.appendChild(btn);
      });
      tabGroup.appendChild(tabContainer);
      controlsDiv.appendChild(tabGroup);
      container.appendChild(controlsDiv);

      // Legend with colorbar
      const legendDiv = document.createElement('div');
      legendDiv.className = 'legend';
      container.appendChild(legendDiv);

      function buildLegend(colorScale, minVal, maxVal) {
        legendDiv.innerHTML = '';
        const title = document.createElement('div');
        title.className = 'legend-title'; title.textContent = 'Legend';
        title.style.color = themeTextColor();
        legendDiv.appendChild(title);

        const items = document.createElement('div');
        items.className = 'items';

        // Color bar
        const barContainer = document.createElement('div');
        barContainer.className = 'colorbar-container';

        const lowLabel = document.createElement('span');
        lowLabel.className = 'colorbar-label';
        lowLabel.textContent = minVal.toFixed(2);
        lowLabel.style.color = themeMutedColor();

        const canvas = document.createElement('canvas');
        canvas.className = 'colorbar-canvas';
        canvas.width = 140; canvas.height = 14;
        const ctx = canvas.getContext('2d');
        for (let i = 0; i < 140; i++) {
          const val = minVal + (maxVal - minVal) * (i / 139);
          ctx.fillStyle = colorScale(val);
          ctx.fillRect(i, 0, 1, 14);
        }

        const highLabel = document.createElement('span');
        highLabel.className = 'colorbar-label';
        highLabel.textContent = maxVal.toFixed(2);
        highLabel.style.color = themeMutedColor();

        const corrLabel = document.createElement('span');
        corrLabel.style.cssText = `font-size:11px;color:${themeMutedColor()};margin-right:4px;`;
        corrLabel.textContent = 'Correlation:';

        barContainer.appendChild(corrLabel);
        barContainer.appendChild(lowLabel);
        barContainer.appendChild(canvas);
        barContainer.appendChild(highLabel);
        items.appendChild(barContainer);

        // Click instruction
        const clickHint = document.createElement('span');
        clickHint.className = 'item';
        clickHint.style.cssText = `font-size:11px;color:${themeMutedColor()};`;
        clickHint.textContent = 'Click a cell for details';
        items.appendChild(clickHint);

        legendDiv.appendChild(items);
      }

      // Detail panel
      const detailPanel = document.createElement('div');
      detailPanel.className = 'detail-panel';
      container.appendChild(detailPanel);

      function showDetail(d) {
        selectedCell = d;
        const saeBase = activeModel === 'gemma2b' ? 'gemma-2-2b' : 'Meta-Llama-3.1-8B';
        const saeSuffix = activeModel === 'gemma2b' ? 'gemmascope-res-16k' : 'llamascope-res-16k';
        const npUrl = `https://neuronpedia.org/${saeBase}/${d.layer}-${saeSuffix}/${d.feature_index}`;
        detailPanel.innerHTML = `
          <button class="detail-close" aria-label="Close detail panel">&times;</button>
          <div class="detail-title">Layer ${d.layer} / ${d.task.toUpperCase()} - Feature #${d.feature_index}</div>
          <div class="detail-row"><span class="detail-key">Correlation</span><span>${d.correlation.toFixed(4)}</span></div>
          <div class="detail-row"><span class="detail-key">Coefficient</span><span>${d.coefficient.toFixed(4)}</span></div>
          <div class="detail-row"><span class="detail-key">Frequency</span><span>${d.frequency.toFixed(1)}%</span></div>
          <div class="detail-row"><span class="detail-key">Description</span><span>${d.description || 'No description available'}</span></div>
          <div class="detail-row"><span class="detail-key">Neuronpedia</span><a class="detail-link" href="${npUrl}" target="_blank" rel="noopener">${npUrl}</a></div>
        `;
        detailPanel.classList.add('visible');
        detailPanel.querySelector('.detail-close').addEventListener('click', () => {
          selectedCell = null;
          detailPanel.classList.remove('visible');
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        const modelData = rawData ? rawData[activeModel] : null;
        const tasks = modelData ? Object.keys(modelData) : [];
        const layers = modelData && tasks.length > 0 ? modelData[tasks[0]].map(d => d.layer) : [];
        const numRows = layers.length || 25;
        const cellH = Math.max(14, Math.min(22, (width - margin.left - margin.right) / (tasks.length || 8) * 0.7));
        height = margin.top + numRows * cellH + margin.bottom + 10;
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom,
          cellH
        };
      }

      function render() {
        if (!rawData || !rawData[activeModel]) return;
        const modelData = rawData[activeModel];
        const tasks = Object.keys(modelData);
        const layers = modelData[tasks[0]].map(d => d.layer);

        const { innerWidth, innerHeight, cellH } = updateSize();

        // Build flat data with task as property
        const flatData = [];
        let minCorr = Infinity, maxCorr = -Infinity;
        tasks.forEach(task => {
          modelData[task].forEach(d => {
            flatData.push({ ...d, task });
            if (d.correlation < minCorr) minCorr = d.correlation;
            if (d.correlation > maxCorr) maxCorr = d.correlation;
          });
        });

        const colorScale = getColorScale(minCorr, maxCorr);
        buildLegend(colorScale, minCorr, maxCorr);

        // Scales
        const xScale = d3.scaleBand().domain(tasks).range([0, innerWidth]).padding(0.06);
        const yScale = d3.scaleBand().domain(layers).range([0, innerHeight]).padding(0.06);

        // Task labels function for display
        const taskDisplayName = (t) => {
          const names = {
            mmlu: 'MMLU', mmlupro: 'MMLU-Pro', simpleqa: 'SimpleQA',
            bbq_ambig: 'BBQ-A', bbq_disambig: 'BBQ-D', harmbench: 'HarmBench',
            xstest: 'XSTest', gsm8k: 'GSM8K'
          };
          return names[t] || t.toUpperCase();
        };

        // X axis (task names on top)
        const xAxisG = gAxes.selectAll('.x-axis').data([0]).join('g').attr('class', 'x-axis axes')
          .attr('transform', `translate(0, -4)`);
        xAxisG.call(d3.axisTop(xScale).tickSize(0).tickFormat(taskDisplayName));
        xAxisG.select('.domain').remove();
        xAxisG.selectAll('text')
          .attr('text-anchor', 'start')
          .attr('transform', 'rotate(-40)')
          .attr('dx', '4px')
          .attr('dy', '4px')
          .style('font-size', '11px')
          .style('fill', themeMutedColor());
        xAxisG.selectAll('path, line').style('stroke', themeAxisColor());

        // Y axis (layer numbers)
        const yAxisG = gAxes.selectAll('.y-axis').data([0]).join('g').attr('class', 'y-axis axes');
        yAxisG.call(d3.axisLeft(yScale).tickSize(0).tickFormat(d => d));
        yAxisG.select('.domain').remove();
        yAxisG.selectAll('text').style('font-size', '11px').style('fill', themeMutedColor());
        yAxisG.selectAll('path, line').style('stroke', themeAxisColor());

        // Y axis label
        gAxes.selectAll('.y-label').data([0]).join('text').attr('class', 'y-label axis-label')
          .attr('transform', `translate(${-36}, ${innerHeight / 2}) rotate(-90)`)
          .attr('text-anchor', 'middle').text('Layer')
          .style('fill', themeTextColor());

        // Cells
        const cells = gCells.selectAll('.hm-cell').data(flatData, d => `${d.task}-${d.layer}`);

        const getTextStyle = (bgColor) => {
          const rgb = d3.color(bgColor);
          if (!rgb) return { fill: 'var(--text-color)' };
          const lum = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
          return { fill: lum > 160 ? '#333' : '#fff' };
        };

        cells.join(
          enter => {
            const g = enter.append('g').attr('class', 'hm-cell')
              .attr('transform', d => `translate(${xScale(d.task)}, ${yScale(d.layer)})`)
              .style('cursor', 'pointer');

            g.append('rect')
              .attr('class', 'hm-rect')
              .attr('width', xScale.bandwidth())
              .attr('height', yScale.bandwidth())
              .attr('rx', 2)
              .attr('fill', d => colorScale(d.correlation))
              .attr('stroke', 'none')
              .attr('stroke-width', 2)
              .attr('opacity', 0)
              .transition().duration(500)
              .attr('opacity', 1);

            g.append('text')
              .attr('class', 'hm-text')
              .attr('x', xScale.bandwidth() / 2)
              .attr('y', yScale.bandwidth() / 2)
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'central')
              .style('font-size', Math.min(10, yScale.bandwidth() * 0.55) + 'px')
              .style('pointer-events', 'none')
              .style('opacity', 0)
              .text(d => d.correlation.toFixed(2))
              .each(function (d) {
                const style = getTextStyle(colorScale(d.correlation));
                d3.select(this).style('fill', style.fill);
              })
              .transition().duration(500).delay(200)
              .style('opacity', yScale.bandwidth() > 16 ? 1 : 0);

            g.on('mouseenter', function (evt, d) {
              d3.select(this).select('.hm-rect').attr('stroke', 'var(--text-color)');
              showTip(evt, `
                <div style="font-weight:700;">${taskDisplayName(d.task)} - Layer ${d.layer}</div>
                <div style="margin-top:4px;">Correlation: <strong>${d.correlation.toFixed(4)}</strong></div>
                <div>Coefficient: ${d.coefficient.toFixed(4)}</div>
                <div>Feature: #${d.feature_index}</div>
                <div>Frequency: ${d.frequency.toFixed(1)}%</div>
                <div style="font-size:11px;margin-top:3px;color:var(--muted-color);">${d.description || 'No description'}</div>
              `);
            })
              .on('mouseleave', function () {
                const isSelected = selectedCell && selectedCell.task === d3.select(this).datum().task && selectedCell.layer === d3.select(this).datum().layer;
                d3.select(this).select('.hm-rect').attr('stroke', isSelected ? 'var(--text-color)' : 'none');
                hideTip();
              })
              .on('click', function (evt, d) {
                showDetail(d);
                // Highlight selected cell
                gCells.selectAll('.hm-rect').attr('stroke', 'none');
                d3.select(this).select('.hm-rect').attr('stroke', 'var(--text-color)');
              });

            return g;
          },
          update => {
            update.transition().duration(500)
              .attr('transform', d => `translate(${xScale(d.task)}, ${yScale(d.layer)})`);

            update.select('.hm-rect')
              .transition().duration(500)
              .attr('width', xScale.bandwidth())
              .attr('height', yScale.bandwidth())
              .attr('fill', d => colorScale(d.correlation))
              .attr('opacity', 1);

            update.select('.hm-text')
              .attr('x', xScale.bandwidth() / 2)
              .attr('y', yScale.bandwidth() / 2)
              .style('font-size', Math.min(10, yScale.bandwidth() * 0.55) + 'px')
              .text(d => d.correlation.toFixed(2))
              .each(function (d) {
                const style = getTextStyle(colorScale(d.correlation));
                d3.select(this).style('fill', style.fill);
              })
              .transition().duration(500)
              .style('opacity', yScale.bandwidth() > 16 ? 1 : 0);

            // Rebind events
            update
              .on('mouseenter', function (evt, d) {
                d3.select(this).select('.hm-rect').attr('stroke', 'var(--text-color)');
                showTip(evt, `
                  <div style="font-weight:700;">${taskDisplayName(d.task)} - Layer ${d.layer}</div>
                  <div style="margin-top:4px;">Correlation: <strong>${d.correlation.toFixed(4)}</strong></div>
                  <div>Coefficient: ${d.coefficient.toFixed(4)}</div>
                  <div>Feature: #${d.feature_index}</div>
                  <div>Frequency: ${d.frequency.toFixed(1)}%</div>
                  <div style="font-size:11px;margin-top:3px;color:var(--muted-color);">${d.description || 'No description'}</div>
                `);
              })
              .on('mouseleave', function () {
                const datum = d3.select(this).datum();
                const isSelected = selectedCell && selectedCell.task === datum.task && selectedCell.layer === datum.layer;
                d3.select(this).select('.hm-rect').attr('stroke', isSelected ? 'var(--text-color)' : 'none');
                hideTip();
              })
              .on('click', function (evt, d) {
                showDetail(d);
                gCells.selectAll('.hm-rect').attr('stroke', 'none');
                d3.select(this).select('.hm-rect').attr('stroke', 'var(--text-color)');
              });

            return update;
          },
          exit => exit.transition().duration(300).style('opacity', 0).remove()
        );
      }

      // Data loading
      const JSON_PATHS = [
        '/data/feature_heatmap_data.json',
        './assets/data/feature_heatmap_data.json',
        '../assets/data/feature_heatmap_data.json',
        '../../assets/data/feature_heatmap_data.json'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try { const r = await fetch(p, { cache: 'no-cache' }); if (r.ok) return await r.json(); } catch (_) { }
        }
        throw new Error('Data not found');
      };

      fetchFirstAvailable(JSON_PATHS)
        .then(data => {
          rawData = data;
          // Set default model (prefer gemma2b if available)
          if (!rawData[activeModel]) {
            activeModel = Object.keys(rawData)[0];
            tabContainer.querySelectorAll('.model-tab').forEach(b => b.classList.toggle('active', b.dataset.model === activeModel));
          }
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }

          // Theme change: re-render for correct text colors
          const mo = new MutationObserver((muts) => {
            for (const m of muts) {
              if (m.attributeName === 'data-theme') { render(); break; }
            }
          });
          mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Failed to load heatmap data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Each cell shows the top feature's correlation for that layer-task combination. Click a cell to see the top features and their descriptions.</figcaption></figure> </div>
<h2 id="safety-analysis"><a href="#safety-analysis">Safety Analysis</a></h2>
<p>CorrSteer’s safety improvements come from <strong>discrimination</strong>, not indiscriminate refusal. The XSTest benchmark separates safe prompts (e.g., asking about historical events) from unsafe contrast prompts (similar wording but genuinely harmful intent).</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Safety Discrimination by Category</figcaption><div class="html-embed__card"><div id="frag-94sh0gmb4cn" data-datafiles="safety_breakdown.json"><div class="safety-dashboard"></div>
<style>
  .safety-dashboard {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  .safety-dashboard svg {
    display: block;
    width: 100%;
    height: auto;
  }
  .safety-dashboard .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }
  .safety-dashboard .axes path,
  .safety-dashboard .axes line {
    stroke: var(--axis-color, var(--text-color));
  }
  .safety-dashboard .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }
  .safety-dashboard .grid line {
    stroke: var(--grid-color, rgba(0,0,0,.08));
  }
  .safety-dashboard .center-line {
    stroke: var(--border-color);
    stroke-width: 1.5;
    stroke-dasharray: 4,3;
  }
  .safety-dashboard .group-label {
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }
  .safety-dashboard .bar-rect {
    cursor: pointer;
    transition: opacity 0.15s ease;
    rx: 3;
    ry: 3;
  }
  .safety-dashboard .bar-rect:hover {
    opacity: 0.8;
  }
  .safety-dashboard .bar-value {
    font-size: 10px;
    font-weight: 600;
    fill: var(--text-color);
    pointer-events: none;
  }
  .safety-dashboard .category-label {
    font-size: 11px;
    fill: var(--text-color);
  }
  .safety-dashboard .separator-line {
    stroke: var(--border-color);
    stroke-width: 1;
    stroke-dasharray: 2,2;
  }
  .safety-dashboard .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0,0,0,.18);
    opacity: 0;
    transition: opacity .12s ease;
    z-index: 10;
    max-width: 260px;
  }
  .safety-dashboard .d3-tooltip__inner {
    text-align: left;
  }
  .safety-dashboard .d3-tooltip__inner .tt-category {
    font-weight: 700;
    margin-bottom: 4px;
  }
  .safety-dashboard .d3-tooltip__inner .tt-type {
    display: inline-block;
    padding: 1px 6px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 0.3px;
    margin-bottom: 6px;
  }
  .safety-dashboard .d3-tooltip__inner .tt-type.safe {
    background: oklch(0.75 0.18 145 / 0.2);
    color: oklch(0.55 0.18 145);
  }
  .safety-dashboard .d3-tooltip__inner .tt-type.unsafe {
    background: oklch(0.65 0.22 25 / 0.2);
    color: oklch(0.55 0.22 25);
  }
  .safety-dashboard .d3-tooltip__inner .tt-row {
    display: flex;
    justify-content: space-between;
    gap: 16px;
  }
  .safety-dashboard .d3-tooltip__inner .tt-label {
    color: var(--muted-color);
  }
  .safety-dashboard .d3-tooltip__inner .tt-value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
  }
  @media (max-width: 600px) {
    .safety-dashboard .category-label {
      font-size: 9px;
    }
    .safety-dashboard .bar-value {
      font-size: 8px;
    }
  }
</style>
<script>
  (() => {
    if (window.safetyDashboardInitialized) return;
    window.safetyDashboardInitialized = true;

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('safety-dashboard'))) {
        const cs = Array.from(document.querySelectorAll('.safety-dashboard'))
          .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      container.style.position = container.style.position || 'relative';

      // Tooltip
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px',
          transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 14px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.45',
          border: '1px solid var(--border-color)', background: 'var(--surface-bg)',
          color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0', transition: 'opacity .12s ease', zIndex: '10', maxWidth: '260px'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const d3 = window.d3;

      // Colors
      const safeColor = 'oklch(0.72 0.19 145)';
      const unsafeColor = 'oklch(0.63 0.24 25)';

      function formatCategory(cat) {
        return cat
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // SVG setup
      const svg = d3.select(container).append('svg');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gLabels = gRoot.append('g').attr('class', 'labels');

      let rawData = [];

      async function loadData() {
        const paths = [
          '/data/safety_breakdown.json',
          './data/safety_breakdown.json',
          '../assets/data/safety_breakdown.json',
          '/assets/data/safety_breakdown.json'
        ];
        for (const p of paths) {
          try {
            const res = await fetch(p);
            if (res.ok) {
              rawData = await res.json();
              render();
              return;
            }
          } catch (_) {}
        }
        console.warn('safety-dashboard: could not load safety_breakdown.json');
      }

      function render() {
        if (!rawData.length) return;

        const containerWidth = container.clientWidth || 700;
        const labelWidth = Math.min(170, containerWidth * 0.25);
        const margin = { top: 30, right: 30, bottom: 40, left: labelWidth + 10 };
        const barHeight = 26;
        const barGap = 5;
        const groupGap = 18;

        // Sort: safe first (lowest rate first), then unsafe (lowest rate first)
        const safeItems = rawData.filter(d => d.type === 'safe').sort((a, b) => a.rate - b.rate);
        const unsafeItems = rawData.filter(d => d.type === 'unsafe').sort((a, b) => a.rate - b.rate);
        const sorted = [...safeItems, ...unsafeItems];

        const totalItems = sorted.length;
        const innerHeight = totalItems * (barHeight + barGap) + groupGap;
        const height = innerHeight + margin.top + margin.bottom;
        const innerWidth = containerWidth - margin.left - margin.right;

        svg
          .attr('viewBox', `0 0 ${containerWidth} ${height}`)
          .attr('preserveAspectRatio', 'xMidYMid meet');

        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales: safe bars go LEFT (negative direction), unsafe bars go RIGHT
        const maxRate = d3.max(rawData, d => d.rate) || 100;
        const domainMax = Math.max(maxRate * 1.15, 10);

        const xLeft = d3.scaleLinear().domain([0, domainMax]).range([0, innerWidth / 2]);
        const xRight = d3.scaleLinear().domain([0, domainMax]).range([0, innerWidth / 2]);
        const centerX = innerWidth / 2;

        // Clear
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();
        gBars.selectAll('*').remove();
        gLabels.selectAll('*').remove();

        // Grid lines
        const ticksLeft = xLeft.ticks(4).filter(t => t > 0);
        const ticksRight = xRight.ticks(4).filter(t => t > 0);

        gGrid.selectAll('.grid-left')
          .data(ticksLeft)
          .join('line')
          .attr('class', 'grid-left')
          .attr('x1', d => centerX - xLeft(d))
          .attr('x2', d => centerX - xLeft(d))
          .attr('y1', -10)
          .attr('y2', innerHeight)
          .attr('stroke', 'var(--grid-color, rgba(0,0,0,.06))')
          .attr('stroke-width', 1);

        gGrid.selectAll('.grid-right')
          .data(ticksRight)
          .join('line')
          .attr('class', 'grid-right')
          .attr('x1', d => centerX + xRight(d))
          .attr('x2', d => centerX + xRight(d))
          .attr('y1', -10)
          .attr('y2', innerHeight)
          .attr('stroke', 'var(--grid-color, rgba(0,0,0,.06))')
          .attr('stroke-width', 1);

        // Center line
        gGrid.append('line')
          .attr('class', 'center-line')
          .attr('x1', centerX)
          .attr('x2', centerX)
          .attr('y1', -10)
          .attr('y2', innerHeight);

        // Axes: top labels
        // Left axis (safe, rates going left)
        const leftAxisG = gAxes.append('g').attr('transform', `translate(0, -14)`);
        leftAxisG.selectAll('text')
          .data(ticksLeft)
          .join('text')
          .attr('x', d => centerX - xLeft(d))
          .attr('y', 0)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--muted-color)')
          .attr('font-size', '10px')
          .text(d => d + '%');

        // Right axis (unsafe, rates going right)
        const rightAxisG = gAxes.append('g').attr('transform', `translate(0, -14)`);
        rightAxisG.selectAll('text')
          .data(ticksRight)
          .join('text')
          .attr('x', d => centerX + xRight(d))
          .attr('y', 0)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--muted-color)')
          .attr('font-size', '10px')
          .text(d => d + '%');

        // Center label "0%"
        gAxes.append('text')
          .attr('x', centerX)
          .attr('y', -14)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--muted-color)')
          .attr('font-size', '10px')
          .attr('font-weight', '600')
          .text('0%');

        // Group headers
        const safeHeaderY = -4;
        gAxes.append('text')
          .attr('class', 'group-label')
          .attr('x', centerX - 20)
          .attr('y', safeHeaderY)
          .attr('text-anchor', 'end')
          .attr('fill', safeColor)
          .attr('font-size', '11px')
          .attr('font-weight', '700')
          .attr('letter-spacing', '0.5px')
          .text('SAFE (False Refusal Rate %)');

        gAxes.append('text')
          .attr('class', 'group-label')
          .attr('x', centerX + 20)
          .attr('y', safeHeaderY)
          .attr('text-anchor', 'start')
          .attr('fill', unsafeColor)
          .attr('font-size', '11px')
          .attr('font-weight', '700')
          .attr('letter-spacing', '0.5px')
          .text('UNSAFE (Compliance Rate %)');

        // Separator between safe and unsafe
        const separatorY = safeItems.length * (barHeight + barGap) + groupGap / 2 - barGap / 2;
        gGrid.append('line')
          .attr('class', 'separator-line')
          .attr('x1', -labelWidth)
          .attr('x2', innerWidth)
          .attr('y1', separatorY)
          .attr('y2', separatorY);

        // Draw bars
        sorted.forEach((d, i) => {
          const yOffset = i < safeItems.length
            ? i * (barHeight + barGap)
            : safeItems.length * (barHeight + barGap) + groupGap + (i - safeItems.length) * (barHeight + barGap);
          const isSafe = d.type === 'safe';
          const barW = isSafe ? xLeft(d.rate) : xRight(d.rate);
          const barX = isSafe ? centerX - barW : centerX;
          const color = isSafe ? safeColor : unsafeColor;

          // Bar background (subtle)
          gBars.append('rect')
            .attr('x', barX)
            .attr('y', yOffset)
            .attr('width', Math.max(barW, 0))
            .attr('height', barHeight)
            .attr('rx', 3)
            .attr('ry', 3)
            .attr('fill', color)
            .attr('opacity', 0.85)
            .attr('class', 'bar-rect')
            .on('mousemove', (event) => {
              const [px, py] = d3.pointer(event, container);
              tipInner.innerHTML =
                `<div class="tt-category">${formatCategory(d.category)}</div>` +
                `<div class="tt-type ${d.type}">${d.type.toUpperCase()}</div>` +
                `<div class="tt-row"><span class="tt-label">N</span><span class="tt-value">${d.n}</span></div>` +
                `<div class="tt-row"><span class="tt-label">${isSafe ? 'False Refusal Rate' : 'Compliance Rate'}</span><span class="tt-value">${d.rate.toFixed(1)}%</span></div>`;
              const tipW = tip.offsetWidth || 200;
              const tipH = tip.offsetHeight || 80;
              let tx = px + 14;
              let ty = py - tipH / 2;
              if (tx + tipW > containerWidth) tx = px - tipW - 14;
              if (ty < 0) ty = 4;
              tip.style.transform = `translate(${tx}px, ${ty}px)`;
              tip.style.opacity = '1';
            })
            .on('mouseleave', () => {
              tip.style.opacity = '0';
              tip.style.transform = 'translate(-9999px, -9999px)';
            });

          // Value label on the bar
          if (d.rate > 0) {
            const valuePadding = 6;
            const textX = isSafe
              ? barX - valuePadding
              : barX + barW + valuePadding;
            const textAnchor = isSafe ? 'end' : 'start';

            gBars.append('text')
              .attr('class', 'bar-value')
              .attr('x', textX)
              .attr('y', yOffset + barHeight / 2)
              .attr('dy', '0.35em')
              .attr('text-anchor', textAnchor)
              .attr('fill', 'var(--text-color)')
              .attr('font-size', '10px')
              .attr('font-weight', '600')
              .text(d.rate.toFixed(1) + '%');
          } else {
            // Show "0%" centered at the bar position
            const textX = isSafe ? centerX - 6 : centerX + 6;
            const textAnchor = isSafe ? 'end' : 'start';
            gBars.append('text')
              .attr('class', 'bar-value')
              .attr('x', textX)
              .attr('y', yOffset + barHeight / 2)
              .attr('dy', '0.35em')
              .attr('text-anchor', textAnchor)
              .attr('fill', 'var(--muted-color)')
              .attr('font-size', '10px')
              .text('0%');
          }

          // Category label
          gLabels.append('text')
            .attr('class', 'category-label')
            .attr('x', -10)
            .attr('y', yOffset + barHeight / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', 'end')
            .attr('fill', 'var(--text-color)')
            .attr('font-size', '11px')
            .text(formatCategory(d.category));
        });

        // Bottom axis labels
        gAxes.append('text')
          .attr('x', centerX / 2)
          .attr('y', innerHeight + 24)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--muted-color)')
          .attr('font-size', '11px')
          .attr('font-weight', '600')
          .text('False Refusal Rate (%)');

        gAxes.append('text')
          .attr('x', centerX + centerX / 2)
          .attr('y', innerHeight + 24)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--muted-color)')
          .attr('font-size', '11px')
          .attr('font-weight', '600')
          .text('Compliance Rate (%)');
      }

      // Responsive
      const rerender = () => render();
      if (window.ResizeObserver) {
        new ResizeObserver(rerender).observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }

      // Dark mode MutationObserver
      const themeTarget = document.documentElement;
      const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === 'attributes' && m.attributeName === 'data-theme') {
            render();
            break;
          }
        }
      });
      observer.observe(themeTarget, { attributes: true, attributeFilter: ['data-theme'] });

      loadData();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">XSTest breakdown: safe categories (left) show near-zero over-refusal. Unsafe contrast categories (right) show appropriate refusal rates.</figcaption></figure> </div>
<p>Safe prompts like <em>historical events</em>, <em>definitions</em>, and <em>figurative language</em> show 0% over-refusal. The steered model correctly identifies these as benign. Meanwhile, contrast categories with genuinely harmful intent show refusal rates of 22-73%.</p>
<h2 id="cross-task-transfer"><a href="#cross-task-transfer">Cross-Task Transfer</a></h2>
<p>Can features selected for one task improve performance on others?</p>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Cross-Task Feature Transferability</figcaption><div class="html-embed__card"><div id="frag-po2gx64hwmm" data-datafiles="transferability.json"><div class="transfer-heatmap"></div>
<style>
  .transfer-heatmap {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  .transfer-heatmap svg {
    display: block;
    width: 100%;
    height: auto;
  }
  .transfer-heatmap .axes path,
  .transfer-heatmap .axes line {
    stroke: var(--axis-color, var(--text-color));
  }
  .transfer-heatmap .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }
  .transfer-heatmap .axis-title {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }
  .transfer-heatmap .cell-rect {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }
  .transfer-heatmap .cell-rect:hover {
    opacity: 0.8;
  }
  .transfer-heatmap .cell-text {
    font-size: 12px;
    font-weight: 600;
    pointer-events: none;
    font-variant-numeric: tabular-nums;
  }
  .transfer-heatmap .cell-delta {
    font-size: 9px;
    font-weight: 500;
    pointer-events: none;
    font-variant-numeric: tabular-nums;
  }
  .transfer-heatmap .diagonal-border {
    fill: none;
    stroke-width: 2.5;
    pointer-events: none;
  }
  .transfer-heatmap .colorbar-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-top: 12px;
  }
  .transfer-heatmap .colorbar-label {
    font-size: 10px;
    color: var(--muted-color);
    font-weight: 600;
    white-space: nowrap;
  }
  .transfer-heatmap .colorbar-gradient {
    width: 200px;
    height: 12px;
    border-radius: 6px;
    border: 1px solid var(--border-color);
  }
  .transfer-heatmap .baseline-note {
    text-align: center;
    font-size: 11px;
    color: var(--muted-color);
    margin-top: 8px;
  }
  .transfer-heatmap .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0,0,0,.18);
    opacity: 0;
    transition: opacity .12s ease;
    z-index: 10;
    max-width: 280px;
  }
  .transfer-heatmap .d3-tooltip__inner {
    text-align: left;
  }
  .transfer-heatmap .d3-tooltip__inner .tt-header {
    font-weight: 700;
    margin-bottom: 6px;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--border-color);
  }
  .transfer-heatmap .d3-tooltip__inner .tt-row {
    display: flex;
    justify-content: space-between;
    gap: 16px;
  }
  .transfer-heatmap .d3-tooltip__inner .tt-label {
    color: var(--muted-color);
  }
  .transfer-heatmap .d3-tooltip__inner .tt-value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
  }
  .transfer-heatmap .d3-tooltip__inner .tt-delta-pos {
    color: oklch(0.55 0.18 145);
  }
  .transfer-heatmap .d3-tooltip__inner .tt-delta-neg {
    color: oklch(0.55 0.22 25);
  }
  @media (max-width: 500px) {
    .transfer-heatmap .cell-text { font-size: 10px; }
    .transfer-heatmap .cell-delta { font-size: 7px; }
    .transfer-heatmap .axes text { font-size: 9px; }
  }
</style>
<script>
  (() => {
    if (window.transferHeatmapInitialized) return;
    window.transferHeatmapInitialized = true;

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('transfer-heatmap'))) {
        const cs = Array.from(document.querySelectorAll('.transfer-heatmap'))
          .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      container.style.position = container.style.position || 'relative';

      // Tooltip
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px',
          transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 14px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.5',
          border: '1px solid var(--border-color)', background: 'var(--surface-bg)',
          color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0', transition: 'opacity .12s ease', zIndex: '10', maxWidth: '280px'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const d3 = window.d3;

      // SVG
      const svg = d3.select(container).append('svg');
      const gRoot = svg.append('g');
      const gCells = gRoot.append('g').attr('class', 'cells');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // Colorbar container (HTML below SVG)
      const colorbarDiv = document.createElement('div');
      colorbarDiv.className = 'colorbar-container';
      container.appendChild(colorbarDiv);

      // Baseline note
      const noteDiv = document.createElement('div');
      noteDiv.className = 'baseline-note';
      container.appendChild(noteDiv);

      let rawData = null;

      const targetKeys = ['mmlu', 'mmlupro', 'bbq_disambig', 'bbq_ambig'];
      const targetLabels = {
        mmlu: 'MMLU',
        mmlupro: 'MMLU-Pro',
        bbq_disambig: 'BBQ Disambig',
        bbq_ambig: 'BBQ Ambig'
      };

      async function loadData() {
        const paths = [
          '/data/transferability.json',
          './data/transferability.json',
          '../assets/data/transferability.json',
          '/assets/data/transferability.json'
        ];
        for (const p of paths) {
          try {
            const res = await fetch(p);
            if (res.ok) {
              rawData = await res.json();
              render();
              return;
            }
          } catch (_) {}
        }
        console.warn('transfer-heatmap: could not load transferability.json');
      }

      function chooseTextColor(bgR, bgG, bgB) {
        const srgb = [bgR, bgG, bgB].map(v => Math.max(0, Math.min(255, v)) / 255);
        const linear = srgb.map(c => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)));
        const L = 0.2126 * linear[0] + 0.7152 * linear[1] + 0.0722 * linear[2];
        return L < 0.45 ? '#ffffff' : '#1a1a2e';
      }

      function render() {
        if (!rawData) return;

        const baseline = rawData.baseline;
        const transfers = rawData.transfers;
        const nRows = transfers.length;
        const nCols = targetKeys.length;

        const containerWidth = container.clientWidth || 500;
        const margin = { top: 60, right: 20, bottom: 50, left: 100 };
        const innerSize = Math.min(containerWidth - margin.left - margin.right, 420);
        const cellSize = innerSize / nCols;
        const width = margin.left + innerSize + margin.right;
        const height = margin.top + nRows * cellSize + margin.bottom;

        svg
          .attr('viewBox', `0 0 ${width} ${height}`)
          .attr('preserveAspectRatio', 'xMidYMid meet');

        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);

        // Compute deltas
        const flatData = [];
        let minDelta = Infinity, maxDelta = -Infinity;

        transfers.forEach((row, r) => {
          targetKeys.forEach((key, c) => {
            const val = row[key];
            const base = baseline[key];
            const delta = val - base;
            if (delta < minDelta) minDelta = delta;
            if (delta > maxDelta) maxDelta = delta;
            // Diagonal: source row index matches target column index
            const isDiag = r === c;
            flatData.push({
              r, c, val, base, delta, isDiag,
              source: row.source,
              target: targetLabels[key]
            });
          });
        });

        // Symmetric domain for diverging scale
        const absMax = Math.max(Math.abs(minDelta), Math.abs(maxDelta), 1);

        // Color scale: diverging green (positive) / red (negative)
        const colorScale = d3.scaleDiverging()
          .domain([-absMax, 0, absMax])
          .interpolator(t => {
            // t: 0 = min (red), 0.5 = zero (neutral), 1 = max (green)
            if (t < 0.5) {
              // Red range: interpolate from saturated red to neutral
              const s = t / 0.5; // 0 to 1
              const r = Math.round(200 + (220 - 200) * s);
              const g = Math.round(60 + (215 - 60) * s);
              const b = Math.round(60 + (220 - 60) * s);
              return `rgb(${r},${g},${b})`;
            } else {
              // Green range: interpolate from neutral to saturated green
              const s = (t - 0.5) / 0.5; // 0 to 1
              const r = Math.round(220 - (220 - 60) * s);
              const g = Math.round(215 - (215 - 170) * s);
              const b = Math.round(220 - (220 - 80) * s);
              return `rgb(${r},${g},${b})`;
            }
          });

        // Parse rgb to get text color contrast
        function parseBgColor(delta) {
          const t = (delta + absMax) / (2 * absMax);
          if (t < 0.5) {
            const s = t / 0.5;
            return [Math.round(200 + 20 * s), Math.round(60 + 155 * s), Math.round(60 + 160 * s)];
          } else {
            const s = (t - 0.5) / 0.5;
            return [Math.round(220 - 160 * s), Math.round(215 - 45 * s), Math.round(220 - 140 * s)];
          }
        }

        // Clear
        gCells.selectAll('*').remove();
        gAxes.selectAll('*').remove();

        // Cells
        flatData.forEach(d => {
          const x = d.c * cellSize;
          const y = d.r * cellSize;
          const pad = 2;
          const [bgR, bgG, bgB] = parseBgColor(d.delta);
          const textFill = chooseTextColor(bgR, bgG, bgB);

          // Cell background
          gCells.append('rect')
            .attr('class', 'cell-rect')
            .attr('x', x + pad)
            .attr('y', y + pad)
            .attr('width', cellSize - 2 * pad)
            .attr('height', cellSize - 2 * pad)
            .attr('rx', 4)
            .attr('ry', 4)
            .attr('fill', colorScale(d.delta))
            .on('mousemove', (event) => {
              const [px, py] = d3.pointer(event, container);
              const sign = d.delta >= 0 ? '+' : '';
              const deltaClass = d.delta >= 0 ? 'tt-delta-pos' : 'tt-delta-neg';
              tipInner.innerHTML =
                `<div class="tt-header">${d.source} &rarr; ${d.target}</div>` +
                `<div class="tt-row"><span class="tt-label">Accuracy</span><span class="tt-value">${d.val.toFixed(2)}%</span></div>` +
                `<div class="tt-row"><span class="tt-label">Baseline</span><span class="tt-value">${d.base.toFixed(2)}%</span></div>` +
                `<div class="tt-row"><span class="tt-label">Delta</span><span class="tt-value ${deltaClass}">${sign}${d.delta.toFixed(2)}</span></div>` +
                (d.isDiag ? '<div style="margin-top:4px;font-size:10px;color:var(--muted-color);">Self-transfer (diagonal)</div>' : '');
              const tipW = tip.offsetWidth || 220;
              const tipH = tip.offsetHeight || 100;
              let tx = px + 14;
              let ty = py - tipH / 2;
              if (tx + tipW > containerWidth) tx = px - tipW - 14;
              if (ty < 0) ty = 4;
              tip.style.transform = `translate(${tx}px, ${ty}px)`;
              tip.style.opacity = '1';
            })
            .on('mouseleave', () => {
              tip.style.opacity = '0';
              tip.style.transform = 'translate(-9999px, -9999px)';
            });

          // Diagonal highlight border
          if (d.isDiag) {
            gCells.append('rect')
              .attr('class', 'diagonal-border')
              .attr('x', x + pad + 1)
              .attr('y', y + pad + 1)
              .attr('width', cellSize - 2 * pad - 2)
              .attr('height', cellSize - 2 * pad - 2)
              .attr('rx', 4)
              .attr('ry', 4)
              .attr('stroke', 'var(--text-color)')
              .attr('stroke-width', 2.5)
              .attr('fill', 'none');
          }

          // Accuracy value
          gCells.append('text')
            .attr('class', 'cell-text')
            .attr('x', x + cellSize / 2)
            .attr('y', y + cellSize / 2 - 4)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('fill', textFill)
            .text(d.val.toFixed(1));

          // Delta value below
          const sign = d.delta >= 0 ? '+' : '';
          gCells.append('text')
            .attr('class', 'cell-delta')
            .attr('x', x + cellSize / 2)
            .attr('y', y + cellSize / 2 + 12)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('fill', textFill)
            .attr('opacity', 0.75)
            .text(`(${sign}${d.delta.toFixed(1)})`);
        });

        // Column labels (top)
        targetKeys.forEach((key, i) => {
          gAxes.append('text')
            .attr('x', i * cellSize + cellSize / 2)
            .attr('y', -12)
            .attr('text-anchor', 'middle')
            .attr('fill', 'var(--text-color)')
            .attr('font-size', '11px')
            .attr('font-weight', '600')
            .text(targetLabels[key]);
        });

        // "Target Task" label
        gAxes.append('text')
          .attr('class', 'axis-title')
          .attr('x', innerSize / 2)
          .attr('y', -32)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--text-color)')
          .attr('font-size', '12px')
          .attr('font-weight', '700')
          .text('Target Task');

        // Row labels (left)
        transfers.forEach((row, i) => {
          gAxes.append('text')
            .attr('x', -12)
            .attr('y', i * cellSize + cellSize / 2)
            .attr('text-anchor', 'end')
            .attr('dominant-baseline', 'middle')
            .attr('fill', 'var(--text-color)')
            .attr('font-size', '11px')
            .attr('font-weight', '600')
            .text(row.source);
        });

        // "Source Task" label
        gAxes.append('text')
          .attr('class', 'axis-title')
          .attr('x', 0)
          .attr('y', 0)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('fill', 'var(--text-color)')
          .attr('font-size', '12px')
          .attr('font-weight', '700')
          .attr('transform', `translate(${-70}, ${innerSize / 2}) rotate(-90)`)
          .text('Source Task');

        // Colorbar
        const gradientId = 'transfer-heatmap-gradient';
        let defs = svg.select('defs');
        if (defs.empty()) defs = svg.append('defs');
        defs.selectAll('*').remove();

        const lg = defs.append('linearGradient')
          .attr('id', gradientId)
          .attr('x1', '0%').attr('y1', '0%')
          .attr('x2', '100%').attr('y2', '0%');

        const nStops = 11;
        for (let i = 0; i <= nStops; i++) {
          const t = i / nStops;
          const val = -absMax + t * 2 * absMax;
          lg.append('stop')
            .attr('offset', `${(t * 100).toFixed(1)}%`)
            .attr('stop-color', colorScale(val));
        }

        colorbarDiv.innerHTML =
          `<span class="colorbar-label">${(-absMax).toFixed(1)}</span>` +
          `<div class="colorbar-gradient" style="background: linear-gradient(to right, ${colorScale(-absMax)}, ${colorScale(0)}, ${colorScale(absMax)})"></div>` +
          `<span class="colorbar-label">+${absMax.toFixed(1)}</span>`;

        noteDiv.textContent = `Baseline: MMLU ${baseline.mmlu}%, MMLU-Pro ${baseline.mmlupro}%, BBQ Disambig ${baseline.bbq_disambig}%, BBQ Ambig ${baseline.bbq_ambig}%`;
      }

      // Responsive
      const rerender = () => render();
      if (window.ResizeObserver) {
        new ResizeObserver(rerender).observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }

      // Dark mode MutationObserver
      const themeTarget = document.documentElement;
      const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === 'attributes' && m.attributeName === 'data-theme') {
            render();
            break;
          }
        }
      });
      observer.observe(themeTarget, { attributes: true, attributeFilter: ['data-theme'] });

      loadData();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Features from source tasks (rows) applied to target tasks (columns). Color intensity = accuracy gain over baseline.</figcaption></figure>
<p>Three patterns emerge:</p>
<ol>
<li><strong>MMLU features transfer broadly</strong> to MMLU-Pro (+5.67%) and BBQ Ambig (+4.91%), sharing multiple-choice format</li>
<li><strong>BBQ features transfer to MMLU</strong>, indicating bias-mitigation features encode general QA capabilities</li>
<li><strong>Task-specific features outperform transferred features</strong> in most cases, confirming the value of targeted selection</li>
</ol>
<h2 id="ablation-studies"><a href="#ablation-studies">Ablation Studies</a></h2>
<h3 id="pooling-strategy-comparison"><a href="#pooling-strategy-comparison">Pooling Strategy Comparison</a></h3>
<p>Max-pooling captures peak feature activation across generated tokens and succeeds across all tasks. Mean-pooling catastrophically fails on multi-token generation tasks (HarmBench: 0%, XSTest: 53.65%) because averaging dilutes sparse signals.</p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Pooling &amp; Negative Feature Ablations</figcaption><div class="html-embed__card"><div id="frag-wnabjhm49zq" data-datafiles="ablation_data.json"><div class="ablation-pooling"></div>
<style>
  .ablation-pooling {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  .ablation-pooling svg {
    display: block;
    width: 100%;
    height: auto;
  }
  .ablation-pooling .tab-bar {
    display: flex;
    gap: 0;
    margin-bottom: 0;
    border-bottom: 2px solid var(--border-color, #e2e5ea);
  }
  .ablation-pooling .tab-btn {
    padding: 10px 22px;
    font-size: 13px;
    font-weight: 600;
    color: var(--muted-color, #6b7280);
    background: none;
    border: none;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    transition: color 0.2s, border-color 0.2s;
    letter-spacing: 0.01em;
    white-space: nowrap;
  }
  .ablation-pooling .tab-btn:hover {
    color: var(--text-color, #1f2937);
  }
  .ablation-pooling .tab-btn.active {
    color: oklch(0.65 0.2 280);
    border-bottom-color: oklch(0.65 0.2 280);
  }
  .ablation-pooling .chart-area {
    padding: 16px 0 0;
  }
  .ablation-pooling .legend {
    display: flex;
    justify-content: center;
    gap: 18px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .ablation-pooling .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11.5px;
    color: var(--text-color, #1f2937);
    cursor: default;
  }
  .ablation-pooling .legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    flex-shrink: 0;
  }
  .ablation-pooling .legend-item .winner-star {
    font-size: 10px;
    margin-left: -2px;
  }
  .ablation-pooling .axis path { display: none; }
  .ablation-pooling .axis line { stroke: var(--axis-color, #d1d5db); }
  .ablation-pooling .axis text {
    fill: var(--tick-color, var(--muted-color, #6b7280));
    font-size: 11px;
  }
  .ablation-pooling .grid line {
    stroke: var(--grid-color, rgba(0,0,0,.06));
    stroke-width: 1;
  }
  .ablation-pooling .bar-rect {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }
  .ablation-pooling .bar-rect:hover { opacity: 0.82; }
  .ablation-pooling .bar-value {
    font-size: 9.5px;
    font-weight: 600;
    fill: var(--text-color, #1f2937);
    pointer-events: none;
    font-variant-numeric: tabular-nums;
  }
  .ablation-pooling .failure-icon {
    font-size: 11px;
    pointer-events: none;
  }
  .ablation-pooling .d3-tooltip {
    position: absolute;
    top: 0; left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid var(--border-color, #e2e5ea);
    background: var(--surface-bg, #fff);
    color: var(--text-color, #1f2937);
    box-shadow: 0 4px 24px rgba(0,0,0,.18);
    opacity: 0;
    transition: opacity .12s ease;
    z-index: 10;
    max-width: 280px;
    backdrop-filter: saturate(1.12) blur(8px);
  }
  .ablation-pooling .d3-tooltip .tt-task {
    font-weight: 700;
    margin-bottom: 6px;
    font-size: 13px;
  }
  .ablation-pooling .d3-tooltip .tt-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    padding: 2px 0;
  }
  .ablation-pooling .d3-tooltip .tt-label {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--muted-color, #6b7280);
  }
  .ablation-pooling .d3-tooltip .tt-dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    flex-shrink: 0;
  }
  .ablation-pooling .d3-tooltip .tt-value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
  }
  .ablation-pooling .d3-tooltip .tt-value.failure {
    color: oklch(0.6 0.24 25);
    font-weight: 700;
  }
  .ablation-pooling .d3-tooltip .tt-value.winner {
    color: oklch(0.55 0.2 280);
    font-weight: 700;
  }
  @media (max-width: 600px) {
    .ablation-pooling .tab-btn { padding: 8px 14px; font-size: 12px; }
    .ablation-pooling .legend { gap: 10px; }
    .ablation-pooling .legend-item { font-size: 10.5px; }
    .ablation-pooling .bar-value { font-size: 8px; }
  }
</style>
<script>
(() => {
  if (window.ablationPoolingInitialized) return;
  window.ablationPoolingInitialized = true;

  const ensureD3 = (cb) => {
    if (window.d3 && typeof window.d3.select === 'function') return cb();
    let s = document.getElementById('d3-cdn-script');
    if (!s) {
      s = document.createElement('script');
      s.id = 'd3-cdn-script';
      s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
      document.head.appendChild(s);
    }
    const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
    s.addEventListener('load', onReady, { once: true });
    if (window.d3) onReady();
  };

  const bootstrap = () => {
    const scriptEl = document.currentScript;
    let container = scriptEl ? scriptEl.previousElementSibling : null;
    if (!(container && container.classList && container.classList.contains('ablation-pooling'))) {
      const cs = Array.from(document.querySelectorAll('.ablation-pooling'))
        .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
      container = cs[cs.length - 1] || null;
    }
    if (!container) return;
    if (container.dataset) {
      if (container.dataset.mounted === 'true') return;
      container.dataset.mounted = 'true';
    }
    container.style.position = container.style.position || 'relative';

    const d3 = window.d3;

    // ---- COLORS ----
    const COLORS = {
      pooling: {
        non:  'var(--pooling-non, #9ca3af)',
        max:  'var(--pooling-max, oklch(0.58 0.22 280))',
        mean: 'var(--pooling-mean, oklch(0.72 0.16 85))',
        all:  'var(--pooling-all, oklch(0.62 0.14 185))'
      },
      negative: {
        non:   'var(--neg-non, #9ca3af)',
        pos:   'var(--neg-pos, oklch(0.58 0.22 280))',
        neg_s: 'var(--neg-negs, oklch(0.72 0.18 25))',
        neg_a: 'var(--neg-nega, oklch(0.52 0.22 25))'
      }
    };
    // Resolved colors for tooltip dots (computed at render time)
    const RESOLVED = {};
    function resolveColor(css) {
      const el = document.createElement('span');
      el.style.color = css;
      el.style.display = 'none';
      document.body.appendChild(el);
      const resolved = getComputedStyle(el).color;
      el.remove();
      return resolved;
    }

    // ---- SERIES CONFIG ----
    const SERIES = {
      pooling: [
        { key: 'non',  label: 'Non-steered',  winner: false },
        { key: 'max',  label: 'Max-pool',     winner: true  },
        { key: 'mean', label: 'Mean-pool',    winner: false },
        { key: 'all',  label: 'All-token',    winner: false }
      ],
      negative: [
        { key: 'non',   label: 'Non-steered', winner: false },
        { key: 'pos',   label: 'Positive',    winner: true  },
        { key: 'neg_s', label: 'Neg-S',       winner: false },
        { key: 'neg_a', label: 'Neg-A',       winner: false }
      ]
    };

    // Failure thresholds: values below these on specific tasks are considered catastrophic
    const FAILURE_THRESHOLD = 15;
    function isFailure(tabKey, seriesKey, task, value) {
      if (tabKey === 'pooling') {
        if (seriesKey === 'mean' && task === 'HarmBench' && value <= 1) return true;
        if (seriesKey === 'mean' && task === 'XSTest' && value < 60) return true;
      }
      if (tabKey === 'negative') {
        if (seriesKey === 'neg_a' && value < FAILURE_THRESHOLD) return true;
      }
      return false;
    }

    // ---- TOOLTIP ----
    let tip, tipInner;
    tip = document.createElement('div');
    tip.className = 'd3-tooltip';
    tipInner = document.createElement('div');
    tipInner.className = 'd3-tooltip__inner';
    tip.appendChild(tipInner);
    container.appendChild(tip);

    function showTip(event, html) {
      tipInner.innerHTML = html;
      const [px, py] = d3.pointer(event, container);
      const cw = container.clientWidth;
      const tipW = tip.offsetWidth || 200;
      const tipH = tip.offsetHeight || 100;
      let tx = px + 14;
      let ty = py - tipH / 2;
      if (tx + tipW > cw) tx = px - tipW - 14;
      if (ty < 0) ty = 4;
      tip.style.transform = `translate(${tx}px, ${ty}px)`;
      tip.style.opacity = '1';
    }
    function hideTip() {
      tip.style.opacity = '0';
      tip.style.transform = 'translate(-9999px, -9999px)';
    }

    // ---- DATA LOADING ----
    let DATA = null;
    async function loadData() {
      const paths = [
        '/data/ablation_data.json',
        './data/ablation_data.json',
        '../assets/data/ablation_data.json',
        '/assets/data/ablation_data.json'
      ];
      for (const p of paths) {
        try {
          const res = await fetch(p);
          if (res.ok) { DATA = await res.json(); return; }
        } catch (_) {}
      }
      // Inline fallback data
      DATA = {
        pooling: [
          { task: 'MMLU', non: 52.23, max: 56.32, mean: 56.32, all: 52.91 },
          { task: 'MMLU-Pro', non: 30.30, max: 31.00, mean: 31.00, all: 30.16 },
          { task: 'BBQ Disambig', non: 75.42, max: 76.53, mean: 76.53, all: 75.00 },
          { task: 'BBQ Ambig', non: 59.10, max: 62.08, mean: 62.08, all: 57.98 },
          { task: 'HarmBench', non: 44.64, max: 67.50, mean: 0.00, all: 47.14 },
          { task: 'XSTest', non: 86.35, max: 87.30, mean: 53.65, all: 86.35 },
          { task: 'SimpleQA', non: 3.63, max: 3.80, mean: 3.76, all: 3.73 }
        ],
        negative: [
          { task: 'MMLU', non: 52.23, pos: 56.32, neg_s: 52.24, neg_a: 49.45 },
          { task: 'MMLU-Pro', non: 14.00, pos: 17.56, neg_s: 14.24, neg_a: 0.66 },
          { task: 'BBQ Disambig', non: 75.42, pos: 76.53, neg_s: 75.37, neg_a: 12.15 },
          { task: 'BBQ Ambig', non: 59.10, pos: 62.08, neg_s: 59.22, neg_a: 60.85 },
          { task: 'HarmBench', non: 44.64, pos: 67.50, neg_s: 44.64, neg_a: 47.86 },
          { task: 'XSTest', non: 86.35, pos: 87.30, neg_s: 86.35, neg_a: 86.67 },
          { task: 'SimpleQA', non: 3.63, pos: 3.80, neg_s: 3.76, neg_a: 3.76 }
        ]
      };
    }

    // ---- TAB STATE ----
    let activeTab = 'pooling';

    // ---- BUILD UI ----
    const tabBar = document.createElement('div');
    tabBar.className = 'tab-bar';

    const tabPooling = document.createElement('button');
    tabPooling.className = 'tab-btn active';
    tabPooling.textContent = 'Pooling Strategies';
    tabPooling.addEventListener('click', () => switchTab('pooling'));

    const tabNegative = document.createElement('button');
    tabNegative.className = 'tab-btn';
    tabNegative.textContent = 'Positive vs Negative';
    tabNegative.addEventListener('click', () => switchTab('negative'));

    tabBar.appendChild(tabPooling);
    tabBar.appendChild(tabNegative);
    container.appendChild(tabBar);

    const chartArea = document.createElement('div');
    chartArea.className = 'chart-area';
    container.appendChild(chartArea);

    function switchTab(tab) {
      activeTab = tab;
      tabPooling.classList.toggle('active', tab === 'pooling');
      tabNegative.classList.toggle('active', tab === 'negative');
      render();
    }

    // ---- RENDER ----
    function render() {
      if (!DATA) return;
      chartArea.innerHTML = '';
      hideTip();

      const tabKey = activeTab;
      const series = SERIES[tabKey];
      const colors = COLORS[tabKey];
      const data = DATA[tabKey];
      if (!data || !data.length) return;

      // Resolve colors for tooltip
      series.forEach(s => {
        RESOLVED[s.key] = resolveColor(colors[s.key]);
      });

      // Legend
      const legend = document.createElement('div');
      legend.className = 'legend';
      series.forEach(s => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML =
          `<span class="legend-swatch" style="background:${colors[s.key]}"></span>` +
          `<span>${s.label}</span>` +
          (s.winner ? `<span class="winner-star" title="Best overall">&#9733;</span>` : '');
        legend.appendChild(item);
      });
      chartArea.appendChild(legend);

      // SVG dimensions
      const containerWidth = container.clientWidth || 700;
      const margin = { top: 16, right: 16, bottom: 64, left: 48 };
      const chartHeight = 360;
      const innerWidth = containerWidth - margin.left - margin.right;
      const innerHeight = chartHeight - margin.top - margin.bottom;

      const svg = d3.select(chartArea)
        .append('svg')
        .attr('viewBox', `0 0 ${containerWidth} ${chartHeight}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      // Scales
      const tasks = data.map(d => d.task);
      const keys = series.map(s => s.key);

      const x0 = d3.scaleBand().domain(tasks).range([0, innerWidth]).paddingInner(0.22).paddingOuter(0.1);
      const x1 = d3.scaleBand().domain(keys).range([0, x0.bandwidth()]).padding(0.12);

      const allVals = data.flatMap(d => keys.map(k => d[k]));
      const yMax = Math.min(100, d3.max(allVals) * 1.12);
      const y = d3.scaleLinear().domain([0, yMax]).range([innerHeight, 0]).nice();

      // Grid
      const grid = g.append('g').attr('class', 'grid');
      grid.selectAll('line')
        .data(y.ticks(5))
        .join('line')
        .attr('x1', 0)
        .attr('x2', innerWidth)
        .attr('y1', d => y(d))
        .attr('y2', d => y(d));

      // Axes
      const xAxis = g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(x0).tickSizeOuter(0));

      xAxis.selectAll('text')
        .attr('transform', 'rotate(-30)')
        .style('text-anchor', 'end')
        .attr('dx', '-0.5em')
        .attr('dy', '0.5em')
        .style('font-size', '11px');

      g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + '%').tickSizeOuter(0));

      // Y-axis label
      g.append('text')
        .attr('transform', `rotate(-90)`)
        .attr('x', -innerHeight / 2)
        .attr('y', -38)
        .attr('text-anchor', 'middle')
        .attr('fill', 'var(--muted-color, #6b7280)')
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Accuracy (%)');

      // Rounded top bar path
      const barPath = (bx, by, bw, bh) => {
        if (bh <= 0) return '';
        const r = Math.min(2.5, bh / 2, bw / 2);
        return `M ${bx},${by + bh} L ${bx},${by + r} Q ${bx},${by} ${bx + r},${by} L ${bx + bw - r},${by} Q ${bx + bw},${by} ${bx + bw},${by + r} L ${bx + bw},${by + bh} Z`;
      };

      // Failure marker color
      const failColor = 'oklch(0.6 0.24 25)';
      const failBg = 'oklch(0.9 0.08 25)';

      // Bar groups
      data.forEach((d, di) => {
        const gGroup = g.append('g').attr('transform', `translate(${x0(d.task)},0)`);

        keys.forEach((key, ki) => {
          const val = d[key];
          const bx = x1(key);
          const bw = x1.bandwidth();
          const bh = innerHeight - y(val);
          const by = y(val);
          const fail = isFailure(tabKey, key, d.task, val);
          const isWinner = series[ki].winner;

          // For zero-height bars, draw a minimal indicator
          if (bh < 1) {
            gGroup.append('rect')
              .attr('class', 'bar-rect')
              .attr('x', bx)
              .attr('y', innerHeight - 2)
              .attr('width', bw)
              .attr('height', 2)
              .attr('rx', 1)
              .attr('fill', fail ? failColor : colors[key])
              .attr('opacity', 0.4)
              .on('mousemove', (event) => showTooltip(event, d, tabKey, series, colors, keys))
              .on('mouseleave', hideTip);
          } else {
            // Failure background highlight
            if (fail) {
              gGroup.append('rect')
                .attr('x', bx - 2)
                .attr('y', by - 2)
                .attr('width', bw + 4)
                .attr('height', bh + 4)
                .attr('rx', 4)
                .attr('fill', failBg)
                .attr('opacity', 0.4)
                .style('pointer-events', 'none');
            }

            gGroup.append('path')
              .attr('class', 'bar-rect')
              .attr('d', barPath(bx, by, bw, bh))
              .attr('fill', fail ? failColor : colors[key])
              .attr('opacity', fail ? 0.85 : (isWinner ? 1 : 0.78))
              .on('mousemove', (event) => showTooltip(event, d, tabKey, series, colors, keys))
              .on('mouseleave', hideTip);
          }

          // Value label on top of bar
          if (val > 0 && bh > 14) {
            gGroup.append('text')
              .attr('class', 'bar-value')
              .attr('x', bx + bw / 2)
              .attr('y', by - 4)
              .attr('text-anchor', 'middle')
              .attr('fill', fail ? failColor : 'var(--text-color, #1f2937)')
              .attr('font-weight', fail ? '700' : '600')
              .text(val.toFixed(1));
          } else if (val === 0) {
            // Warning icon for 0% (HarmBench mean-pool)
            gGroup.append('text')
              .attr('class', 'failure-icon')
              .attr('x', bx + bw / 2)
              .attr('y', innerHeight - 8)
              .attr('text-anchor', 'middle')
              .attr('fill', failColor)
              .text('0%');
          } else if (bh > 0 && bh <= 14) {
            gGroup.append('text')
              .attr('class', 'bar-value')
              .attr('x', bx + bw / 2)
              .attr('y', by - 4)
              .attr('text-anchor', 'middle')
              .attr('fill', fail ? failColor : 'var(--text-color, #1f2937)')
              .attr('font-size', '8px')
              .text(val.toFixed(1));
          }

          // Warning triangle for catastrophic failures
          if (fail && val > 0) {
            gGroup.append('text')
              .attr('class', 'failure-icon')
              .attr('x', bx + bw / 2)
              .attr('y', by - 14)
              .attr('text-anchor', 'middle')
              .attr('fill', failColor)
              .attr('font-size', '12px')
              .text('\u26A0');
          }
        });
      });
    }

    function showTooltip(event, d, tabKey, series, colors, keys) {
      const best = keys.reduce((a, b) => d[a] >= d[b] ? a : b);
      let html = `<div class="tt-task">${d.task}</div>`;
      series.forEach(s => {
        const val = d[s.key];
        const fail = isFailure(tabKey, s.key, d.task, val);
        const win = s.key === best;
        const cls = fail ? 'failure' : (win ? 'winner' : '');
        html += `<div class="tt-row">
          <span class="tt-label"><span class="tt-dot" style="background:${RESOLVED[s.key] || colors[s.key]}"></span>${s.label}</span>
          <span class="tt-value ${cls}">${val.toFixed(2)}%${fail ? ' \u26A0' : ''}${win ? ' \u2605' : ''}</span>
        </div>`;
      });
      showTip(event, html);
    }

    // ---- INIT ----
    async function init() {
      await loadData();
      render();

      // Responsive
      if (window.ResizeObserver) {
        new ResizeObserver(() => render()).observe(container);
      } else {
        window.addEventListener('resize', () => render());
      }

      // Dark mode
      const mo = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === 'attributes' && m.attributeName === 'data-theme') {
            render();
            break;
          }
        }
      });
      mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
    }

    init();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
  } else {
    ensureD3(bootstrap);
  }
})();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Left: pooling strategy comparison. Right: positive vs. negative correlation features. Toggle tabs to explore.</figcaption></figure> </div>
<h3 id="positive-vs-negative-features"><a href="#positive-vs-negative-features">Positive vs. Negative Features</a></h3>
<p>Steering with negatively correlated features provides no improvement (Neg-S) or severe degradation (Neg-A: MMLU-Pro drops to 0.66%). SAE activations are non-negative; steering should <strong>amplify success</strong>, not suppress failure. The ablation chart above (tab 2) shows this clearly.</p>
<h3 id="control-experiments"><a href="#control-experiments">Control Experiments</a></h3>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Controls confirm real signal</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p><strong>Label permutation:</strong> Randomly shuffled correctness labels yield 6.24% MMLU accuracy (near chance), confirming features capture genuine task structure, not artifacts.</p><p><strong>Random features:</strong> Random selection yields 6.29% MMLU accuracy, comparable to chance, confirming that correlation-based selection is essential, not just the steering mechanism itself.</p> </div> </div> </div> 
<h2 id="efficiency-and-scalability"><a href="#efficiency-and-scalability">Efficiency and Scalability</a></h2>
<p>CorrSteer is lightweight and practical:</p>
<ul>
<li><strong>Streaming correlation</strong> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> memory per feature, scaling to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>+ features</li>
<li><strong>~100 samples minimum</strong>, stable at ~4,000 samples</li>
<li><strong>No backward passes</strong>, no activation storage, no task-specific tuning</li>
<li><strong>Inference cost</strong>: only steering vectors needed; SAE not required at generation time</li>
<li><strong>Reversible</strong>: steering can be adjusted or removed without retraining</li>
</ul>
<div class="semi-wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Performance stabilizes at ~4,000 samples. Diminishing returns beyond this point.</figcaption><div class="html-embed__card"><div id="frag-fx5r69uajti"><div class="efficiency-chart" id="efficiency-chart"></div>
<style>
  .efficiency-chart {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
  }

  .efficiency-chart .ec-loading {
    text-align: center;
    padding: 60px 20px;
    font-size: 14px;
    color: var(--muted-color, #6b7280);
  }

  .efficiency-chart .ec-spinner {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 2px solid var(--border-color, #d2d2d7);
    border-top-color: #6B5CE7;
    border-radius: 50%;
    animation: ec-spin 0.7s linear infinite;
    margin-bottom: 12px;
  }

  @keyframes ec-spin {
    to { transform: rotate(360deg); }
  }

  .efficiency-chart .ec-panel {
    position: relative;
    width: 100%;
  }

  .efficiency-chart .ec-panel-title {
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted-color, #6b7280);
    margin: 16px 0 4px;
    padding-left: 4px;
  }

  .efficiency-chart .ec-panel-title:first-child {
    margin-top: 0;
  }

  .efficiency-chart svg {
    display: block;
    width: 100%;
    height: auto;
  }

  .efficiency-chart .axis path { display: none; }
  .efficiency-chart .axis line { stroke: var(--border-color, #d1d5db); }
  .efficiency-chart .axis text {
    fill: var(--muted-color, #6b7280);
    font-size: 11px;
  }

  .efficiency-chart .grid line {
    stroke: var(--border-color, rgba(0,0,0,0.06));
    stroke-dasharray: 3,3;
    stroke-width: 1;
  }

  .efficiency-chart .ec-legend {
    display: flex;
    justify-content: center;
    gap: 16px;
    flex-wrap: wrap;
    margin: 8px 0 4px;
  }

  .efficiency-chart .ec-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-color, #1f2937);
    cursor: default;
  }

  .efficiency-chart .ec-legend-line {
    width: 20px;
    height: 0;
    border-top-width: 2.5px;
    border-top-style: solid;
    flex-shrink: 0;
  }

  .efficiency-chart .ec-legend-dashed {
    width: 20px;
    height: 0;
    border-top-width: 1.5px;
    border-top-style: dashed;
    flex-shrink: 0;
  }

  .efficiency-chart .ec-legend-dashed-long {
    width: 20px;
    height: 0;
    border-top-width: 1.5px;
    flex-shrink: 0;
  }

  .efficiency-chart .ec-colorbar {
    position: absolute;
    right: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }

  .efficiency-chart .ec-colorbar-label {
    font-size: 10px;
    font-weight: 600;
    color: var(--muted-color, #6b7280);
  }

  .efficiency-chart .ec-colorbar-gradient {
    width: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color, #d1d5db);
  }

  .efficiency-chart .ec-colorbar-tick {
    font-size: 9px;
    color: var(--muted-color, #6b7280);
    font-variant-numeric: tabular-nums;
  }

  /* Tooltip */
  .efficiency-chart .ec-tooltip {
    position: absolute;
    pointer-events: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.45;
    border: 1px solid var(--border-color, #e2e5ea);
    background: var(--surface-bg, #fff);
    color: var(--text-color, #1f2937);
    box-shadow: 0 4px 24px rgba(0,0,0,0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 10;
    max-width: 260px;
    transform: translate(-9999px, -9999px);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .efficiency-chart .ec-tooltip .tt-title {
    font-weight: 700;
    margin-bottom: 6px;
    font-size: 13px;
  }

  .efficiency-chart .ec-tooltip .tt-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 14px;
    padding: 1.5px 0;
  }

  .efficiency-chart .ec-tooltip .tt-label {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--muted-color, #6b7280);
  }

  .efficiency-chart .ec-tooltip .tt-dot {
    display: inline-block;
    width: 10px;
    height: 3px;
    border-radius: 1px;
    flex-shrink: 0;
  }

  .efficiency-chart .ec-tooltip .tt-value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
  }

  .efficiency-chart .ec-error {
    text-align: center;
    padding: 40px 20px;
    color: #e15759;
    font-size: 14px;
  }

  .efficiency-chart .ec-separator {
    height: 1px;
    background: var(--border-color, #e2e5ea);
    margin: 8px 0;
  }

  @media (max-width: 600px) {
    .efficiency-chart .ec-legend { gap: 8px; }
    .efficiency-chart .ec-legend-item { font-size: 10px; }
    .efficiency-chart .ec-colorbar { right: 2px; }
  }
</style>
<script>
(() => {
  if (window.__efficiencyChartInit) return;
  window.__efficiencyChartInit = true;

  const ensureD3 = (cb) => {
    if (window.d3 && typeof window.d3.select === 'function') return cb();
    let s = document.getElementById('d3-cdn-script');
    if (!s) {
      s = document.createElement('script');
      s.id = 'd3-cdn-script';
      s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
      document.head.appendChild(s);
    }
    const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
    s.addEventListener('load', onReady, { once: true });
    if (window.d3) onReady();
  };

  const bootstrap = () => {
    const scriptEl = document.currentScript;
    let container = scriptEl ? scriptEl.previousElementSibling : null;
    if (!(container && container.classList && container.classList.contains('efficiency-chart'))) {
      const cs = Array.from(document.querySelectorAll('.efficiency-chart'))
        .filter(el => !(el.dataset && el.dataset.mounted === 'true'));
      container = cs[cs.length - 1] || null;
    }
    if (!container) return;
    if (container.dataset) {
      if (container.dataset.mounted === 'true') return;
      container.dataset.mounted = 'true';
    }
    container.style.position = 'relative';

    const d3 = window.d3;

    // ---- Theme ----
    const isDark = () => document.documentElement.getAttribute('data-theme') === 'dark';
    const palette = () => isDark()
      ? {
          text: '#e5e7eb', muted: '#9ca3af', axis: '#6b7280',
          grid: 'rgba(255,255,255,0.07)', border: 'rgba(255,255,255,0.1)',
          surfaceBg: '#1a1d28', pageBg: '#0f1115',
          crosshair: 'rgba(255,255,255,0.25)',
          baselineLight: 'rgba(255,255,255,0.35)', baselineDark: 'rgba(255,255,255,0.5)',
          highlightBg: 'rgba(255,255,255,0.06)'
        }
      : {
          text: '#1f2937', muted: '#6b7280', axis: '#9ca3af',
          grid: 'rgba(0,0,0,0.06)', border: '#e2e5ea',
          surfaceBg: '#fff', pageBg: '#fff',
          crosshair: 'rgba(0,0,0,0.15)',
          baselineLight: 'rgba(0,0,0,0.2)', baselineDark: 'rgba(0,0,0,0.35)',
          highlightBg: 'rgba(0,0,0,0.04)'
        };

    // ---- Colors ----
    const PRIMARY = '#6B5CE7';
    const SECONDARY = '#22C55E';
    const BASELINE_WITHOUT = '#9ca3af';
    const BASELINE_CD = '#6b7280';

    // Viridis-like colorscale for layers 1-25
    function layerColor(layerNum) {
      // Use d3.interpolateViridis: 0 = dark purple, 1 = yellow
      const t = (layerNum - 1) / 24;
      return d3.interpolateViridis(t);
    }

    // ---- Loading ----
    container.innerHTML = '<div class="ec-loading"><div class="ec-spinner"></div><div>Loading training data...</div></div>';

    // ---- Tooltip ----
    let tooltip;

    function showTooltip(event, html, panelEl) {
      tooltip.innerHTML = html;
      tooltip.style.opacity = '1';
      const [px, py] = d3.pointer(event, container);
      const cw = container.clientWidth;
      const tipW = tooltip.offsetWidth || 220;
      const tipH = tooltip.offsetHeight || 100;
      let tx = px + 16;
      let ty = py - tipH / 2;
      if (tx + tipW > cw) tx = px - tipW - 16;
      if (ty < 0) ty = 4;
      if (ty + tipH > container.clientHeight) ty = container.clientHeight - tipH - 4;
      tooltip.style.transform = `translate(${tx}px, ${ty}px)`;
    }

    function hideTooltip() {
      tooltip.style.opacity = '0';
      setTimeout(() => { tooltip.style.transform = 'translate(-9999px, -9999px)'; }, 120);
    }

    // ---- Data loading ----
    let DATA = null;
    async function loadData() {
      const paths = [
        '/data/mmlu_progress.json',
        './assets/data/mmlu_progress.json',
        '../assets/data/mmlu_progress.json',
        '/assets/data/mmlu_progress.json',
        '../../assets/data/mmlu_progress.json'
      ];
      for (const p of paths) {
        try {
          const res = await fetch(p);
          if (res.ok) { DATA = await res.json(); return true; }
        } catch (_) {}
      }
      return false;
    }

    // ---- Build UI elements ----
    let topPanelDiv, bottomPanelDiv;
    let topSvg, topG, bottomSvg, bottomG;
    let topCrosshair, bottomCrosshair;
    let bottomHighlightLine;
    let colorbarDiv;

    // Shared dimensions
    const topHeight = 280;
    const bottomHeight = 260;
    const colorbarWidth = 50;

    function buildUI() {
      container.innerHTML = '';

      // Tooltip
      tooltip = document.createElement('div');
      tooltip.className = 'ec-tooltip';
      container.appendChild(tooltip);

      // ---- Top panel ----
      const topTitle = document.createElement('div');
      topTitle.className = 'ec-panel-title';
      topTitle.textContent = 'MMLU Accuracy & Matched Layers';
      container.appendChild(topTitle);

      // Legend for top panel
      const topLegend = document.createElement('div');
      topLegend.className = 'ec-legend';
      topLegend.innerHTML = `
        <span class="ec-legend-item">
          <span class="ec-legend-line" style="border-top-color:${PRIMARY}"></span>
          <span>Accuracy (%)</span>
        </span>
        <span class="ec-legend-item">
          <span class="ec-legend-line" style="border-top-color:${SECONDARY}"></span>
          <span>Matched Layers</span>
        </span>
        <span class="ec-legend-item">
          <span class="ec-legend-dashed" style="border-top-color:${BASELINE_WITHOUT}"></span>
          <span>w/o Steering (55.2%)</span>
        </span>
        <span class="ec-legend-item">
          <span class="ec-legend-dashed-long" style="border-top-color:${BASELINE_CD}; border-top-style: dashed; border-top-width: 2px; background-image: repeating-linear-gradient(90deg, ${BASELINE_CD} 0, ${BASELINE_CD} 6px, transparent 6px, transparent 10px);"></span>
          <span>Constrained Dec. (51.9%)</span>
        </span>
      `;
      container.appendChild(topLegend);

      topPanelDiv = document.createElement('div');
      topPanelDiv.className = 'ec-panel';
      container.appendChild(topPanelDiv);

      // Separator
      const sep = document.createElement('div');
      sep.className = 'ec-separator';
      container.appendChild(sep);

      // ---- Bottom panel ----
      const bottomTitle = document.createElement('div');
      bottomTitle.className = 'ec-panel-title';
      bottomTitle.textContent = 'Per-Layer Correlation Over Training';
      container.appendChild(bottomTitle);

      bottomPanelDiv = document.createElement('div');
      bottomPanelDiv.className = 'ec-panel';
      bottomPanelDiv.style.position = 'relative';
      container.appendChild(bottomPanelDiv);
    }

    // ---- Render ----
    function render() {
      if (!DATA) return;
      const p = palette();
      const containerWidth = container.clientWidth || 700;

      // Update panel title colors
      container.querySelectorAll('.ec-panel-title').forEach(el => el.style.color = p.muted);
      // Update legend text colors
      container.querySelectorAll('.ec-legend-item span:last-child').forEach(el => el.style.color = p.text);
      // Update separator
      const sep = container.querySelector('.ec-separator');
      if (sep) sep.style.background = p.border;

      renderTopPanel(containerWidth, p);
      renderBottomPanel(containerWidth, p);
    }

    function renderTopPanel(containerWidth, p) {
      topPanelDiv.innerHTML = '';

      const margin = { top: 14, right: 60, bottom: 36, left: 52 };
      const innerWidth = containerWidth - margin.left - margin.right;
      const innerHeight = topHeight - margin.top - margin.bottom;

      const svg = d3.select(topPanelDiv)
        .append('svg')
        .attr('viewBox', `0 0 ${containerWidth} ${topHeight}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      // Scales
      const xScale = d3.scaleLinear()
        .domain([0, d3.max(DATA.steps)])
        .range([0, innerWidth]);

      const yAccMin = Math.min(51, d3.min(DATA.accuracy) - 0.5);
      const yAccMax = Math.max(57, d3.max(DATA.accuracy) + 0.5);
      const yAcc = d3.scaleLinear()
        .domain([yAccMin, yAccMax])
        .range([innerHeight, 0])
        .nice();

      const yCount = d3.scaleLinear()
        .domain([0, 25])
        .range([innerHeight, 0]);

      // Grid lines (horizontal, left Y)
      const gridTicks = yAcc.ticks(5);
      g.append('g').attr('class', 'grid')
        .selectAll('line')
        .data(gridTicks)
        .join('line')
        .attr('x1', 0).attr('x2', innerWidth)
        .attr('y1', d => yAcc(d)).attr('y2', d => yAcc(d))
        .attr('stroke', p.grid)
        .attr('stroke-dasharray', '3,3');

      // Baselines
      // w/o steering at 55.2%
      g.append('line')
        .attr('x1', 0).attr('x2', innerWidth)
        .attr('y1', yAcc(55.2)).attr('y2', yAcc(55.2))
        .attr('stroke', p.baselineLight)
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '4,4');

      g.append('text')
        .attr('x', innerWidth - 4)
        .attr('y', yAcc(55.2) - 5)
        .attr('text-anchor', 'end')
        .attr('fill', p.baselineLight)
        .attr('font-size', '9.5px')
        .attr('font-weight', '500')
        .text('w/o steering');

      // Constrained Decoding at 51.9%
      g.append('line')
        .attr('x1', 0).attr('x2', innerWidth)
        .attr('y1', yAcc(51.9)).attr('y2', yAcc(51.9))
        .attr('stroke', p.baselineDark)
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '8,4');

      g.append('text')
        .attr('x', innerWidth - 4)
        .attr('y', yAcc(51.9) - 5)
        .attr('text-anchor', 'end')
        .attr('fill', p.baselineDark)
        .attr('font-size', '9.5px')
        .attr('font-weight', '500')
        .text('constrained dec.');

      // X axis
      g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(xScale).ticks(8).tickSizeOuter(0))
        .selectAll('text').attr('fill', p.muted);

      // X label
      g.append('text')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 32)
        .attr('text-anchor', 'middle')
        .attr('fill', p.muted)
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Training Step');

      // Left Y axis (accuracy)
      const yAccAxis = g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yAcc).ticks(5).tickFormat(d => d + '%').tickSizeOuter(0));
      yAccAxis.selectAll('text').attr('fill', PRIMARY);

      g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -innerHeight / 2)
        .attr('y', -38)
        .attr('text-anchor', 'middle')
        .attr('fill', PRIMARY)
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Accuracy (%)');

      // Right Y axis (matched count)
      const yCountAxis = g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(${innerWidth},0)`)
        .call(d3.axisRight(yCount).ticks(5).tickSizeOuter(0));
      yCountAxis.selectAll('text').attr('fill', SECONDARY);

      g.append('text')
        .attr('transform', 'rotate(90)')
        .attr('x', innerHeight / 2)
        .attr('y', -innerWidth - 46)
        .attr('text-anchor', 'middle')
        .attr('fill', SECONDARY)
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Matched Layers');

      // Line generators
      const lineAcc = d3.line()
        .x((d, i) => xScale(DATA.steps[i]))
        .y(d => yAcc(d))
        .curve(d3.curveMonotoneX);

      const lineCount = d3.line()
        .x((d, i) => xScale(DATA.steps[i]))
        .y(d => yCount(d))
        .curve(d3.curveMonotoneX);

      // Accuracy line
      g.append('path')
        .datum(DATA.accuracy)
        .attr('fill', 'none')
        .attr('stroke', PRIMARY)
        .attr('stroke-width', 2.5)
        .attr('stroke-linejoin', 'round')
        .attr('stroke-linecap', 'round')
        .attr('d', lineAcc);

      // Accuracy dots (small)
      g.selectAll('.acc-dot')
        .data(DATA.accuracy)
        .join('circle')
        .attr('class', 'acc-dot')
        .attr('cx', (d, i) => xScale(DATA.steps[i]))
        .attr('cy', d => yAcc(d))
        .attr('r', 2.5)
        .attr('fill', PRIMARY)
        .attr('stroke', 'none');

      // Matched count line
      g.append('path')
        .datum(DATA.matched_count)
        .attr('fill', 'none')
        .attr('stroke', SECONDARY)
        .attr('stroke-width', 2)
        .attr('stroke-linejoin', 'round')
        .attr('stroke-linecap', 'round')
        .attr('d', lineCount);

      // Matched count circle markers
      g.selectAll('.count-dot')
        .data(DATA.matched_count)
        .join('circle')
        .attr('class', 'count-dot')
        .attr('cx', (d, i) => xScale(DATA.steps[i]))
        .attr('cy', d => yCount(d))
        .attr('r', 3.5)
        .attr('fill', isDark() ? '#0f1115' : '#fff')
        .attr('stroke', SECONDARY)
        .attr('stroke-width', 2);

      // Vertical crosshair line (hidden initially)
      const crosshairLine = g.append('line')
        .attr('class', 'top-crosshair')
        .attr('y1', 0).attr('y2', innerHeight)
        .attr('stroke', p.crosshair)
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,3')
        .style('display', 'none');

      // Focus dots
      const focusDotAcc = g.append('circle')
        .attr('r', 5).attr('fill', PRIMARY).attr('stroke', isDark() ? '#0f1115' : '#fff')
        .attr('stroke-width', 2).style('display', 'none');

      const focusDotCount = g.append('circle')
        .attr('r', 5).attr('fill', SECONDARY).attr('stroke', isDark() ? '#0f1115' : '#fff')
        .attr('stroke-width', 2).style('display', 'none');

      // Overlay for mouse interaction
      const overlay = g.append('rect')
        .attr('width', innerWidth)
        .attr('height', innerHeight)
        .attr('fill', 'transparent')
        .style('cursor', 'crosshair');

      const bisect = d3.bisector(d => d).left;

      overlay.on('mousemove', function(event) {
        const [mx] = d3.pointer(event, this);
        const x0 = xScale.invert(mx);
        let idx = bisect(DATA.steps, x0);
        if (idx >= DATA.steps.length) idx = DATA.steps.length - 1;
        if (idx > 0) {
          const d0 = DATA.steps[idx - 1], d1 = DATA.steps[idx];
          if (x0 - d0 < d1 - x0) idx = idx - 1;
        }

        const step = DATA.steps[idx];
        const acc = DATA.accuracy[idx];
        const count = DATA.matched_count[idx];
        const cx = xScale(step);

        crosshairLine.attr('x1', cx).attr('x2', cx).style('display', null);
        focusDotAcc.attr('cx', cx).attr('cy', yAcc(acc)).style('display', null);
        focusDotCount.attr('cx', cx).attr('cy', yCount(count)).style('display', null);

        const html = `
          <div class="tt-title">Step ${step}</div>
          <div class="tt-row">
            <span class="tt-label"><span class="tt-dot" style="background:${PRIMARY}"></span>Accuracy</span>
            <span class="tt-value">${acc.toFixed(2)}%</span>
          </div>
          <div class="tt-row">
            <span class="tt-label"><span class="tt-dot" style="background:${SECONDARY}"></span>Matched</span>
            <span class="tt-value">${count} / 25</span>
          </div>
        `;
        showTooltip(event, html, topPanelDiv);
      });

      overlay.on('mouseleave', function() {
        crosshairLine.style('display', 'none');
        focusDotAcc.style('display', 'none');
        focusDotCount.style('display', 'none');
        hideTooltip();
      });
    }

    function renderBottomPanel(containerWidth, p) {
      bottomPanelDiv.innerHTML = '';

      const cbW = 60;
      const margin = { top: 14, right: cbW + 20, bottom: 36, left: 52 };
      const innerWidth = containerWidth - margin.left - margin.right;
      const innerHeight = bottomHeight - margin.top - margin.bottom;

      const svg = d3.select(bottomPanelDiv)
        .append('svg')
        .attr('viewBox', `0 0 ${containerWidth} ${bottomHeight}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      // Scales
      const xScale = d3.scaleLinear()
        .domain([0, d3.max(DATA.steps)])
        .range([0, innerWidth]);

      // Find max correlation value
      let corrMax = 0;
      for (let l = 1; l <= 25; l++) {
        const vals = DATA.layers[String(l)];
        if (vals) {
          const mx = d3.max(vals);
          if (mx > corrMax) corrMax = mx;
        }
      }
      corrMax = Math.ceil(corrMax * 20) / 20; // round up to nearest 0.05

      const yScale = d3.scaleLinear()
        .domain([0, corrMax])
        .range([innerHeight, 0])
        .nice();

      // Grid
      const gridTicks = yScale.ticks(5);
      g.append('g').attr('class', 'grid')
        .selectAll('line')
        .data(gridTicks)
        .join('line')
        .attr('x1', 0).attr('x2', innerWidth)
        .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
        .attr('stroke', p.grid)
        .attr('stroke-dasharray', '3,3');

      // X axis
      g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(xScale).ticks(8).tickSizeOuter(0))
        .selectAll('text').attr('fill', p.muted);

      // X label
      g.append('text')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 32)
        .attr('text-anchor', 'middle')
        .attr('fill', p.muted)
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Training Step');

      // Y axis
      g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0))
        .selectAll('text').attr('fill', p.muted);

      g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -innerHeight / 2)
        .attr('y', -38)
        .attr('text-anchor', 'middle')
        .attr('fill', p.muted)
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text('Correlation');

      // Line generator
      const lineGen = d3.line()
        .x((d, i) => xScale(DATA.steps[i]))
        .y(d => yScale(d))
        .curve(d3.curveMonotoneX);

      // Draw all 25 layer lines
      const layerPaths = [];
      for (let l = 1; l <= 25; l++) {
        const vals = DATA.layers[String(l)];
        if (!vals) continue;
        const path = g.append('path')
          .datum(vals)
          .attr('fill', 'none')
          .attr('stroke', layerColor(l))
          .attr('stroke-width', 1.5)
          .attr('stroke-linejoin', 'round')
          .attr('stroke-linecap', 'round')
          .attr('opacity', 0.65)
          .attr('d', lineGen);
        layerPaths.push({ layer: l, path: path, vals: vals });
      }

      // Highlight line (thicker, on top)
      const highlightPath = g.append('path')
        .attr('fill', 'none')
        .attr('stroke-width', 3.5)
        .attr('stroke-linejoin', 'round')
        .attr('stroke-linecap', 'round')
        .attr('opacity', 0)
        .style('pointer-events', 'none');

      // Crosshair
      const crosshairLine = g.append('line')
        .attr('y1', 0).attr('y2', innerHeight)
        .attr('stroke', p.crosshair)
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,3')
        .style('display', 'none');

      // Focus dot
      const focusDot = g.append('circle')
        .attr('r', 5)
        .attr('stroke', isDark() ? '#0f1115' : '#fff')
        .attr('stroke-width', 2)
        .style('display', 'none');

      // Overlay
      const overlay = g.append('rect')
        .attr('width', innerWidth)
        .attr('height', innerHeight)
        .attr('fill', 'transparent')
        .style('cursor', 'crosshair');

      const bisect = d3.bisector(d => d).left;

      overlay.on('mousemove', function(event) {
        const [mx, my] = d3.pointer(event, this);
        const x0 = xScale.invert(mx);
        let idx = bisect(DATA.steps, x0);
        if (idx >= DATA.steps.length) idx = DATA.steps.length - 1;
        if (idx > 0) {
          const d0 = DATA.steps[idx - 1], d1 = DATA.steps[idx];
          if (x0 - d0 < d1 - x0) idx = idx - 1;
        }

        const step = DATA.steps[idx];
        const cx = xScale(step);

        // Find nearest layer to mouse Y
        const yVal = yScale.invert(my);
        let nearestLayer = 1;
        let nearestDist = Infinity;
        for (let l = 1; l <= 25; l++) {
          const vals = DATA.layers[String(l)];
          if (!vals) continue;
          const v = vals[idx];
          const dist = Math.abs(v - yVal);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestLayer = l;
          }
        }

        const nearestVal = DATA.layers[String(nearestLayer)][idx];
        const color = layerColor(nearestLayer);

        // Crosshair
        crosshairLine.attr('x1', cx).attr('x2', cx).style('display', null);

        // Focus dot
        focusDot
          .attr('cx', cx)
          .attr('cy', yScale(nearestVal))
          .attr('fill', color)
          .style('display', null);

        // Dim other lines, highlight nearest
        layerPaths.forEach(lp => {
          lp.path.attr('opacity', lp.layer === nearestLayer ? 0.9 : 0.15)
            .attr('stroke-width', lp.layer === nearestLayer ? 2.5 : 1);
        });

        // Highlight path
        highlightPath
          .datum(DATA.layers[String(nearestLayer)])
          .attr('stroke', color)
          .attr('opacity', 1)
          .attr('d', lineGen);

        // Tooltip
        const html = `
          <div class="tt-title">Step ${step}</div>
          <div class="tt-row">
            <span class="tt-label"><span class="tt-dot" style="background:${color}"></span>Layer ${nearestLayer}</span>
            <span class="tt-value">${nearestVal.toFixed(4)}</span>
          </div>
        `;
        showTooltip(event, html, bottomPanelDiv);
      });

      overlay.on('mouseleave', function() {
        crosshairLine.style('display', 'none');
        focusDot.style('display', 'none');
        highlightPath.attr('opacity', 0);
        layerPaths.forEach(lp => {
          lp.path.attr('opacity', 0.65).attr('stroke-width', 1.5);
        });
        hideTooltip();
      });

      // ---- Colorbar ----
      const cbHeight = innerHeight;
      const cbX = margin.left + innerWidth + 16;
      const cbY = margin.top;
      const cbBarW = 12;

      // Gradient definition
      const defs = svg.append('defs');
      const gradId = 'ec-viridis-grad-' + Math.random().toString(36).slice(2, 8);
      const grad = defs.append('linearGradient')
        .attr('id', gradId)
        .attr('x1', '0').attr('y1', '1')
        .attr('x2', '0').attr('y2', '0');

      for (let i = 0; i <= 10; i++) {
        const t = i / 10;
        grad.append('stop')
          .attr('offset', `${t * 100}%`)
          .attr('stop-color', d3.interpolateViridis(t));
      }

      const cbGroup = svg.append('g')
        .attr('transform', `translate(${cbX}, ${cbY})`);

      cbGroup.append('text')
        .attr('x', cbBarW / 2)
        .attr('y', -5)
        .attr('text-anchor', 'middle')
        .attr('fill', p.muted)
        .attr('font-size', '10px')
        .attr('font-weight', '600')
        .text('Layer');

      cbGroup.append('rect')
        .attr('x', 0).attr('y', 0)
        .attr('width', cbBarW)
        .attr('height', cbHeight)
        .attr('rx', 3)
        .attr('fill', `url(#${gradId})`)
        .attr('stroke', p.border)
        .attr('stroke-width', 1);

      // Tick labels for colorbar
      const cbScale = d3.scaleLinear().domain([1, 25]).range([cbHeight, 0]);
      const cbTicks = [1, 5, 10, 15, 20, 25];
      cbTicks.forEach(l => {
        cbGroup.append('text')
          .attr('x', cbBarW + 5)
          .attr('y', cbScale(l))
          .attr('dy', '0.35em')
          .attr('fill', p.muted)
          .attr('font-size', '9px')
          .attr('font-variant-numeric', 'tabular-nums')
          .text(l);
      });
    }

    // ---- Initialize ----
    async function init() {
      const ok = await loadData();
      if (!ok) {
        container.innerHTML = '<div class="ec-error">Failed to load training progress data.</div>';
        return;
      }

      buildUI();
      render();

      // Responsive
      if (window.ResizeObserver) {
        new ResizeObserver(() => render()).observe(container);
      } else {
        window.addEventListener('resize', render);
      }

      // Dark mode
      const mo = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === 'attributes' && m.attributeName === 'data-theme') {
            buildUI();
            render();
            break;
          }
        }
      });
      mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
    }

    init();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
  } else {
    ensureD3(bootstrap);
  }
})();
</script></div></div></figure> </div>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>CorrSteer demonstrates that correlation-based feature selection from generation-time SAE activations provides an effective, interpretable, and low-side-effect approach to LLM steering. By treating correlation as a selection heuristic and intervention as the causal test, it bridges the gap between interpretability research and practical model control.</p>
<p>The method’s interpretability advantage is unique: every steering decision is traceable to specific, human-readable SAE features. This transparency is essential for deploying steering in safety-critical applications.</p>
<hr/>
<p><strong>Resources:</strong></p>
<ul>
<li>Paper: <a href="https://arxiv.org/abs/2508.12535">arXiv:2508.12535</a></li>
<li>Code: <a href="https://github.com/seonglae/CorrSteer">github.com/seonglae/CorrSteer</a></li>
</ul> </main> </section> <footer class="footer"> <div class="footer-inner"> <section class="citation-block"> <h3>Citation</h3> <p>For attribution in academic contexts, please cite this work as</p> <pre class="citation short">Seonglae Cho, Zekun Wu, Adriano Koshiyama (2025). &quot;CorrSteer: Generation-Time LLM Steering via Correlated Sparse Autoencoder Features&quot;.</pre> <p>BibTeX citation</p> <pre class="citation long">@article{cho2025corrsteer,
  title={CorrSteer: Generation-Time LLM Steering via Correlated Sparse Autoencoder Features},
  author={Seonglae Cho and Zekun Wu and Adriano Koshiyama},
  year={2025},
  eprint={2508.12535},
  archivePrefix={arXiv},
  primaryClass={cs.CL},
  url={https://arxiv.org/abs/2508.12535},
  
}</pre> </section>  <section class="reuse-block"> <h3>Reuse</h3> <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</p> </section> <section class="references-block">  </section> <div class="template-credit"> <p>
Made with ❤️ with <a href="https://huggingface.co/spaces/tfrere/research-article-template" target="_blank" rel="noopener noreferrer">research article template</a> </p> </div> </div> </footer> <script>
  (() => {
    const getFooter = () =>
      document.currentScript?.closest("footer") ||
      document.querySelector("footer.footer");
    const footer = getFooter();
    if (!footer) return;
    const target = footer.querySelector(".references-block");
    if (!target) return;

    const contentRoot =
      document.querySelector("section.content-grid main") ||
      document.querySelector("main") ||
      document.body;

    const ensureHeading = (text) => {
      const exists = Array.from(target.children).some(
        (c) =>
          c.tagName === "H3" &&
          c.textContent.trim().toLowerCase() === text.toLowerCase(),
      );
      if (!exists) {
        const h = document.createElement("h3");
        h.textContent = text;
        target.appendChild(h);
      }
    };

    const moveIntoFooter = (element, headingText) => {
      if (!element) return false;
      // Remove an eventual heading already included inside the block (avoid duplicates)
      const firstHeading = element.querySelector(
        ":scope > h1, :scope > h2, :scope > h3",
      );
      if (firstHeading) {
        const txt = (firstHeading.textContent || "").trim().toLowerCase();
        const targetTxt = headingText.trim().toLowerCase();
        if (
          txt === targetTxt ||
          txt.includes("reference") ||
          txt.includes("bibliograph")
        ) {
          firstHeading.remove();
        }
      }

      // Move footnote backref links inside paragraphs
      if (element.classList && element.classList.contains("footnotes")) {
        const footnoteItems = element.querySelectorAll("li");
        footnoteItems.forEach((item) => {
          const backrefContainer = item.querySelector("small.backrefs");
          const lastP = item.querySelector("p:last-of-type");
          if (backrefContainer && lastP && !lastP.contains(backrefContainer)) {
            lastP.appendChild(document.createTextNode(" "));
            lastP.appendChild(backrefContainer);
          }
        });
      }

      ensureHeading(headingText);
      target.appendChild(element);
      return true;
    };
    const run = () => {
      const findFirstOutsideFooter = (selectors) => {
        for (const sel of selectors) {
          const el = contentRoot.querySelector(sel);
          if (el && !footer.contains(el)) return el;
        }
        return null;
      };

      const referencesEl = findFirstOutsideFooter([
        "#bibliography-references-list",
        "[data-bibliography-block]",
        "#references",
        "#refs",
        ".references",
        ".bibliography",
      ]);
      const footnotesEl = findFirstOutsideFooter([".footnotes"]);

      const movedRefs = moveIntoFooter(referencesEl, "References");
      const movedNotes = moveIntoFooter(footnotesEl, "Footnotes");
      return movedRefs || movedNotes;
    };

    // Try now; if not found yet, try again on DOM ready
    const done = run();
    if (!done) {
      const onReady = () => run();
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", onReady, { once: true });
      } else {
        setTimeout(onReady, 0);
      }
    }

    // Resize on window changes (e.g., fonts, layout)
    // No textarea auto-resize needed for <pre> blocks
  })();
</script>    </body> </html>